/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!*****************************************!*\
  !*** ./node_modules/mithril/mithril.js ***!
  \*****************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(setImmediate, global) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n;(function () {\n\t\"use strict\";\n\n\tfunction Vnode(tag, key, attrs0, children, text, dom) {\n\t\treturn { tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false };\n\t}\n\tVnode.normalize = function (node) {\n\t\tif (Array.isArray(node)) return Vnode(\"[\", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined);\n\t\tif (node != null && (typeof node === \"undefined\" ? \"undefined\" : _typeof(node)) !== \"object\") return Vnode(\"#\", undefined, undefined, node === false ? \"\" : node, undefined, undefined);\n\t\treturn node;\n\t};\n\tVnode.normalizeChildren = function normalizeChildren(children) {\n\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\tchildren[i] = Vnode.normalize(children[i]);\n\t\t}\n\t\treturn children;\n\t};\n\tvar selectorParser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[(.+?)(?:\\s*=\\s*(\"|'|)((?:\\\\[\"'\\]]|.)*?)\\5)?\\])/g;\n\tvar selectorCache = {};\n\tvar hasOwn = {}.hasOwnProperty;\n\tfunction isEmpty(object) {\n\t\tfor (var key in object) {\n\t\t\tif (hasOwn.call(object, key)) return false;\n\t\t}return true;\n\t}\n\tfunction compileSelector(selector) {\n\t\tvar match,\n\t\t    tag = \"div\",\n\t\t    classes = [],\n\t\t    attrs = {};\n\t\twhile (match = selectorParser.exec(selector)) {\n\t\t\tvar type = match[1],\n\t\t\t    value = match[2];\n\t\t\tif (type === \"\" && value !== \"\") tag = value;else if (type === \"#\") attrs.id = value;else if (type === \".\") classes.push(value);else if (match[3][0] === \"[\") {\n\t\t\t\tvar attrValue = match[6];\n\t\t\t\tif (attrValue) attrValue = attrValue.replace(/\\\\([\"'])/g, \"$1\").replace(/\\\\\\\\/g, \"\\\\\");\n\t\t\t\tif (match[4] === \"class\") classes.push(attrValue);else attrs[match[4]] = attrValue === \"\" ? attrValue : attrValue || true;\n\t\t\t}\n\t\t}\n\t\tif (classes.length > 0) attrs.className = classes.join(\" \");\n\t\treturn selectorCache[selector] = { tag: tag, attrs: attrs };\n\t}\n\tfunction execSelector(state, attrs, children) {\n\t\tvar hasAttrs = false,\n\t\t    childList,\n\t\t    text;\n\t\tvar className = attrs.className || attrs.class;\n\t\tif (!isEmpty(state.attrs) && !isEmpty(attrs)) {\n\t\t\tvar newAttrs = {};\n\t\t\tfor (var key in attrs) {\n\t\t\t\tif (hasOwn.call(attrs, key)) {\n\t\t\t\t\tnewAttrs[key] = attrs[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\tattrs = newAttrs;\n\t\t}\n\t\tfor (var key in state.attrs) {\n\t\t\tif (hasOwn.call(state.attrs, key)) {\n\t\t\t\tattrs[key] = state.attrs[key];\n\t\t\t}\n\t\t}\n\t\tif (className !== undefined) {\n\t\t\tif (attrs.class !== undefined) {\n\t\t\t\tattrs.class = undefined;\n\t\t\t\tattrs.className = className;\n\t\t\t}\n\t\t\tif (state.attrs.className != null) {\n\t\t\t\tattrs.className = state.attrs.className + \" \" + className;\n\t\t\t}\n\t\t}\n\t\tfor (var key in attrs) {\n\t\t\tif (hasOwn.call(attrs, key) && key !== \"key\") {\n\t\t\t\thasAttrs = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === \"#\") {\n\t\t\ttext = children[0].children;\n\t\t} else {\n\t\t\tchildList = children;\n\t\t}\n\t\treturn Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text);\n\t}\n\tfunction hyperscript(selector) {\n\t\t// Because sloppy mode sucks\n\t\tvar attrs = arguments[1],\n\t\t    start = 2,\n\t\t    children;\n\t\tif (selector == null || typeof selector !== \"string\" && typeof selector !== \"function\" && typeof selector.view !== \"function\") {\n\t\t\tthrow Error(\"The selector must be either a string or a component.\");\n\t\t}\n\t\tif (typeof selector === \"string\") {\n\t\t\tvar cached = selectorCache[selector] || compileSelector(selector);\n\t\t}\n\t\tif (attrs == null) {\n\t\t\tattrs = {};\n\t\t} else if ((typeof attrs === \"undefined\" ? \"undefined\" : _typeof(attrs)) !== \"object\" || attrs.tag != null || Array.isArray(attrs)) {\n\t\t\tattrs = {};\n\t\t\tstart = 1;\n\t\t}\n\t\tif (arguments.length === start + 1) {\n\t\t\tchildren = arguments[start];\n\t\t\tif (!Array.isArray(children)) children = [children];\n\t\t} else {\n\t\t\tchildren = [];\n\t\t\twhile (start < arguments.length) {\n\t\t\t\tchildren.push(arguments[start++]);\n\t\t\t}\n\t\t}\n\t\tvar normalized = Vnode.normalizeChildren(children);\n\t\tif (typeof selector === \"string\") {\n\t\t\treturn execSelector(cached, attrs, normalized);\n\t\t} else {\n\t\t\treturn Vnode(selector, attrs.key, attrs, normalized);\n\t\t}\n\t}\n\thyperscript.trust = function (html) {\n\t\tif (html == null) html = \"\";\n\t\treturn Vnode(\"<\", undefined, undefined, html, undefined, undefined);\n\t};\n\thyperscript.fragment = function (attrs1, children) {\n\t\treturn Vnode(\"[\", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined);\n\t};\n\tvar m = hyperscript;\n\t/** @constructor */\n\tvar PromisePolyfill = function PromisePolyfill(executor) {\n\t\tif (!(this instanceof PromisePolyfill)) throw new Error(\"Promise must be called with `new`\");\n\t\tif (typeof executor !== \"function\") throw new TypeError(\"executor must be a function\");\n\t\tvar self = this,\n\t\t    resolvers = [],\n\t\t    rejectors = [],\n\t\t    resolveCurrent = handler(resolvers, true),\n\t\t    rejectCurrent = handler(rejectors, false);\n\t\tvar instance = self._instance = { resolvers: resolvers, rejectors: rejectors };\n\t\tvar callAsync = typeof setImmediate === \"function\" ? setImmediate : setTimeout;\n\t\tfunction handler(list, shouldAbsorb) {\n\t\t\treturn function execute(value) {\n\t\t\t\tvar then;\n\t\t\t\ttry {\n\t\t\t\t\tif (shouldAbsorb && value != null && ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" || typeof value === \"function\") && typeof (then = value.then) === \"function\") {\n\t\t\t\t\t\tif (value === self) throw new TypeError(\"Promise can't be resolved w/ itself\");\n\t\t\t\t\t\texecuteOnce(then.bind(value));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallAsync(function () {\n\t\t\t\t\t\t\tif (!shouldAbsorb && list.length === 0) console.error(\"Possible unhandled promise rejection:\", value);\n\t\t\t\t\t\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\t\t\t\t\t\tlist[i](value);\n\t\t\t\t\t\t\t}resolvers.length = 0, rejectors.length = 0;\n\t\t\t\t\t\t\tinstance.state = shouldAbsorb;\n\t\t\t\t\t\t\tinstance.retry = function () {\n\t\t\t\t\t\t\t\texecute(value);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\trejectCurrent(e);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tfunction executeOnce(then) {\n\t\t\tvar runs = 0;\n\t\t\tfunction run(fn) {\n\t\t\t\treturn function (value) {\n\t\t\t\t\tif (runs++ > 0) return;\n\t\t\t\t\tfn(value);\n\t\t\t\t};\n\t\t\t}\n\t\t\tvar onerror = run(rejectCurrent);\n\t\t\ttry {\n\t\t\t\tthen(run(resolveCurrent), onerror);\n\t\t\t} catch (e) {\n\t\t\t\tonerror(e);\n\t\t\t}\n\t\t}\n\t\texecuteOnce(executor);\n\t};\n\tPromisePolyfill.prototype.then = function (onFulfilled, onRejection) {\n\t\tvar self = this,\n\t\t    instance = self._instance;\n\t\tfunction handle(callback, list, next, state) {\n\t\t\tlist.push(function (value) {\n\t\t\t\tif (typeof callback !== \"function\") next(value);else try {\n\t\t\t\t\tresolveNext(callback(value));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (rejectNext) rejectNext(e);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (typeof instance.retry === \"function\" && state === instance.state) instance.retry();\n\t\t}\n\t\tvar resolveNext, rejectNext;\n\t\tvar promise = new PromisePolyfill(function (resolve, reject) {\n\t\t\tresolveNext = resolve, rejectNext = reject;\n\t\t});\n\t\thandle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false);\n\t\treturn promise;\n\t};\n\tPromisePolyfill.prototype.catch = function (onRejection) {\n\t\treturn this.then(null, onRejection);\n\t};\n\tPromisePolyfill.resolve = function (value) {\n\t\tif (value instanceof PromisePolyfill) return value;\n\t\treturn new PromisePolyfill(function (resolve) {\n\t\t\tresolve(value);\n\t\t});\n\t};\n\tPromisePolyfill.reject = function (value) {\n\t\treturn new PromisePolyfill(function (resolve, reject) {\n\t\t\treject(value);\n\t\t});\n\t};\n\tPromisePolyfill.all = function (list) {\n\t\treturn new PromisePolyfill(function (resolve, reject) {\n\t\t\tvar total = list.length,\n\t\t\t    count = 0,\n\t\t\t    values = [];\n\t\t\tif (list.length === 0) resolve([]);else for (var i = 0; i < list.length; i++) {\n\t\t\t\t(function (i) {\n\t\t\t\t\tfunction consume(value) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tvalues[i] = value;\n\t\t\t\t\t\tif (count === total) resolve(values);\n\t\t\t\t\t}\n\t\t\t\t\tif (list[i] != null && (_typeof(list[i]) === \"object\" || typeof list[i] === \"function\") && typeof list[i].then === \"function\") {\n\t\t\t\t\t\tlist[i].then(consume, reject);\n\t\t\t\t\t} else consume(list[i]);\n\t\t\t\t})(i);\n\t\t\t}\n\t\t});\n\t};\n\tPromisePolyfill.race = function (list) {\n\t\treturn new PromisePolyfill(function (resolve, reject) {\n\t\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\t\tlist[i].then(resolve, reject);\n\t\t\t}\n\t\t});\n\t};\n\tif (typeof window !== \"undefined\") {\n\t\tif (typeof window.Promise === \"undefined\") window.Promise = PromisePolyfill;\n\t\tvar PromisePolyfill = window.Promise;\n\t} else if (typeof global !== \"undefined\") {\n\t\tif (typeof global.Promise === \"undefined\") global.Promise = PromisePolyfill;\n\t\tvar PromisePolyfill = global.Promise;\n\t} else {}\n\tvar buildQueryString = function buildQueryString(object) {\n\t\tif (Object.prototype.toString.call(object) !== \"[object Object]\") return \"\";\n\t\tvar args = [];\n\t\tfor (var key0 in object) {\n\t\t\tdestructure(key0, object[key0]);\n\t\t}\n\t\treturn args.join(\"&\");\n\t\tfunction destructure(key0, value) {\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\t\tdestructure(key0 + \"[\" + i + \"]\", value[i]);\n\t\t\t\t}\n\t\t\t} else if (Object.prototype.toString.call(value) === \"[object Object]\") {\n\t\t\t\tfor (var i in value) {\n\t\t\t\t\tdestructure(key0 + \"[\" + i + \"]\", value[i]);\n\t\t\t\t}\n\t\t\t} else args.push(encodeURIComponent(key0) + (value != null && value !== \"\" ? \"=\" + encodeURIComponent(value) : \"\"));\n\t\t}\n\t};\n\tvar FILE_PROTOCOL_REGEX = new RegExp(\"^file://\", \"i\");\n\tvar _8 = function _8($window, Promise) {\n\t\tvar callbackCount = 0;\n\t\tvar oncompletion;\n\t\tfunction setCompletionCallback(callback) {\n\t\t\toncompletion = callback;\n\t\t}\n\t\tfunction finalizer() {\n\t\t\tvar count = 0;\n\t\t\tfunction complete() {\n\t\t\t\tif (--count === 0 && typeof oncompletion === \"function\") oncompletion();\n\t\t\t}\n\t\t\treturn function finalize(promise0) {\n\t\t\t\tvar then0 = promise0.then;\n\t\t\t\tpromise0.then = function () {\n\t\t\t\t\tcount++;\n\t\t\t\t\tvar next = then0.apply(promise0, arguments);\n\t\t\t\t\tnext.then(complete, function (e) {\n\t\t\t\t\t\tcomplete();\n\t\t\t\t\t\tif (count === 0) throw e;\n\t\t\t\t\t});\n\t\t\t\t\treturn finalize(next);\n\t\t\t\t};\n\t\t\t\treturn promise0;\n\t\t\t};\n\t\t}\n\t\tfunction normalize(args, extra) {\n\t\t\tif (typeof args === \"string\") {\n\t\t\t\tvar url = args;\n\t\t\t\targs = extra || {};\n\t\t\t\tif (args.url == null) args.url = url;\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\t\tfunction request(args, extra) {\n\t\t\tvar finalize = finalizer();\n\t\t\targs = normalize(args, extra);\n\t\t\tvar promise0 = new Promise(function (resolve, reject) {\n\t\t\t\tif (args.method == null) args.method = \"GET\";\n\t\t\t\targs.method = args.method.toUpperCase();\n\t\t\t\tvar useBody = args.method === \"GET\" || args.method === \"TRACE\" ? false : typeof args.useBody === \"boolean\" ? args.useBody : true;\n\t\t\t\tif (typeof args.serialize !== \"function\") args.serialize = typeof FormData !== \"undefined\" && args.data instanceof FormData ? function (value) {\n\t\t\t\t\treturn value;\n\t\t\t\t} : JSON.stringify;\n\t\t\t\tif (typeof args.deserialize !== \"function\") args.deserialize = deserialize;\n\t\t\t\tif (typeof args.extract !== \"function\") args.extract = extract;\n\t\t\t\targs.url = interpolate(args.url, args.data);\n\t\t\t\tif (useBody) args.data = args.serialize(args.data);else args.url = assemble(args.url, args.data);\n\t\t\t\tvar xhr = new $window.XMLHttpRequest(),\n\t\t\t\t    aborted = false,\n\t\t\t\t    _abort = xhr.abort;\n\t\t\t\txhr.abort = function abort() {\n\t\t\t\t\taborted = true;\n\t\t\t\t\t_abort.call(xhr);\n\t\t\t\t};\n\t\t\t\txhr.open(args.method, args.url, typeof args.async === \"boolean\" ? args.async : true, typeof args.user === \"string\" ? args.user : undefined, typeof args.password === \"string\" ? args.password : undefined);\n\t\t\t\tif (args.serialize === JSON.stringify && useBody && !(args.headers && args.headers.hasOwnProperty(\"Content-Type\"))) {\n\t\t\t\t\txhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\");\n\t\t\t\t}\n\t\t\t\tif (args.deserialize === deserialize && !(args.headers && args.headers.hasOwnProperty(\"Accept\"))) {\n\t\t\t\t\txhr.setRequestHeader(\"Accept\", \"application/json, text/*\");\n\t\t\t\t}\n\t\t\t\tif (args.withCredentials) xhr.withCredentials = args.withCredentials;\n\t\t\t\tfor (var key in args.headers) {\n\t\t\t\t\tif ({}.hasOwnProperty.call(args.headers, key)) {\n\t\t\t\t\t\txhr.setRequestHeader(key, args.headers[key]);\n\t\t\t\t\t}\n\t\t\t\t}if (typeof args.config === \"function\") xhr = args.config(xhr, args) || xhr;\n\t\t\t\txhr.onreadystatechange = function () {\n\t\t\t\t\t// Don't throw errors on xhr.abort().\n\t\t\t\t\tif (aborted) return;\n\t\t\t\t\tif (xhr.readyState === 4) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar response = args.extract !== extract ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args));\n\t\t\t\t\t\t\tif (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {\n\t\t\t\t\t\t\t\tresolve(cast(args.type, response));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar error = new Error(xhr.responseText);\n\t\t\t\t\t\t\t\tfor (var key in response) {\n\t\t\t\t\t\t\t\t\terror[key] = response[key];\n\t\t\t\t\t\t\t\t}reject(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\treject(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif (useBody && args.data != null) xhr.send(args.data);else xhr.send();\n\t\t\t});\n\t\t\treturn args.background === true ? promise0 : finalize(promise0);\n\t\t}\n\t\tfunction jsonp(args, extra) {\n\t\t\tvar finalize = finalizer();\n\t\t\targs = normalize(args, extra);\n\t\t\tvar promise0 = new Promise(function (resolve, reject) {\n\t\t\t\tvar callbackName = args.callbackName || \"_mithril_\" + Math.round(Math.random() * 1e16) + \"_\" + callbackCount++;\n\t\t\t\tvar script = $window.document.createElement(\"script\");\n\t\t\t\t$window[callbackName] = function (data) {\n\t\t\t\t\tscript.parentNode.removeChild(script);\n\t\t\t\t\tresolve(cast(args.type, data));\n\t\t\t\t\tdelete $window[callbackName];\n\t\t\t\t};\n\t\t\t\tscript.onerror = function () {\n\t\t\t\t\tscript.parentNode.removeChild(script);\n\t\t\t\t\treject(new Error(\"JSONP request failed\"));\n\t\t\t\t\tdelete $window[callbackName];\n\t\t\t\t};\n\t\t\t\tif (args.data == null) args.data = {};\n\t\t\t\targs.url = interpolate(args.url, args.data);\n\t\t\t\targs.data[args.callbackKey || \"callback\"] = callbackName;\n\t\t\t\tscript.src = assemble(args.url, args.data);\n\t\t\t\t$window.document.documentElement.appendChild(script);\n\t\t\t});\n\t\t\treturn args.background === true ? promise0 : finalize(promise0);\n\t\t}\n\t\tfunction interpolate(url, data) {\n\t\t\tif (data == null) return url;\n\t\t\tvar tokens = url.match(/:[^\\/]+/gi) || [];\n\t\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\t\tvar key = tokens[i].slice(1);\n\t\t\t\tif (data[key] != null) {\n\t\t\t\t\turl = url.replace(tokens[i], data[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn url;\n\t\t}\n\t\tfunction assemble(url, data) {\n\t\t\tvar querystring = buildQueryString(data);\n\t\t\tif (querystring !== \"\") {\n\t\t\t\tvar prefix = url.indexOf(\"?\") < 0 ? \"?\" : \"&\";\n\t\t\t\turl += prefix + querystring;\n\t\t\t}\n\t\t\treturn url;\n\t\t}\n\t\tfunction deserialize(data) {\n\t\t\ttry {\n\t\t\t\treturn data !== \"\" ? JSON.parse(data) : null;\n\t\t\t} catch (e) {\n\t\t\t\tthrow new Error(data);\n\t\t\t}\n\t\t}\n\t\tfunction extract(xhr) {\n\t\t\treturn xhr.responseText;\n\t\t}\n\t\tfunction cast(type0, data) {\n\t\t\tif (typeof type0 === \"function\") {\n\t\t\t\tif (Array.isArray(data)) {\n\t\t\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\t\t\tdata[i] = new type0(data[i]);\n\t\t\t\t\t}\n\t\t\t\t} else return new type0(data);\n\t\t\t}\n\t\t\treturn data;\n\t\t}\n\t\treturn { request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback };\n\t};\n\tvar requestService = _8(window, PromisePolyfill);\n\tvar coreRenderer = function coreRenderer($window) {\n\t\tvar $doc = $window.document;\n\t\tvar $emptyFragment = $doc.createDocumentFragment();\n\t\tvar nameSpace = {\n\t\t\tsvg: \"http://www.w3.org/2000/svg\",\n\t\t\tmath: \"http://www.w3.org/1998/Math/MathML\"\n\t\t};\n\t\tvar onevent;\n\t\tfunction setEventCallback(callback) {\n\t\t\treturn onevent = callback;\n\t\t}\n\t\tfunction getNameSpace(vnode) {\n\t\t\treturn vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag];\n\t\t}\n\t\t//create\n\t\tfunction createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {\n\t\t\tfor (var i = start; i < end; i++) {\n\t\t\t\tvar vnode = vnodes[i];\n\t\t\t\tif (vnode != null) {\n\t\t\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfunction createNode(parent, vnode, hooks, ns, nextSibling) {\n\t\t\tvar tag = vnode.tag;\n\t\t\tif (typeof tag === \"string\") {\n\t\t\t\tvnode.state = {};\n\t\t\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);\n\t\t\t\tswitch (tag) {\n\t\t\t\t\tcase \"#\":\n\t\t\t\t\t\treturn createText(parent, vnode, nextSibling);\n\t\t\t\t\tcase \"<\":\n\t\t\t\t\t\treturn createHTML(parent, vnode, nextSibling);\n\t\t\t\t\tcase \"[\":\n\t\t\t\t\t\treturn createFragment(parent, vnode, hooks, ns, nextSibling);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn createElement(parent, vnode, hooks, ns, nextSibling);\n\t\t\t\t}\n\t\t\t} else return createComponent(parent, vnode, hooks, ns, nextSibling);\n\t\t}\n\t\tfunction createText(parent, vnode, nextSibling) {\n\t\t\tvnode.dom = $doc.createTextNode(vnode.children);\n\t\t\tinsertNode(parent, vnode.dom, nextSibling);\n\t\t\treturn vnode.dom;\n\t\t}\n\t\tfunction createHTML(parent, vnode, nextSibling) {\n\t\t\tvar match1 = vnode.children.match(/^\\s*?<(\\w+)/im) || [];\n\t\t\tvar parent1 = { caption: \"table\", thead: \"table\", tbody: \"table\", tfoot: \"table\", tr: \"tbody\", th: \"tr\", td: \"tr\", colgroup: \"table\", col: \"colgroup\" }[match1[1]] || \"div\";\n\t\t\tvar temp = $doc.createElement(parent1);\n\t\t\ttemp.innerHTML = vnode.children;\n\t\t\tvnode.dom = temp.firstChild;\n\t\t\tvnode.domSize = temp.childNodes.length;\n\t\t\tvar fragment = $doc.createDocumentFragment();\n\t\t\tvar child;\n\t\t\twhile (child = temp.firstChild) {\n\t\t\t\tfragment.appendChild(child);\n\t\t\t}\n\t\t\tinsertNode(parent, fragment, nextSibling);\n\t\t\treturn fragment;\n\t\t}\n\t\tfunction createFragment(parent, vnode, hooks, ns, nextSibling) {\n\t\t\tvar fragment = $doc.createDocumentFragment();\n\t\t\tif (vnode.children != null) {\n\t\t\t\tvar children = vnode.children;\n\t\t\t\tcreateNodes(fragment, children, 0, children.length, hooks, null, ns);\n\t\t\t}\n\t\t\tvnode.dom = fragment.firstChild;\n\t\t\tvnode.domSize = fragment.childNodes.length;\n\t\t\tinsertNode(parent, fragment, nextSibling);\n\t\t\treturn fragment;\n\t\t}\n\t\tfunction createElement(parent, vnode, hooks, ns, nextSibling) {\n\t\t\tvar tag = vnode.tag;\n\t\t\tvar attrs2 = vnode.attrs;\n\t\t\tvar is = attrs2 && attrs2.is;\n\t\t\tns = getNameSpace(vnode) || ns;\n\t\t\tvar element = ns ? is ? $doc.createElementNS(ns, tag, { is: is }) : $doc.createElementNS(ns, tag) : is ? $doc.createElement(tag, { is: is }) : $doc.createElement(tag);\n\t\t\tvnode.dom = element;\n\t\t\tif (attrs2 != null) {\n\t\t\t\tsetAttrs(vnode, attrs2, ns);\n\t\t\t}\n\t\t\tinsertNode(parent, element, nextSibling);\n\t\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\t\tsetContentEditable(vnode);\n\t\t\t} else {\n\t\t\t\tif (vnode.text != null) {\n\t\t\t\t\tif (vnode.text !== \"\") element.textContent = vnode.text;else vnode.children = [Vnode(\"#\", undefined, undefined, vnode.text, undefined, undefined)];\n\t\t\t\t}\n\t\t\t\tif (vnode.children != null) {\n\t\t\t\t\tvar children = vnode.children;\n\t\t\t\t\tcreateNodes(element, children, 0, children.length, hooks, null, ns);\n\t\t\t\t\tsetLateAttrs(vnode);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn element;\n\t\t}\n\t\tfunction initComponent(vnode, hooks) {\n\t\t\tvar sentinel;\n\t\t\tif (typeof vnode.tag.view === \"function\") {\n\t\t\t\tvnode.state = Object.create(vnode.tag);\n\t\t\t\tsentinel = vnode.state.view;\n\t\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment;\n\t\t\t\tsentinel.$$reentrantLock$$ = true;\n\t\t\t} else {\n\t\t\t\tvnode.state = void 0;\n\t\t\t\tsentinel = vnode.tag;\n\t\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment;\n\t\t\t\tsentinel.$$reentrantLock$$ = true;\n\t\t\t\tvnode.state = vnode.tag.prototype != null && typeof vnode.tag.prototype.view === \"function\" ? new vnode.tag(vnode) : vnode.tag(vnode);\n\t\t\t}\n\t\t\tvnode._state = vnode.state;\n\t\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);\n\t\t\tinitLifecycle(vnode._state, vnode, hooks);\n\t\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode));\n\t\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\");\n\t\t\tsentinel.$$reentrantLock$$ = null;\n\t\t}\n\t\tfunction createComponent(parent, vnode, hooks, ns, nextSibling) {\n\t\t\tinitComponent(vnode, hooks);\n\t\t\tif (vnode.instance != null) {\n\t\t\t\tvar element = createNode(parent, vnode.instance, hooks, ns, nextSibling);\n\t\t\t\tvnode.dom = vnode.instance.dom;\n\t\t\t\tvnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0;\n\t\t\t\tinsertNode(parent, element, nextSibling);\n\t\t\t\treturn element;\n\t\t\t} else {\n\t\t\t\tvnode.domSize = 0;\n\t\t\t\treturn $emptyFragment;\n\t\t\t}\n\t\t}\n\t\t//update\n\t\tfunction updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {\n\t\t\tif (old === vnodes || old == null && vnodes == null) return;else if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns);else if (vnodes == null) removeNodes(old, 0, old.length, vnodes);else {\n\t\t\t\tif (old.length === vnodes.length) {\n\t\t\t\t\tvar isUnkeyed = false;\n\t\t\t\t\tfor (var i = 0; i < vnodes.length; i++) {\n\t\t\t\t\t\tif (vnodes[i] != null && old[i] != null) {\n\t\t\t\t\t\t\tisUnkeyed = vnodes[i].key == null && old[i].key == null;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (isUnkeyed) {\n\t\t\t\t\t\tfor (var i = 0; i < old.length; i++) {\n\t\t\t\t\t\t\tif (old[i] === vnodes[i]) continue;else if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling));else if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes);else updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trecycling = recycling || isRecyclable(old, vnodes);\n\t\t\t\tif (recycling) {\n\t\t\t\t\tvar pool = old.pool;\n\t\t\t\t\told = old.concat(old.pool);\n\t\t\t\t}\n\t\t\t\tvar oldStart = 0,\n\t\t\t\t    start = 0,\n\t\t\t\t    oldEnd = old.length - 1,\n\t\t\t\t    end = vnodes.length - 1,\n\t\t\t\t    map;\n\t\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\t\tvar o = old[oldStart],\n\t\t\t\t\t    v = vnodes[start];\n\t\t\t\t\tif (o === v && !recycling) oldStart++, start++;else if (o == null) oldStart++;else if (v == null) start++;else if (o.key === v.key) {\n\t\t\t\t\t\tvar shouldRecycle = pool != null && oldStart >= old.length - pool.length || pool == null && recycling;\n\t\t\t\t\t\toldStart++, start++;\n\t\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns);\n\t\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar o = old[oldEnd];\n\t\t\t\t\t\tif (o === v && !recycling) oldEnd--, start++;else if (o == null) oldEnd--;else if (v == null) start++;else if (o.key === v.key) {\n\t\t\t\t\t\t\tvar shouldRecycle = pool != null && oldEnd >= old.length - pool.length || pool == null && recycling;\n\t\t\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns);\n\t\t\t\t\t\t\tif (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling));\n\t\t\t\t\t\t\toldEnd--, start++;\n\t\t\t\t\t\t} else break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\t\tvar o = old[oldEnd],\n\t\t\t\t\t    v = vnodes[end];\n\t\t\t\t\tif (o === v && !recycling) oldEnd--, end--;else if (o == null) oldEnd--;else if (v == null) end--;else if (o.key === v.key) {\n\t\t\t\t\t\tvar shouldRecycle = pool != null && oldEnd >= old.length - pool.length || pool == null && recycling;\n\t\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns);\n\t\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling);\n\t\t\t\t\t\tif (o.dom != null) nextSibling = o.dom;\n\t\t\t\t\t\toldEnd--, end--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!map) map = getKeyMap(old, oldEnd);\n\t\t\t\t\t\tif (v != null) {\n\t\t\t\t\t\t\tvar oldIndex = map[v.key];\n\t\t\t\t\t\t\tif (oldIndex != null) {\n\t\t\t\t\t\t\t\tvar movable = old[oldIndex];\n\t\t\t\t\t\t\t\tvar shouldRecycle = pool != null && oldIndex >= old.length - pool.length || pool == null && recycling;\n\t\t\t\t\t\t\t\tupdateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns);\n\t\t\t\t\t\t\t\tinsertNode(parent, toFragment(movable), nextSibling);\n\t\t\t\t\t\t\t\told[oldIndex].skip = true;\n\t\t\t\t\t\t\t\tif (movable.dom != null) nextSibling = movable.dom;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar dom = createNode(parent, v, hooks, ns, nextSibling);\n\t\t\t\t\t\t\t\tnextSibling = dom;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tend--;\n\t\t\t\t\t}\n\t\t\t\t\tif (end < start) break;\n\t\t\t\t}\n\t\t\t\tcreateNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns);\n\t\t\t\tremoveNodes(old, oldStart, oldEnd + 1, vnodes);\n\t\t\t}\n\t\t}\n\t\tfunction updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\t\tvar oldTag = old.tag,\n\t\t\t    tag = vnode.tag;\n\t\t\tif (oldTag === tag) {\n\t\t\t\tvnode.state = old.state;\n\t\t\t\tvnode._state = old._state;\n\t\t\t\tvnode.events = old.events;\n\t\t\t\tif (!recycling && shouldNotUpdate(vnode, old)) return;\n\t\t\t\tif (typeof oldTag === \"string\") {\n\t\t\t\t\tif (vnode.attrs != null) {\n\t\t\t\t\t\tif (recycling) {\n\t\t\t\t\t\t\tvnode.state = {};\n\t\t\t\t\t\t\tinitLifecycle(vnode.attrs, vnode, hooks);\n\t\t\t\t\t\t} else updateLifecycle(vnode.attrs, vnode, hooks);\n\t\t\t\t\t}\n\t\t\t\t\tswitch (oldTag) {\n\t\t\t\t\t\tcase \"#\":\n\t\t\t\t\t\t\tupdateText(old, vnode);break;\n\t\t\t\t\t\tcase \"<\":\n\t\t\t\t\t\t\tupdateHTML(parent, old, vnode, nextSibling);break;\n\t\t\t\t\t\tcase \"[\":\n\t\t\t\t\t\t\tupdateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns);break;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tupdateElement(old, vnode, recycling, hooks, ns);\n\t\t\t\t\t}\n\t\t\t\t} else updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns);\n\t\t\t} else {\n\t\t\t\tremoveNode(old, null);\n\t\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling);\n\t\t\t}\n\t\t}\n\t\tfunction updateText(old, vnode) {\n\t\t\tif (old.children.toString() !== vnode.children.toString()) {\n\t\t\t\told.dom.nodeValue = vnode.children;\n\t\t\t}\n\t\t\tvnode.dom = old.dom;\n\t\t}\n\t\tfunction updateHTML(parent, old, vnode, nextSibling) {\n\t\t\tif (old.children !== vnode.children) {\n\t\t\t\ttoFragment(old);\n\t\t\t\tcreateHTML(parent, vnode, nextSibling);\n\t\t\t} else vnode.dom = old.dom, vnode.domSize = old.domSize;\n\t\t}\n\t\tfunction updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {\n\t\t\tupdateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns);\n\t\t\tvar domSize = 0,\n\t\t\t    children = vnode.children;\n\t\t\tvnode.dom = null;\n\t\t\tif (children != null) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tvar child = children[i];\n\t\t\t\t\tif (child != null && child.dom != null) {\n\t\t\t\t\t\tif (vnode.dom == null) vnode.dom = child.dom;\n\t\t\t\t\t\tdomSize += child.domSize || 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (domSize !== 1) vnode.domSize = domSize;\n\t\t\t}\n\t\t}\n\t\tfunction updateElement(old, vnode, recycling, hooks, ns) {\n\t\t\tvar element = vnode.dom = old.dom;\n\t\t\tns = getNameSpace(vnode) || ns;\n\t\t\tif (vnode.tag === \"textarea\") {\n\t\t\t\tif (vnode.attrs == null) vnode.attrs = {};\n\t\t\t\tif (vnode.text != null) {\n\t\t\t\t\tvnode.attrs.value = vnode.text; //FIXME handle0 multiple children\n\t\t\t\t\tvnode.text = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdateAttrs(vnode, old.attrs, vnode.attrs, ns);\n\t\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\t\tsetContentEditable(vnode);\n\t\t\t} else if (old.text != null && vnode.text != null && vnode.text !== \"\") {\n\t\t\t\tif (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text;\n\t\t\t} else {\n\t\t\t\tif (old.text != null) old.children = [Vnode(\"#\", undefined, undefined, old.text, undefined, old.dom.firstChild)];\n\t\t\t\tif (vnode.text != null) vnode.children = [Vnode(\"#\", undefined, undefined, vnode.text, undefined, undefined)];\n\t\t\t\tupdateNodes(element, old.children, vnode.children, recycling, hooks, null, ns);\n\t\t\t}\n\t\t}\n\t\tfunction updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\t\tif (recycling) {\n\t\t\t\tinitComponent(vnode, hooks);\n\t\t\t} else {\n\t\t\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode));\n\t\t\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\");\n\t\t\t\tif (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks);\n\t\t\t\tupdateLifecycle(vnode._state, vnode, hooks);\n\t\t\t}\n\t\t\tif (vnode.instance != null) {\n\t\t\t\tif (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling);else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns);\n\t\t\t\tvnode.dom = vnode.instance.dom;\n\t\t\t\tvnode.domSize = vnode.instance.domSize;\n\t\t\t} else if (old.instance != null) {\n\t\t\t\tremoveNode(old.instance, null);\n\t\t\t\tvnode.dom = undefined;\n\t\t\t\tvnode.domSize = 0;\n\t\t\t} else {\n\t\t\t\tvnode.dom = old.dom;\n\t\t\t\tvnode.domSize = old.domSize;\n\t\t\t}\n\t\t}\n\t\tfunction isRecyclable(old, vnodes) {\n\t\t\tif (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {\n\t\t\t\tvar oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0;\n\t\t\t\tvar poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0;\n\t\t\t\tvar vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0;\n\t\t\t\tif (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tfunction getKeyMap(vnodes, end) {\n\t\t\tvar map = {},\n\t\t\t    i = 0;\n\t\t\tfor (var i = 0; i < end; i++) {\n\t\t\t\tvar vnode = vnodes[i];\n\t\t\t\tif (vnode != null) {\n\t\t\t\t\tvar key2 = vnode.key;\n\t\t\t\t\tif (key2 != null) map[key2] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\t\tfunction toFragment(vnode) {\n\t\t\tvar count0 = vnode.domSize;\n\t\t\tif (count0 != null || vnode.dom == null) {\n\t\t\t\tvar fragment = $doc.createDocumentFragment();\n\t\t\t\tif (count0 > 0) {\n\t\t\t\t\tvar dom = vnode.dom;\n\t\t\t\t\twhile (--count0) {\n\t\t\t\t\t\tfragment.appendChild(dom.nextSibling);\n\t\t\t\t\t}fragment.insertBefore(dom, fragment.firstChild);\n\t\t\t\t}\n\t\t\t\treturn fragment;\n\t\t\t} else return vnode.dom;\n\t\t}\n\t\tfunction getNextSibling(vnodes, i, nextSibling) {\n\t\t\tfor (; i < vnodes.length; i++) {\n\t\t\t\tif (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom;\n\t\t\t}\n\t\t\treturn nextSibling;\n\t\t}\n\t\tfunction insertNode(parent, dom, nextSibling) {\n\t\t\tif (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling);else parent.appendChild(dom);\n\t\t}\n\t\tfunction setContentEditable(vnode) {\n\t\t\tvar children = vnode.children;\n\t\t\tif (children != null && children.length === 1 && children[0].tag === \"<\") {\n\t\t\t\tvar content = children[0].children;\n\t\t\t\tif (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content;\n\t\t\t} else if (vnode.text != null || children != null && children.length !== 0) throw new Error(\"Child node of a contenteditable must be trusted\");\n\t\t}\n\t\t//remove\n\t\tfunction removeNodes(vnodes, start, end, context) {\n\t\t\tfor (var i = start; i < end; i++) {\n\t\t\t\tvar vnode = vnodes[i];\n\t\t\t\tif (vnode != null) {\n\t\t\t\t\tif (vnode.skip) vnode.skip = false;else removeNode(vnode, context);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfunction removeNode(vnode, context) {\n\t\t\tvar expected = 1,\n\t\t\t    called = 0;\n\t\t\tif (vnode.attrs && typeof vnode.attrs.onbeforeremove === \"function\") {\n\t\t\t\tvar result = vnode.attrs.onbeforeremove.call(vnode.state, vnode);\n\t\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\t\texpected++;\n\t\t\t\t\tresult.then(continuation, continuation);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (typeof vnode.tag !== \"string\" && typeof vnode._state.onbeforeremove === \"function\") {\n\t\t\t\tvar result = vnode._state.onbeforeremove.call(vnode.state, vnode);\n\t\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\t\texpected++;\n\t\t\t\t\tresult.then(continuation, continuation);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinuation();\n\t\t\tfunction continuation() {\n\t\t\t\tif (++called === expected) {\n\t\t\t\t\tonremove(vnode);\n\t\t\t\t\tif (vnode.dom) {\n\t\t\t\t\t\tvar count0 = vnode.domSize || 1;\n\t\t\t\t\t\tif (count0 > 1) {\n\t\t\t\t\t\t\tvar dom = vnode.dom;\n\t\t\t\t\t\t\twhile (--count0) {\n\t\t\t\t\t\t\t\tremoveNodeFromDOM(dom.nextSibling);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremoveNodeFromDOM(vnode.dom);\n\t\t\t\t\t\tif (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === \"string\") {\n\t\t\t\t\t\t\t//TODO test custom elements\n\t\t\t\t\t\t\tif (!context.pool) context.pool = [vnode];else context.pool.push(vnode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfunction removeNodeFromDOM(node) {\n\t\t\tvar parent = node.parentNode;\n\t\t\tif (parent != null) parent.removeChild(node);\n\t\t}\n\t\tfunction onremove(vnode) {\n\t\t\tif (vnode.attrs && typeof vnode.attrs.onremove === \"function\") vnode.attrs.onremove.call(vnode.state, vnode);\n\t\t\tif (typeof vnode.tag !== \"string\") {\n\t\t\t\tif (typeof vnode._state.onremove === \"function\") vnode._state.onremove.call(vnode.state, vnode);\n\t\t\t\tif (vnode.instance != null) onremove(vnode.instance);\n\t\t\t} else {\n\t\t\t\tvar children = vnode.children;\n\t\t\t\tif (Array.isArray(children)) {\n\t\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\t\tvar child = children[i];\n\t\t\t\t\t\tif (child != null) onremove(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//attrs2\n\t\tfunction setAttrs(vnode, attrs2, ns) {\n\t\t\tfor (var key2 in attrs2) {\n\t\t\t\tsetAttr(vnode, key2, null, attrs2[key2], ns);\n\t\t\t}\n\t\t}\n\t\tfunction setAttr(vnode, key2, old, value, ns) {\n\t\t\tvar element = vnode.dom;\n\t\t\tif (key2 === \"key\" || key2 === \"is\" || old === value && !isFormAttribute(vnode, key2) && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\" || typeof value === \"undefined\" || isLifecycleMethod(key2)) return;\n\t\t\tvar nsLastIndex = key2.indexOf(\":\");\n\t\t\tif (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === \"xlink\") {\n\t\t\t\telement.setAttributeNS(\"http://www.w3.org/1999/xlink\", key2.slice(nsLastIndex + 1), value);\n\t\t\t} else if (key2[0] === \"o\" && key2[1] === \"n\" && typeof value === \"function\") updateEvent(vnode, key2, value);else if (key2 === \"style\") updateStyle(element, old, value);else if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {\n\t\t\t\tif (key2 === \"value\") {\n\t\t\t\t\tvar normalized0 = \"\" + value; // eslint-disable-line no-implicit-coercion\n\t\t\t\t\t//setting input[value] to same value by typing on focused element moves cursor to end in Chrome\n\t\t\t\t\tif ((vnode.tag === \"input\" || vnode.tag === \"textarea\") && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return;\n\t\t\t\t\t//setting select[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\t\tif (vnode.tag === \"select\") {\n\t\t\t\t\t\tif (value === null) {\n\t\t\t\t\t\t\tif (vnode.dom.selectedIndex === -1 && vnode.dom === $doc.activeElement) return;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (old !== null && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//setting option[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\t\tif (vnode.tag === \"option\" && old != null && vnode.dom.value === normalized0) return;\n\t\t\t\t}\n\t\t\t\t// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.\n\t\t\t\tif (vnode.tag === \"input\" && key2 === \"type\") {\n\t\t\t\t\telement.setAttribute(key2, value);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telement[key2] = value;\n\t\t\t} else {\n\t\t\t\tif (typeof value === \"boolean\") {\n\t\t\t\t\tif (value) element.setAttribute(key2, \"\");else element.removeAttribute(key2);\n\t\t\t\t} else element.setAttribute(key2 === \"className\" ? \"class\" : key2, value);\n\t\t\t}\n\t\t}\n\t\tfunction setLateAttrs(vnode) {\n\t\t\tvar attrs2 = vnode.attrs;\n\t\t\tif (vnode.tag === \"select\" && attrs2 != null) {\n\t\t\t\tif (\"value\" in attrs2) setAttr(vnode, \"value\", null, attrs2.value, undefined);\n\t\t\t\tif (\"selectedIndex\" in attrs2) setAttr(vnode, \"selectedIndex\", null, attrs2.selectedIndex, undefined);\n\t\t\t}\n\t\t}\n\t\tfunction updateAttrs(vnode, old, attrs2, ns) {\n\t\t\tif (attrs2 != null) {\n\t\t\t\tfor (var key2 in attrs2) {\n\t\t\t\t\tsetAttr(vnode, key2, old && old[key2], attrs2[key2], ns);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (old != null) {\n\t\t\t\tfor (var key2 in old) {\n\t\t\t\t\tif (attrs2 == null || !(key2 in attrs2)) {\n\t\t\t\t\t\tif (key2 === \"className\") key2 = \"class\";\n\t\t\t\t\t\tif (key2[0] === \"o\" && key2[1] === \"n\" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined);else if (key2 !== \"key\") vnode.dom.removeAttribute(key2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfunction isFormAttribute(vnode, attr) {\n\t\t\treturn attr === \"value\" || attr === \"checked\" || attr === \"selectedIndex\" || attr === \"selected\" && vnode.dom === $doc.activeElement;\n\t\t}\n\t\tfunction isLifecycleMethod(attr) {\n\t\t\treturn attr === \"oninit\" || attr === \"oncreate\" || attr === \"onupdate\" || attr === \"onremove\" || attr === \"onbeforeremove\" || attr === \"onbeforeupdate\";\n\t\t}\n\t\tfunction isAttribute(attr) {\n\t\t\treturn attr === \"href\" || attr === \"list\" || attr === \"form\" || attr === \"width\" || attr === \"height\"; // || attr === \"type\"\n\t\t}\n\t\tfunction isCustomElement(vnode) {\n\t\t\treturn vnode.attrs.is || vnode.tag.indexOf(\"-\") > -1;\n\t\t}\n\t\tfunction hasIntegrationMethods(source) {\n\t\t\treturn source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove);\n\t\t}\n\t\t//style\n\t\tfunction updateStyle(element, old, style) {\n\t\t\tif (old === style) element.style.cssText = \"\", old = null;\n\t\t\tif (style == null) element.style.cssText = \"\";else if (typeof style === \"string\") element.style.cssText = style;else {\n\t\t\t\tif (typeof old === \"string\") element.style.cssText = \"\";\n\t\t\t\tfor (var key2 in style) {\n\t\t\t\t\telement.style[key2] = style[key2];\n\t\t\t\t}\n\t\t\t\tif (old != null && typeof old !== \"string\") {\n\t\t\t\t\tfor (var key2 in old) {\n\t\t\t\t\t\tif (!(key2 in style)) element.style[key2] = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//event\n\t\tfunction updateEvent(vnode, key2, value) {\n\t\t\tvar element = vnode.dom;\n\t\t\tvar callback = typeof onevent !== \"function\" ? value : function (e) {\n\t\t\t\tvar result = value.call(element, e);\n\t\t\t\tonevent.call(element, e);\n\t\t\t\treturn result;\n\t\t\t};\n\t\t\tif (key2 in element) element[key2] = typeof value === \"function\" ? callback : null;else {\n\t\t\t\tvar eventName = key2.slice(2);\n\t\t\t\tif (vnode.events === undefined) vnode.events = {};\n\t\t\t\tif (vnode.events[key2] === callback) return;\n\t\t\t\tif (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false);\n\t\t\t\tif (typeof value === \"function\") {\n\t\t\t\t\tvnode.events[key2] = callback;\n\t\t\t\t\telement.addEventListener(eventName, vnode.events[key2], false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//lifecycle\n\t\tfunction initLifecycle(source, vnode, hooks) {\n\t\t\tif (typeof source.oninit === \"function\") source.oninit.call(vnode.state, vnode);\n\t\t\tif (typeof source.oncreate === \"function\") hooks.push(source.oncreate.bind(vnode.state, vnode));\n\t\t}\n\t\tfunction updateLifecycle(source, vnode, hooks) {\n\t\t\tif (typeof source.onupdate === \"function\") hooks.push(source.onupdate.bind(vnode.state, vnode));\n\t\t}\n\t\tfunction shouldNotUpdate(vnode, old) {\n\t\t\tvar forceVnodeUpdate, forceComponentUpdate;\n\t\t\tif (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === \"function\") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old);\n\t\t\tif (typeof vnode.tag !== \"string\" && typeof vnode._state.onbeforeupdate === \"function\") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old);\n\t\t\tif (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {\n\t\t\t\tvnode.dom = old.dom;\n\t\t\t\tvnode.domSize = old.domSize;\n\t\t\t\tvnode.instance = old.instance;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tfunction render(dom, vnodes) {\n\t\t\tif (!dom) throw new Error(\"Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.\");\n\t\t\tvar hooks = [];\n\t\t\tvar active = $doc.activeElement;\n\t\t\tvar namespace = dom.namespaceURI;\n\t\t\t// First time0 rendering into a node clears it out\n\t\t\tif (dom.vnodes == null) dom.textContent = \"\";\n\t\t\tif (!Array.isArray(vnodes)) vnodes = [vnodes];\n\t\t\tupdateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, namespace === \"http://www.w3.org/1999/xhtml\" ? undefined : namespace);\n\t\t\tdom.vnodes = vnodes;\n\t\t\t// document.activeElement can return null in IE https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement\n\t\t\tif (active != null && $doc.activeElement !== active) active.focus();\n\t\t\tfor (var i = 0; i < hooks.length; i++) {\n\t\t\t\thooks[i]();\n\t\t\t}\n\t\t}\n\t\treturn { render: render, setEventCallback: setEventCallback };\n\t};\n\tfunction throttle(callback) {\n\t\t//60fps translates to 16.6ms, round it down since setTimeout requires int\n\t\tvar time = 16;\n\t\tvar last = 0,\n\t\t    pending = null;\n\t\tvar timeout = typeof requestAnimationFrame === \"function\" ? requestAnimationFrame : setTimeout;\n\t\treturn function () {\n\t\t\tvar now = Date.now();\n\t\t\tif (last === 0 || now - last >= time) {\n\t\t\t\tlast = now;\n\t\t\t\tcallback();\n\t\t\t} else if (pending === null) {\n\t\t\t\tpending = timeout(function () {\n\t\t\t\t\tpending = null;\n\t\t\t\t\tcallback();\n\t\t\t\t\tlast = Date.now();\n\t\t\t\t}, time - (now - last));\n\t\t\t}\n\t\t};\n\t}\n\tvar _11 = function _11($window) {\n\t\tvar renderService = coreRenderer($window);\n\t\trenderService.setEventCallback(function (e) {\n\t\t\tif (e.redraw === false) e.redraw = undefined;else redraw();\n\t\t});\n\t\tvar callbacks = [];\n\t\tfunction subscribe(key1, callback) {\n\t\t\tunsubscribe(key1);\n\t\t\tcallbacks.push(key1, throttle(callback));\n\t\t}\n\t\tfunction unsubscribe(key1) {\n\t\t\tvar index = callbacks.indexOf(key1);\n\t\t\tif (index > -1) callbacks.splice(index, 2);\n\t\t}\n\t\tfunction redraw() {\n\t\t\tfor (var i = 1; i < callbacks.length; i += 2) {\n\t\t\t\tcallbacks[i]();\n\t\t\t}\n\t\t}\n\t\treturn { subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render };\n\t};\n\tvar redrawService = _11(window);\n\trequestService.setCompletionCallback(redrawService.redraw);\n\tvar _16 = function _16(redrawService0) {\n\t\treturn function (root, component) {\n\t\t\tif (component === null) {\n\t\t\t\tredrawService0.render(root, []);\n\t\t\t\tredrawService0.unsubscribe(root);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (component.view == null && typeof component !== \"function\") throw new Error(\"m.mount(element, component) expects a component, not a vnode\");\n\n\t\t\tvar run0 = function run0() {\n\t\t\t\tredrawService0.render(root, Vnode(component));\n\t\t\t};\n\t\t\tredrawService0.subscribe(root, run0);\n\t\t\tredrawService0.redraw();\n\t\t};\n\t};\n\tm.mount = _16(redrawService);\n\tvar Promise = PromisePolyfill;\n\tvar parseQueryString = function parseQueryString(string) {\n\t\tif (string === \"\" || string == null) return {};\n\t\tif (string.charAt(0) === \"?\") string = string.slice(1);\n\t\tvar entries = string.split(\"&\"),\n\t\t    data0 = {},\n\t\t    counters = {};\n\t\tfor (var i = 0; i < entries.length; i++) {\n\t\t\tvar entry = entries[i].split(\"=\");\n\t\t\tvar key5 = decodeURIComponent(entry[0]);\n\t\t\tvar value = entry.length === 2 ? decodeURIComponent(entry[1]) : \"\";\n\t\t\tif (value === \"true\") value = true;else if (value === \"false\") value = false;\n\t\t\tvar levels = key5.split(/\\]\\[?|\\[/);\n\t\t\tvar cursor = data0;\n\t\t\tif (key5.indexOf(\"[\") > -1) levels.pop();\n\t\t\tfor (var j = 0; j < levels.length; j++) {\n\t\t\t\tvar level = levels[j],\n\t\t\t\t    nextLevel = levels[j + 1];\n\t\t\t\tvar isNumber = nextLevel == \"\" || !isNaN(parseInt(nextLevel, 10));\n\t\t\t\tvar isValue = j === levels.length - 1;\n\t\t\t\tif (level === \"\") {\n\t\t\t\t\tvar key5 = levels.slice(0, j).join();\n\t\t\t\t\tif (counters[key5] == null) counters[key5] = 0;\n\t\t\t\t\tlevel = counters[key5]++;\n\t\t\t\t}\n\t\t\t\tif (cursor[level] == null) {\n\t\t\t\t\tcursor[level] = isValue ? value : isNumber ? [] : {};\n\t\t\t\t}\n\t\t\t\tcursor = cursor[level];\n\t\t\t}\n\t\t}\n\t\treturn data0;\n\t};\n\tvar coreRouter = function coreRouter($window) {\n\t\tvar supportsPushState = typeof $window.history.pushState === \"function\";\n\t\tvar callAsync0 = typeof setImmediate === \"function\" ? setImmediate : setTimeout;\n\t\tfunction normalize1(fragment0) {\n\t\t\tvar data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent);\n\t\t\tif (fragment0 === \"pathname\" && data[0] !== \"/\") data = \"/\" + data;\n\t\t\treturn data;\n\t\t}\n\t\tvar asyncId;\n\t\tfunction debounceAsync(callback0) {\n\t\t\treturn function () {\n\t\t\t\tif (asyncId != null) return;\n\t\t\t\tasyncId = callAsync0(function () {\n\t\t\t\t\tasyncId = null;\n\t\t\t\t\tcallback0();\n\t\t\t\t});\n\t\t\t};\n\t\t}\n\t\tfunction parsePath(path, queryData, hashData) {\n\t\t\tvar queryIndex = path.indexOf(\"?\");\n\t\t\tvar hashIndex = path.indexOf(\"#\");\n\t\t\tvar pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length;\n\t\t\tif (queryIndex > -1) {\n\t\t\t\tvar queryEnd = hashIndex > -1 ? hashIndex : path.length;\n\t\t\t\tvar queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd));\n\t\t\t\tfor (var key4 in queryParams) {\n\t\t\t\t\tqueryData[key4] = queryParams[key4];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hashIndex > -1) {\n\t\t\t\tvar hashParams = parseQueryString(path.slice(hashIndex + 1));\n\t\t\t\tfor (var key4 in hashParams) {\n\t\t\t\t\thashData[key4] = hashParams[key4];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn path.slice(0, pathEnd);\n\t\t}\n\t\tvar router = { prefix: \"#!\" };\n\t\trouter.getPath = function () {\n\t\t\tvar type2 = router.prefix.charAt(0);\n\t\t\tswitch (type2) {\n\t\t\t\tcase \"#\":\n\t\t\t\t\treturn normalize1(\"hash\").slice(router.prefix.length);\n\t\t\t\tcase \"?\":\n\t\t\t\t\treturn normalize1(\"search\").slice(router.prefix.length) + normalize1(\"hash\");\n\t\t\t\tdefault:\n\t\t\t\t\treturn normalize1(\"pathname\").slice(router.prefix.length) + normalize1(\"search\") + normalize1(\"hash\");\n\t\t\t}\n\t\t};\n\t\trouter.setPath = function (path, data, options) {\n\t\t\tvar queryData = {},\n\t\t\t    hashData = {};\n\t\t\tpath = parsePath(path, queryData, hashData);\n\t\t\tif (data != null) {\n\t\t\t\tfor (var key4 in data) {\n\t\t\t\t\tqueryData[key4] = data[key4];\n\t\t\t\t}path = path.replace(/:([^\\/]+)/g, function (match2, token) {\n\t\t\t\t\tdelete queryData[token];\n\t\t\t\t\treturn data[token];\n\t\t\t\t});\n\t\t\t}\n\t\t\tvar query = buildQueryString(queryData);\n\t\t\tif (query) path += \"?\" + query;\n\t\t\tvar hash = buildQueryString(hashData);\n\t\t\tif (hash) path += \"#\" + hash;\n\t\t\tif (supportsPushState) {\n\t\t\t\tvar state = options ? options.state : null;\n\t\t\t\tvar title = options ? options.title : null;\n\t\t\t\t$window.onpopstate();\n\t\t\t\tif (options && options.replace) $window.history.replaceState(state, title, router.prefix + path);else $window.history.pushState(state, title, router.prefix + path);\n\t\t\t} else $window.location.href = router.prefix + path;\n\t\t};\n\t\trouter.defineRoutes = function (routes, resolve, reject) {\n\t\t\tfunction resolveRoute() {\n\t\t\t\tvar path = router.getPath();\n\t\t\t\tvar params = {};\n\t\t\t\tvar pathname = parsePath(path, params, params);\n\t\t\t\tvar state = $window.history.state;\n\t\t\t\tif (state != null) {\n\t\t\t\t\tfor (var k in state) {\n\t\t\t\t\t\tparams[k] = state[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (var route0 in routes) {\n\t\t\t\t\tvar matcher = new RegExp(\"^\" + route0.replace(/:[^\\/]+?\\.{3}/g, \"(.*?)\").replace(/:[^\\/]+/g, \"([^\\\\/]+)\") + \"\\/?$\");\n\t\t\t\t\tif (matcher.test(pathname)) {\n\t\t\t\t\t\tpathname.replace(matcher, function () {\n\t\t\t\t\t\t\tvar keys = route0.match(/:[^\\/]+/g) || [];\n\t\t\t\t\t\t\tvar values = [].slice.call(arguments, 1, -2);\n\t\t\t\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\t\t\t\tparams[keys[i].replace(/:|\\./g, \"\")] = decodeURIComponent(values[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresolve(routes[route0], params, path, route0);\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treject(path, params);\n\t\t\t}\n\t\t\tif (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute);else if (router.prefix.charAt(0) === \"#\") $window.onhashchange = resolveRoute;\n\t\t\tresolveRoute();\n\t\t};\n\t\treturn router;\n\t};\n\tvar _20 = function _20($window, redrawService0) {\n\t\tvar routeService = coreRouter($window);\n\t\tvar identity = function identity(v) {\n\t\t\treturn v;\n\t\t};\n\t\tvar render1, component, attrs3, currentPath, _lastUpdate;\n\t\tvar route = function route(root, defaultRoute, routes) {\n\t\t\tif (root == null) throw new Error(\"Ensure the DOM element that was passed to `m.route` is not undefined\");\n\t\t\tvar run1 = function run1() {\n\t\t\t\tif (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)));\n\t\t\t};\n\t\t\tvar bail = function bail(path) {\n\t\t\t\tif (path !== defaultRoute) routeService.setPath(defaultRoute, null, { replace: true });else throw new Error(\"Could not resolve default route \" + defaultRoute);\n\t\t\t};\n\t\t\trouteService.defineRoutes(routes, function (payload, params, path) {\n\t\t\t\tvar update = _lastUpdate = function lastUpdate(routeResolver, comp) {\n\t\t\t\t\tif (update !== _lastUpdate) return;\n\t\t\t\t\tcomponent = comp != null && (typeof comp.view === \"function\" || typeof comp === \"function\") ? comp : \"div\";\n\t\t\t\t\tattrs3 = params, currentPath = path, _lastUpdate = null;\n\t\t\t\t\trender1 = (routeResolver.render || identity).bind(routeResolver);\n\t\t\t\t\trun1();\n\t\t\t\t};\n\t\t\t\tif (payload.view || typeof payload === \"function\") update({}, payload);else {\n\t\t\t\t\tif (payload.onmatch) {\n\t\t\t\t\t\tPromise.resolve(payload.onmatch(params, path)).then(function (resolved) {\n\t\t\t\t\t\t\tupdate(payload, resolved);\n\t\t\t\t\t\t}, bail);\n\t\t\t\t\t} else update(payload, \"div\");\n\t\t\t\t}\n\t\t\t}, bail);\n\t\t\tredrawService0.subscribe(root, run1);\n\t\t};\n\t\troute.set = function (path, data, options) {\n\t\t\tif (_lastUpdate != null) {\n\t\t\t\toptions = options || {};\n\t\t\t\toptions.replace = true;\n\t\t\t}\n\t\t\t_lastUpdate = null;\n\t\t\trouteService.setPath(path, data, options);\n\t\t};\n\t\troute.get = function () {\n\t\t\treturn currentPath;\n\t\t};\n\t\troute.prefix = function (prefix0) {\n\t\t\trouteService.prefix = prefix0;\n\t\t};\n\t\troute.link = function (vnode1) {\n\t\t\tvnode1.dom.setAttribute(\"href\", routeService.prefix + vnode1.attrs.href);\n\t\t\tvnode1.dom.onclick = function (e) {\n\t\t\t\tif (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return;\n\t\t\t\te.preventDefault();\n\t\t\t\te.redraw = false;\n\t\t\t\tvar href = this.getAttribute(\"href\");\n\t\t\t\tif (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length);\n\t\t\t\troute.set(href, undefined, undefined);\n\t\t\t};\n\t\t};\n\t\troute.param = function (key3) {\n\t\t\tif (typeof attrs3 !== \"undefined\" && typeof key3 !== \"undefined\") return attrs3[key3];\n\t\t\treturn attrs3;\n\t\t};\n\t\treturn route;\n\t};\n\tm.route = _20(window, redrawService);\n\tm.withAttr = function (attrName, callback1, context) {\n\t\treturn function (e) {\n\t\t\tcallback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName));\n\t\t};\n\t};\n\tvar _28 = coreRenderer(window);\n\tm.render = _28.render;\n\tm.redraw = redrawService.redraw;\n\tm.request = requestService.request;\n\tm.jsonp = requestService.jsonp;\n\tm.parseQueryString = parseQueryString;\n\tm.buildQueryString = buildQueryString;\n\tm.version = \"1.1.6\";\n\tm.vnode = Vnode;\n\tif (true) module[\"exports\"] = m;else window.m = m;\n})();\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../timers-browserify/main.js */ 9).setImmediate, __webpack_require__(/*! ./../webpack/buildin/global.js */ 3)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvbWl0aHJpbC9taXRocmlsLmpzPzQ2NTkiXSwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiXG5mdW5jdGlvbiBWbm9kZSh0YWcsIGtleSwgYXR0cnMwLCBjaGlsZHJlbiwgdGV4dCwgZG9tKSB7XG5cdHJldHVybiB7dGFnOiB0YWcsIGtleToga2V5LCBhdHRyczogYXR0cnMwLCBjaGlsZHJlbjogY2hpbGRyZW4sIHRleHQ6IHRleHQsIGRvbTogZG9tLCBkb21TaXplOiB1bmRlZmluZWQsIHN0YXRlOiB1bmRlZmluZWQsIF9zdGF0ZTogdW5kZWZpbmVkLCBldmVudHM6IHVuZGVmaW5lZCwgaW5zdGFuY2U6IHVuZGVmaW5lZCwgc2tpcDogZmFsc2V9XG59XG5Wbm9kZS5ub3JtYWxpemUgPSBmdW5jdGlvbihub2RlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gVm5vZGUoXCJbXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihub2RlKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdGlmIChub2RlICE9IG51bGwgJiYgdHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpIHJldHVybiBWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG5vZGUgPT09IGZhbHNlID8gXCJcIiA6IG5vZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRyZXR1cm4gbm9kZVxufVxuVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4gPSBmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRyZW5baV0gPSBWbm9kZS5ub3JtYWxpemUoY2hpbGRyZW5baV0pXG5cdH1cblx0cmV0dXJuIGNoaWxkcmVuXG59XG52YXIgc2VsZWN0b3JQYXJzZXIgPSAvKD86KF58I3xcXC4pKFteI1xcLlxcW1xcXV0rKSl8KFxcWyguKz8pKD86XFxzKj1cXHMqKFwifCd8KSgoPzpcXFxcW1wiJ1xcXV18LikqPylcXDUpP1xcXSkvZ1xudmFyIHNlbGVjdG9yQ2FjaGUgPSB7fVxudmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5XG5mdW5jdGlvbiBpc0VtcHR5KG9iamVjdCkge1xuXHRmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBpZiAoaGFzT3duLmNhbGwob2JqZWN0LCBrZXkpKSByZXR1cm4gZmFsc2Vcblx0cmV0dXJuIHRydWVcbn1cbmZ1bmN0aW9uIGNvbXBpbGVTZWxlY3RvcihzZWxlY3Rvcikge1xuXHR2YXIgbWF0Y2gsIHRhZyA9IFwiZGl2XCIsIGNsYXNzZXMgPSBbXSwgYXR0cnMgPSB7fVxuXHR3aGlsZSAobWF0Y2ggPSBzZWxlY3RvclBhcnNlci5leGVjKHNlbGVjdG9yKSkge1xuXHRcdHZhciB0eXBlID0gbWF0Y2hbMV0sIHZhbHVlID0gbWF0Y2hbMl1cblx0XHRpZiAodHlwZSA9PT0gXCJcIiAmJiB2YWx1ZSAhPT0gXCJcIikgdGFnID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIiNcIikgYXR0cnMuaWQgPSB2YWx1ZVxuXHRcdGVsc2UgaWYgKHR5cGUgPT09IFwiLlwiKSBjbGFzc2VzLnB1c2godmFsdWUpXG5cdFx0ZWxzZSBpZiAobWF0Y2hbM11bMF0gPT09IFwiW1wiKSB7XG5cdFx0XHR2YXIgYXR0clZhbHVlID0gbWF0Y2hbNl1cblx0XHRcdGlmIChhdHRyVmFsdWUpIGF0dHJWYWx1ZSA9IGF0dHJWYWx1ZS5yZXBsYWNlKC9cXFxcKFtcIiddKS9nLCBcIiQxXCIpLnJlcGxhY2UoL1xcXFxcXFxcL2csIFwiXFxcXFwiKVxuXHRcdFx0aWYgKG1hdGNoWzRdID09PSBcImNsYXNzXCIpIGNsYXNzZXMucHVzaChhdHRyVmFsdWUpXG5cdFx0XHRlbHNlIGF0dHJzW21hdGNoWzRdXSA9IGF0dHJWYWx1ZSA9PT0gXCJcIiA/IGF0dHJWYWx1ZSA6IGF0dHJWYWx1ZSB8fCB0cnVlXG5cdFx0fVxuXHR9XG5cdGlmIChjbGFzc2VzLmxlbmd0aCA+IDApIGF0dHJzLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbihcIiBcIilcblx0cmV0dXJuIHNlbGVjdG9yQ2FjaGVbc2VsZWN0b3JdID0ge3RhZzogdGFnLCBhdHRyczogYXR0cnN9XG59XG5mdW5jdGlvbiBleGVjU2VsZWN0b3Ioc3RhdGUsIGF0dHJzLCBjaGlsZHJlbikge1xuXHR2YXIgaGFzQXR0cnMgPSBmYWxzZSwgY2hpbGRMaXN0LCB0ZXh0XG5cdHZhciBjbGFzc05hbWUgPSBhdHRycy5jbGFzc05hbWUgfHwgYXR0cnMuY2xhc3Ncblx0aWYgKCFpc0VtcHR5KHN0YXRlLmF0dHJzKSAmJiAhaXNFbXB0eShhdHRycykpIHtcblx0XHR2YXIgbmV3QXR0cnMgPSB7fVxuXHRcdGZvcih2YXIga2V5IGluIGF0dHJzKSB7XG5cdFx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkpIHtcblx0XHRcdFx0bmV3QXR0cnNba2V5XSA9IGF0dHJzW2tleV1cblx0XHRcdH1cblx0XHR9XG5cdFx0YXR0cnMgPSBuZXdBdHRyc1xuXHR9XG5cdGZvciAodmFyIGtleSBpbiBzdGF0ZS5hdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChzdGF0ZS5hdHRycywga2V5KSkge1xuXHRcdFx0YXR0cnNba2V5XSA9IHN0YXRlLmF0dHJzW2tleV1cblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGF0dHJzLmNsYXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGF0dHJzLmNsYXNzID0gdW5kZWZpbmVkXG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBjbGFzc05hbWVcblx0XHR9XG5cdFx0aWYgKHN0YXRlLmF0dHJzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBzdGF0ZS5hdHRycy5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZVxuXHRcdH1cblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImtleVwiKSB7XG5cdFx0XHRoYXNBdHRycyA9IHRydWVcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0gIT0gbnVsbCAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiI1wiKSB7XG5cdFx0dGV4dCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRMaXN0ID0gY2hpbGRyZW5cblx0fVxuXHRyZXR1cm4gVm5vZGUoc3RhdGUudGFnLCBhdHRycy5rZXksIGhhc0F0dHJzID8gYXR0cnMgOiB1bmRlZmluZWQsIGNoaWxkTGlzdCwgdGV4dClcbn1cbmZ1bmN0aW9uIGh5cGVyc2NyaXB0KHNlbGVjdG9yKSB7XG5cdC8vIEJlY2F1c2Ugc2xvcHB5IG1vZGUgc3Vja3Ncblx0dmFyIGF0dHJzID0gYXJndW1lbnRzWzFdLCBzdGFydCA9IDIsIGNoaWxkcmVuXG5cdGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2VsZWN0b3IudmlldyAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJUaGUgc2VsZWN0b3IgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBjb21wb25lbnQuXCIpO1xuXHR9XG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHR2YXIgY2FjaGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gfHwgY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKVxuXHR9XG5cdGlmIChhdHRycyA9PSBudWxsKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIiB8fCBhdHRycy50YWcgIT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuXHRcdGF0dHJzID0ge31cblx0XHRzdGFydCA9IDFcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gc3RhcnQgKyAxKSB7XG5cdFx0Y2hpbGRyZW4gPSBhcmd1bWVudHNbc3RhcnRdXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgY2hpbGRyZW4gPSBbY2hpbGRyZW5dXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRyZW4gPSBbXVxuXHRcdHdoaWxlIChzdGFydCA8IGFyZ3VtZW50cy5sZW5ndGgpIGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW3N0YXJ0KytdKVxuXHR9XG5cdHZhciBub3JtYWxpemVkID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gZXhlY1NlbGVjdG9yKGNhY2hlZCwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFZub2RlKHNlbGVjdG9yLCBhdHRycy5rZXksIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9XG59XG5oeXBlcnNjcmlwdC50cnVzdCA9IGZ1bmN0aW9uKGh0bWwpIHtcblx0aWYgKGh0bWwgPT0gbnVsbCkgaHRtbCA9IFwiXCJcblx0cmV0dXJuIFZub2RlKFwiPFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaHRtbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG5oeXBlcnNjcmlwdC5mcmFnbWVudCA9IGZ1bmN0aW9uKGF0dHJzMSwgY2hpbGRyZW4pIHtcblx0cmV0dXJuIFZub2RlKFwiW1wiLCBhdHRyczEua2V5LCBhdHRyczEsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG52YXIgbSA9IGh5cGVyc2NyaXB0XG4vKiogQGNvbnN0cnVjdG9yICovXG52YXIgUHJvbWlzZVBvbHlmaWxsID0gZnVuY3Rpb24oZXhlY3V0b3IpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UgbXVzdCBiZSBjYWxsZWQgd2l0aCBgbmV3YFwiKVxuXHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIilcblx0dmFyIHNlbGYgPSB0aGlzLCByZXNvbHZlcnMgPSBbXSwgcmVqZWN0b3JzID0gW10sIHJlc29sdmVDdXJyZW50ID0gaGFuZGxlcihyZXNvbHZlcnMsIHRydWUpLCByZWplY3RDdXJyZW50ID0gaGFuZGxlcihyZWplY3RvcnMsIGZhbHNlKVxuXHR2YXIgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZSA9IHtyZXNvbHZlcnM6IHJlc29sdmVycywgcmVqZWN0b3JzOiByZWplY3RvcnN9XG5cdHZhciBjYWxsQXN5bmMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIGhhbmRsZXIobGlzdCwgc2hvdWxkQWJzb3JiKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGUodmFsdWUpIHtcblx0XHRcdHZhciB0aGVuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoc2hvdWxkQWJzb3JiICYmIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mICh0aGVuID0gdmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgdy8gaXRzZWxmXCIpXG5cdFx0XHRcdFx0ZXhlY3V0ZU9uY2UodGhlbi5iaW5kKHZhbHVlKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjYWxsQXN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXNob3VsZEFic29yYiAmJiBsaXN0Lmxlbmd0aCA9PT0gMCkgY29uc29sZS5lcnJvcihcIlBvc3NpYmxlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjpcIiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIGxpc3RbaV0odmFsdWUpXG5cdFx0XHRcdFx0XHRyZXNvbHZlcnMubGVuZ3RoID0gMCwgcmVqZWN0b3JzLmxlbmd0aCA9IDBcblx0XHRcdFx0XHRcdGluc3RhbmNlLnN0YXRlID0gc2hvdWxkQWJzb3JiXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5yZXRyeSA9IGZ1bmN0aW9uKCkge2V4ZWN1dGUodmFsdWUpfVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlamVjdEN1cnJlbnQoZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZXhlY3V0ZU9uY2UodGhlbikge1xuXHRcdHZhciBydW5zID0gMFxuXHRcdGZ1bmN0aW9uIHJ1bihmbikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChydW5zKysgPiAwKSByZXR1cm5cblx0XHRcdFx0Zm4odmFsdWUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBvbmVycm9yID0gcnVuKHJlamVjdEN1cnJlbnQpXG5cdFx0dHJ5IHt0aGVuKHJ1bihyZXNvbHZlQ3VycmVudCksIG9uZXJyb3IpfSBjYXRjaCAoZSkge29uZXJyb3IoZSl9XG5cdH1cblx0ZXhlY3V0ZU9uY2UoZXhlY3V0b3IpXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3Rpb24pIHtcblx0dmFyIHNlbGYgPSB0aGlzLCBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlXG5cdGZ1bmN0aW9uIGhhbmRsZShjYWxsYmFjaywgbGlzdCwgbmV4dCwgc3RhdGUpIHtcblx0XHRsaXN0LnB1c2goZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgbmV4dCh2YWx1ZSlcblx0XHRcdGVsc2UgdHJ5IHtyZXNvbHZlTmV4dChjYWxsYmFjayh2YWx1ZSkpfSBjYXRjaCAoZSkge2lmIChyZWplY3ROZXh0KSByZWplY3ROZXh0KGUpfVxuXHRcdH0pXG5cdFx0aWYgKHR5cGVvZiBpbnN0YW5jZS5yZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHN0YXRlID09PSBpbnN0YW5jZS5zdGF0ZSkgaW5zdGFuY2UucmV0cnkoKVxuXHR9XG5cdHZhciByZXNvbHZlTmV4dCwgcmVqZWN0TmV4dFxuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVzb2x2ZU5leHQgPSByZXNvbHZlLCByZWplY3ROZXh0ID0gcmVqZWN0fSlcblx0aGFuZGxlKG9uRnVsZmlsbGVkLCBpbnN0YW5jZS5yZXNvbHZlcnMsIHJlc29sdmVOZXh0LCB0cnVlKSwgaGFuZGxlKG9uUmVqZWN0aW9uLCBpbnN0YW5jZS5yZWplY3RvcnMsIHJlamVjdE5leHQsIGZhbHNlKVxuXHRyZXR1cm4gcHJvbWlzZVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG5cdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pXG59XG5Qcm9taXNlUG9seWZpbGwucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkgcmV0dXJuIHZhbHVlXG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUpIHtyZXNvbHZlKHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVqZWN0KHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwuYWxsID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHR2YXIgdG90YWwgPSBsaXN0Lmxlbmd0aCwgY291bnQgPSAwLCB2YWx1ZXMgPSBbXVxuXHRcdGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSlcblx0XHRlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0KGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0ZnVuY3Rpb24gY29uc3VtZSh2YWx1ZSkge1xuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gdG90YWwpIHJlc29sdmUodmFsdWVzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaXN0W2ldICE9IG51bGwgJiYgKHR5cGVvZiBsaXN0W2ldID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBsaXN0W2ldID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiBsaXN0W2ldLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGxpc3RbaV0udGhlbihjb25zdW1lLCByZWplY3QpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBjb25zdW1lKGxpc3RbaV0pXG5cdFx0XHR9KShpKVxuXHRcdH1cblx0fSlcbn1cblByb21pc2VQb2x5ZmlsbC5yYWNlID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxpc3RbaV0udGhlbihyZXNvbHZlLCByZWplY3QpXG5cdFx0fVxuXHR9KVxufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgd2luZG93LlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IHdpbmRvdy5Qcm9taXNlXG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWwuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IGdsb2JhbC5Qcm9taXNlXG59IGVsc2Uge1xufVxudmFyIGJ1aWxkUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSByZXR1cm4gXCJcIlxuXHR2YXIgYXJncyA9IFtdXG5cdGZvciAodmFyIGtleTAgaW4gb2JqZWN0KSB7XG5cdFx0ZGVzdHJ1Y3R1cmUoa2V5MCwgb2JqZWN0W2tleTBdKVxuXHR9XG5cdHJldHVybiBhcmdzLmpvaW4oXCImXCIpXG5cdGZ1bmN0aW9uIGRlc3RydWN0dXJlKGtleTAsIHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleTAgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBhcmdzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleTApICsgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IFwiXCIgPyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiBcIlwiKSlcblx0fVxufVxudmFyIEZJTEVfUFJPVE9DT0xfUkVHRVggPSBuZXcgUmVnRXhwKFwiXmZpbGU6Ly9cIiwgXCJpXCIpXG52YXIgXzggPSBmdW5jdGlvbigkd2luZG93LCBQcm9taXNlKSB7XG5cdHZhciBjYWxsYmFja0NvdW50ID0gMFxuXHR2YXIgb25jb21wbGV0aW9uXG5cdGZ1bmN0aW9uIHNldENvbXBsZXRpb25DYWxsYmFjayhjYWxsYmFjaykge29uY29tcGxldGlvbiA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG5cdFx0dmFyIGNvdW50ID0gMFxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge2lmICgtLWNvdW50ID09PSAwICYmIHR5cGVvZiBvbmNvbXBsZXRpb24gPT09IFwiZnVuY3Rpb25cIikgb25jb21wbGV0aW9uKCl9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGZpbmFsaXplKHByb21pc2UwKSB7XG5cdFx0XHR2YXIgdGhlbjAgPSBwcm9taXNlMC50aGVuXG5cdFx0XHRwcm9taXNlMC50aGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0dmFyIG5leHQgPSB0aGVuMC5hcHBseShwcm9taXNlMCwgYXJndW1lbnRzKVxuXHRcdFx0XHRuZXh0LnRoZW4oY29tcGxldGUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRjb21wbGV0ZSgpXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB0aHJvdyBlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVybiBmaW5hbGl6ZShuZXh0KVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2UwXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZShhcmdzLCBleHRyYSkge1xuXHRcdGlmICh0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIHVybCA9IGFyZ3Ncblx0XHRcdGFyZ3MgPSBleHRyYSB8fCB7fVxuXHRcdFx0aWYgKGFyZ3MudXJsID09IG51bGwpIGFyZ3MudXJsID0gdXJsXG5cdFx0fVxuXHRcdHJldHVybiBhcmdzXG5cdH1cblx0ZnVuY3Rpb24gcmVxdWVzdChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGlmIChhcmdzLm1ldGhvZCA9PSBudWxsKSBhcmdzLm1ldGhvZCA9IFwiR0VUXCJcblx0XHRcdGFyZ3MubWV0aG9kID0gYXJncy5tZXRob2QudG9VcHBlckNhc2UoKVxuXHRcdFx0dmFyIHVzZUJvZHkgPSAoYXJncy5tZXRob2QgPT09IFwiR0VUXCIgfHwgYXJncy5tZXRob2QgPT09IFwiVFJBQ0VcIikgPyBmYWxzZSA6ICh0eXBlb2YgYXJncy51c2VCb2R5ID09PSBcImJvb2xlYW5cIiA/IGFyZ3MudXNlQm9keSA6IHRydWUpXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3Muc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3Muc2VyaWFsaXplID0gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGFyZ3MuZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhID8gZnVuY3Rpb24odmFsdWUpIHtyZXR1cm4gdmFsdWV9IDogSlNPTi5zdHJpbmdpZnlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5kZXNlcmlhbGl6ZSAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemVcblx0XHRcdGlmICh0eXBlb2YgYXJncy5leHRyYWN0ICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZXh0cmFjdCA9IGV4dHJhY3Rcblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGlmICh1c2VCb2R5KSBhcmdzLmRhdGEgPSBhcmdzLnNlcmlhbGl6ZShhcmdzLmRhdGEpXG5cdFx0XHRlbHNlIGFyZ3MudXJsID0gYXNzZW1ibGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdHZhciB4aHIgPSBuZXcgJHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpLFxuXHRcdFx0XHRhYm9ydGVkID0gZmFsc2UsXG5cdFx0XHRcdF9hYm9ydCA9IHhoci5hYm9ydFxuXHRcdFx0eGhyLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG5cdFx0XHRcdGFib3J0ZWQgPSB0cnVlXG5cdFx0XHRcdF9hYm9ydC5jYWxsKHhocilcblx0XHRcdH1cblx0XHRcdHhoci5vcGVuKGFyZ3MubWV0aG9kLCBhcmdzLnVybCwgdHlwZW9mIGFyZ3MuYXN5bmMgPT09IFwiYm9vbGVhblwiID8gYXJncy5hc3luYyA6IHRydWUsIHR5cGVvZiBhcmdzLnVzZXIgPT09IFwic3RyaW5nXCIgPyBhcmdzLnVzZXIgOiB1bmRlZmluZWQsIHR5cGVvZiBhcmdzLnBhc3N3b3JkID09PSBcInN0cmluZ1wiID8gYXJncy5wYXNzd29yZCA6IHVuZGVmaW5lZClcblx0XHRcdGlmIChhcmdzLnNlcmlhbGl6ZSA9PT0gSlNPTi5zdHJpbmdpZnkgJiYgdXNlQm9keSAmJiAhKGFyZ3MuaGVhZGVycyAmJiBhcmdzLmhlYWRlcnMuaGFzT3duUHJvcGVydHkoXCJDb250ZW50LVR5cGVcIikpKSB7XG5cdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3MuZGVzZXJpYWxpemUgPT09IGRlc2VyaWFsaXplICYmICEoYXJncy5oZWFkZXJzICYmIGFyZ3MuaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShcIkFjY2VwdFwiKSkpIHtcblx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0LypcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLndpdGhDcmVkZW50aWFscykgeGhyLndpdGhDcmVkZW50aWFscyA9IGFyZ3Mud2l0aENyZWRlbnRpYWxzXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJncy5oZWFkZXJzKSBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcmdzLmhlYWRlcnMsIGtleSkpIHtcblx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBhcmdzLmhlYWRlcnNba2V5XSlcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2YgYXJncy5jb25maWcgPT09IFwiZnVuY3Rpb25cIikgeGhyID0gYXJncy5jb25maWcoeGhyLCBhcmdzKSB8fCB4aHJcblx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gRG9uJ3QgdGhyb3cgZXJyb3JzIG9uIHhoci5hYm9ydCgpLlxuXHRcdFx0XHRpZihhYm9ydGVkKSByZXR1cm5cblx0XHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHZhciByZXNwb25zZSA9IChhcmdzLmV4dHJhY3QgIT09IGV4dHJhY3QpID8gYXJncy5leHRyYWN0KHhociwgYXJncykgOiBhcmdzLmRlc2VyaWFsaXplKGFyZ3MuZXh0cmFjdCh4aHIsIGFyZ3MpKVxuXHRcdFx0XHRcdFx0aWYgKCh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB8fCB4aHIuc3RhdHVzID09PSAzMDQgfHwgRklMRV9QUk9UT0NPTF9SRUdFWC50ZXN0KGFyZ3MudXJsKSkge1xuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKGNhc3QoYXJncy50eXBlLCByZXNwb25zZSkpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKHhoci5yZXNwb25zZVRleHQpXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiByZXNwb25zZSkgZXJyb3Jba2V5XSA9IHJlc3BvbnNlW2tleV1cblx0XHRcdFx0XHRcdFx0cmVqZWN0KGVycm9yKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0cmVqZWN0KGUpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodXNlQm9keSAmJiAoYXJncy5kYXRhICE9IG51bGwpKSB4aHIuc2VuZChhcmdzLmRhdGEpXG5cdFx0XHRlbHNlIHhoci5zZW5kKClcblx0XHR9KVxuXHRcdHJldHVybiBhcmdzLmJhY2tncm91bmQgPT09IHRydWUgPyBwcm9taXNlMCA6IGZpbmFsaXplKHByb21pc2UwKVxuXHR9XG5cdGZ1bmN0aW9uIGpzb25wKGFyZ3MsIGV4dHJhKSB7XG5cdFx0dmFyIGZpbmFsaXplID0gZmluYWxpemVyKClcblx0XHRhcmdzID0gbm9ybWFsaXplKGFyZ3MsIGV4dHJhKVxuXHRcdHZhciBwcm9taXNlMCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0dmFyIGNhbGxiYWNrTmFtZSA9IGFyZ3MuY2FsbGJhY2tOYW1lIHx8IFwiX21pdGhyaWxfXCIgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxZTE2KSArIFwiX1wiICsgY2FsbGJhY2tDb3VudCsrXG5cdFx0XHR2YXIgc2NyaXB0ID0gJHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpXG5cdFx0XHQkd2luZG93W2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdClcblx0XHRcdFx0cmVzb2x2ZShjYXN0KGFyZ3MudHlwZSwgZGF0YSkpXG5cdFx0XHRcdGRlbGV0ZSAkd2luZG93W2NhbGxiYWNrTmFtZV1cblx0XHRcdH1cblx0XHRcdHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdClcblx0XHRcdFx0cmVqZWN0KG5ldyBFcnJvcihcIkpTT05QIHJlcXVlc3QgZmFpbGVkXCIpKVxuXHRcdFx0XHRkZWxldGUgJHdpbmRvd1tjYWxsYmFja05hbWVdXG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJncy5kYXRhID09IG51bGwpIGFyZ3MuZGF0YSA9IHt9XG5cdFx0XHRhcmdzLnVybCA9IGludGVycG9sYXRlKGFyZ3MudXJsLCBhcmdzLmRhdGEpXG5cdFx0XHRhcmdzLmRhdGFbYXJncy5jYWxsYmFja0tleSB8fCBcImNhbGxiYWNrXCJdID0gY2FsbGJhY2tOYW1lXG5cdFx0XHRzY3JpcHQuc3JjID0gYXNzZW1ibGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdCR3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdClcblx0XHR9KVxuXHRcdHJldHVybiBhcmdzLmJhY2tncm91bmQgPT09IHRydWU/IHByb21pc2UwIDogZmluYWxpemUocHJvbWlzZTApXG5cdH1cblx0ZnVuY3Rpb24gaW50ZXJwb2xhdGUodXJsLCBkYXRhKSB7XG5cdFx0aWYgKGRhdGEgPT0gbnVsbCkgcmV0dXJuIHVybFxuXHRcdHZhciB0b2tlbnMgPSB1cmwubWF0Y2goLzpbXlxcL10rL2dpKSB8fCBbXVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIga2V5ID0gdG9rZW5zW2ldLnNsaWNlKDEpXG5cdFx0XHRpZiAoZGF0YVtrZXldICE9IG51bGwpIHtcblx0XHRcdFx0dXJsID0gdXJsLnJlcGxhY2UodG9rZW5zW2ldLCBkYXRhW2tleV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB1cmxcblx0fVxuXHRmdW5jdGlvbiBhc3NlbWJsZSh1cmwsIGRhdGEpIHtcblx0XHR2YXIgcXVlcnlzdHJpbmcgPSBidWlsZFF1ZXJ5U3RyaW5nKGRhdGEpXG5cdFx0aWYgKHF1ZXJ5c3RyaW5nICE9PSBcIlwiKSB7XG5cdFx0XHR2YXIgcHJlZml4ID0gdXJsLmluZGV4T2YoXCI/XCIpIDwgMCA/IFwiP1wiIDogXCImXCJcblx0XHRcdHVybCArPSBwcmVmaXggKyBxdWVyeXN0cmluZ1xuXHRcdH1cblx0XHRyZXR1cm4gdXJsXG5cdH1cblx0ZnVuY3Rpb24gZGVzZXJpYWxpemUoZGF0YSkge1xuXHRcdHRyeSB7cmV0dXJuIGRhdGEgIT09IFwiXCIgPyBKU09OLnBhcnNlKGRhdGEpIDogbnVsbH1cblx0XHRjYXRjaCAoZSkge3Rocm93IG5ldyBFcnJvcihkYXRhKX1cblx0fVxuXHRmdW5jdGlvbiBleHRyYWN0KHhocikge3JldHVybiB4aHIucmVzcG9uc2VUZXh0fVxuXHRmdW5jdGlvbiBjYXN0KHR5cGUwLCBkYXRhKSB7XG5cdFx0aWYgKHR5cGVvZiB0eXBlMCA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRkYXRhW2ldID0gbmV3IHR5cGUwKGRhdGFbaV0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgcmV0dXJuIG5ldyB0eXBlMChkYXRhKVxuXHRcdH1cblx0XHRyZXR1cm4gZGF0YVxuXHR9XG5cdHJldHVybiB7cmVxdWVzdDogcmVxdWVzdCwganNvbnA6IGpzb25wLCBzZXRDb21wbGV0aW9uQ2FsbGJhY2s6IHNldENvbXBsZXRpb25DYWxsYmFja31cbn1cbnZhciByZXF1ZXN0U2VydmljZSA9IF84KHdpbmRvdywgUHJvbWlzZVBvbHlmaWxsKVxudmFyIGNvcmVSZW5kZXJlciA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyICRkb2MgPSAkd2luZG93LmRvY3VtZW50XG5cdHZhciAkZW1wdHlGcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdHZhciBuYW1lU3BhY2UgPSB7XG5cdFx0c3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG5cdFx0bWF0aDogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCJcblx0fVxuXHR2YXIgb25ldmVudFxuXHRmdW5jdGlvbiBzZXRFdmVudENhbGxiYWNrKGNhbGxiYWNrKSB7cmV0dXJuIG9uZXZlbnQgPSBjYWxsYmFja31cblx0ZnVuY3Rpb24gZ2V0TmFtZVNwYWNlKHZub2RlKSB7XG5cdFx0cmV0dXJuIHZub2RlLmF0dHJzICYmIHZub2RlLmF0dHJzLnhtbG5zIHx8IG5hbWVTcGFjZVt2bm9kZS50YWddXG5cdH1cblx0Ly9jcmVhdGVcblx0ZnVuY3Rpb24gY3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciB0YWcgPSB2bm9kZS50YWdcblx0XHRpZiAodHlwZW9mIHRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSB7fVxuXHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdHN3aXRjaCAodGFnKSB7XG5cdFx0XHRcdGNhc2UgXCIjXCI6IHJldHVybiBjcmVhdGVUZXh0KHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRjYXNlIFwiPFwiOiByZXR1cm4gY3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHRcdFx0Y2FzZSBcIltcIjogcmV0dXJuIGNyZWF0ZUZyYWdtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGRlZmF1bHQ6IHJldHVybiBjcmVhdGVFbGVtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZVRleHQocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHR2bm9kZS5kb20gPSAkZG9jLmNyZWF0ZVRleHROb2RlKHZub2RlLmNoaWxkcmVuKVxuXHRcdGluc2VydE5vZGUocGFyZW50LCB2bm9kZS5kb20sIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiB2bm9kZS5kb21cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIG1hdGNoMSA9IHZub2RlLmNoaWxkcmVuLm1hdGNoKC9eXFxzKj88KFxcdyspL2ltKSB8fCBbXVxuXHRcdHZhciBwYXJlbnQxID0ge2NhcHRpb246IFwidGFibGVcIiwgdGhlYWQ6IFwidGFibGVcIiwgdGJvZHk6IFwidGFibGVcIiwgdGZvb3Q6IFwidGFibGVcIiwgdHI6IFwidGJvZHlcIiwgdGg6IFwidHJcIiwgdGQ6IFwidHJcIiwgY29sZ3JvdXA6IFwidGFibGVcIiwgY29sOiBcImNvbGdyb3VwXCJ9W21hdGNoMVsxXV0gfHwgXCJkaXZcIlxuXHRcdHZhciB0ZW1wID0gJGRvYy5jcmVhdGVFbGVtZW50KHBhcmVudDEpXG5cdFx0dGVtcC5pbm5lckhUTUwgPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IHRlbXAuZmlyc3RDaGlsZFxuXHRcdHZub2RlLmRvbVNpemUgPSB0ZW1wLmNoaWxkTm9kZXMubGVuZ3RoXG5cdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHR2YXIgY2hpbGRcblx0XHR3aGlsZSAoY2hpbGQgPSB0ZW1wLmZpcnN0Q2hpbGQpIHtcblx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKGNoaWxkKVxuXHRcdH1cblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZnJhZ21lbnQsIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiBmcmFnbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdGlmICh2bm9kZS5jaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0Y3JlYXRlTm9kZXMoZnJhZ21lbnQsIGNoaWxkcmVuLCAwLCBjaGlsZHJlbi5sZW5ndGgsIGhvb2tzLCBudWxsLCBucylcblx0XHR9XG5cdFx0dm5vZGUuZG9tID0gZnJhZ21lbnQuZmlyc3RDaGlsZFxuXHRcdHZub2RlLmRvbVNpemUgPSBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aFxuXHRcdGluc2VydE5vZGUocGFyZW50LCBmcmFnbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIGZyYWdtZW50XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlRWxlbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIHRhZyA9IHZub2RlLnRhZ1xuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdHZhciBpcyA9IGF0dHJzMiAmJiBhdHRyczIuaXNcblx0XHRucyA9IGdldE5hbWVTcGFjZSh2bm9kZSkgfHwgbnNcblx0XHR2YXIgZWxlbWVudCA9IG5zID9cblx0XHRcdGlzID8gJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZywge2lzOiBpc30pIDogJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZykgOlxuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnKVxuXHRcdHZub2RlLmRvbSA9IGVsZW1lbnRcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdHNldEF0dHJzKHZub2RlLCBhdHRyczIsIG5zKVxuXHRcdH1cblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdm5vZGUuYXR0cnMuY29udGVudGVkaXRhYmxlICE9IG51bGwpIHtcblx0XHRcdHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSlcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS50ZXh0ICE9PSBcIlwiKSBlbGVtZW50LnRleHRDb250ZW50ID0gdm5vZGUudGV4dFxuXHRcdFx0XHRlbHNlIHZub2RlLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdm5vZGUudGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXVxuXHRcdFx0fVxuXHRcdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdFx0Y3JlYXRlTm9kZXMoZWxlbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdFx0XHRzZXRMYXRlQXR0cnModm5vZGUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpIHtcblx0XHR2YXIgc2VudGluZWxcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZy52aWV3ID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0gT2JqZWN0LmNyZWF0ZSh2bm9kZS50YWcpXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnN0YXRlLnZpZXdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHZvaWQgMFxuXHRcdFx0c2VudGluZWwgPSB2bm9kZS50YWdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdFx0dm5vZGUuc3RhdGUgPSAodm5vZGUudGFnLnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS50YWcucHJvdG90eXBlLnZpZXcgPT09IFwiZnVuY3Rpb25cIikgPyBuZXcgdm5vZGUudGFnKHZub2RlKSA6IHZub2RlLnRhZyh2bm9kZSlcblx0XHR9XG5cdFx0dm5vZGUuX3N0YXRlID0gdm5vZGUuc3RhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdGluaXRMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0dm5vZGUuaW5zdGFuY2UgPSBWbm9kZS5ub3JtYWxpemUodm5vZGUuX3N0YXRlLnZpZXcuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSBudWxsXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHRpbml0Q29tcG9uZW50KHZub2RlLCBob29rcylcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5kb20gIT0gbnVsbCA/IHZub2RlLmluc3RhbmNlLmRvbVNpemUgOiAwXG5cdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0XHRyZXR1cm4gZWxlbWVudFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbVNpemUgPSAwXG5cdFx0XHRyZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHR9XG5cdH1cblx0Ly91cGRhdGVcblx0ZnVuY3Rpb24gdXBkYXRlTm9kZXMocGFyZW50LCBvbGQsIHZub2RlcywgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0aWYgKG9sZCA9PT0gdm5vZGVzIHx8IG9sZCA9PSBudWxsICYmIHZub2RlcyA9PSBudWxsKSByZXR1cm5cblx0XHRlbHNlIGlmIChvbGQgPT0gbnVsbCkgY3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIDAsIHZub2Rlcy5sZW5ndGgsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0ZWxzZSBpZiAodm5vZGVzID09IG51bGwpIHJlbW92ZU5vZGVzKG9sZCwgMCwgb2xkLmxlbmd0aCwgdm5vZGVzKVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKG9sZC5sZW5ndGggPT09IHZub2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGlzVW5rZXllZCA9IGZhbHNlXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHZub2Rlc1tpXSAhPSBudWxsICYmIG9sZFtpXSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRpc1Vua2V5ZWQgPSB2bm9kZXNbaV0ua2V5ID09IG51bGwgJiYgb2xkW2ldLmtleSA9PSBudWxsXG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNVbmtleWVkKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChvbGRbaV0gPT09IHZub2Rlc1tpXSkgY29udGludWVcblx0XHRcdFx0XHRcdGVsc2UgaWYgKG9sZFtpXSA9PSBudWxsICYmIHZub2Rlc1tpXSAhPSBudWxsKSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGVzW2ldLCBob29rcywgbnMsIGdldE5leHRTaWJsaW5nKG9sZCwgaSArIDEsIG5leHRTaWJsaW5nKSlcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHZub2Rlc1tpXSA9PSBudWxsKSByZW1vdmVOb2RlcyhvbGQsIGksIGkgKyAxLCB2bm9kZXMpXG5cdFx0XHRcdFx0XHRlbHNlIHVwZGF0ZU5vZGUocGFyZW50LCBvbGRbaV0sIHZub2Rlc1tpXSwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgaSArIDEsIG5leHRTaWJsaW5nKSwgcmVjeWNsaW5nLCBucylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlY3ljbGluZyA9IHJlY3ljbGluZyB8fCBpc1JlY3ljbGFibGUob2xkLCB2bm9kZXMpXG5cdFx0XHRpZiAocmVjeWNsaW5nKSB7XG5cdFx0XHRcdHZhciBwb29sID0gb2xkLnBvb2xcblx0XHRcdFx0b2xkID0gb2xkLmNvbmNhdChvbGQucG9vbClcblx0XHRcdH1cblx0XHRcdHZhciBvbGRTdGFydCA9IDAsIHN0YXJ0ID0gMCwgb2xkRW5kID0gb2xkLmxlbmd0aCAtIDEsIGVuZCA9IHZub2Rlcy5sZW5ndGggLSAxLCBtYXBcblx0XHRcdHdoaWxlIChvbGRFbmQgPj0gb2xkU3RhcnQgJiYgZW5kID49IHN0YXJ0KSB7XG5cdFx0XHRcdHZhciBvID0gb2xkW29sZFN0YXJ0XSwgdiA9IHZub2Rlc1tzdGFydF1cblx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkU3RhcnQrKywgc3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZFN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBzdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRTdGFydCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0b2xkU3RhcnQrKywgc3RhcnQrK1xuXHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRTdGFydCwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRpZiAocmVjeWNsaW5nICYmIG8udGFnID09PSB2LnRhZykgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHZhciBvID0gb2xkW29sZEVuZF1cblx0XHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRFbmQtLSwgc3RhcnQrK1xuXHRcdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkRW5kLS1cblx0XHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIHN0YXJ0Kytcblx0XHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRFbmQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0XHRpZiAocmVjeWNsaW5nIHx8IHN0YXJ0IDwgZW5kKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRTdGFydCwgbmV4dFNpYmxpbmcpKVxuXHRcdFx0XHRcdFx0b2xkRW5kLS0sIHN0YXJ0Kytcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBicmVha1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAob2xkRW5kID49IG9sZFN0YXJ0ICYmIGVuZCA+PSBzdGFydCkge1xuXHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRFbmRdLCB2ID0gdm5vZGVzW2VuZF1cblx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkRW5kLS0sIGVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkRW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBlbmQtLVxuXHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkRW5kID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRpZiAocmVjeWNsaW5nICYmIG8udGFnID09PSB2LnRhZykgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdGlmIChvLmRvbSAhPSBudWxsKSBuZXh0U2libGluZyA9IG8uZG9tXG5cdFx0XHRcdFx0b2xkRW5kLS0sIGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCFtYXApIG1hcCA9IGdldEtleU1hcChvbGQsIG9sZEVuZClcblx0XHRcdFx0XHRpZiAodiAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHR2YXIgb2xkSW5kZXggPSBtYXBbdi5rZXldXG5cdFx0XHRcdFx0XHRpZiAob2xkSW5kZXggIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbW92YWJsZSA9IG9sZFtvbGRJbmRleF1cblx0XHRcdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEluZGV4ID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG1vdmFibGUsIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgcmVjeWNsaW5nLCBucylcblx0XHRcdFx0XHRcdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobW92YWJsZSksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdFx0XHRvbGRbb2xkSW5kZXhdLnNraXAgPSB0cnVlXG5cdFx0XHRcdFx0XHRcdGlmIChtb3ZhYmxlLmRvbSAhPSBudWxsKSBuZXh0U2libGluZyA9IG1vdmFibGUuZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0dmFyIGRvbSA9IGNyZWF0ZU5vZGUocGFyZW50LCB2LCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdFx0XHRuZXh0U2libGluZyA9IGRvbVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbmQtLVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlbmQgPCBzdGFydCkgYnJlYWtcblx0XHRcdH1cblx0XHRcdGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCBzdGFydCwgZW5kICsgMSwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHRcdHJlbW92ZU5vZGVzKG9sZCwgb2xkU3RhcnQsIG9sZEVuZCArIDEsIHZub2Rlcylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlTm9kZShwYXJlbnQsIG9sZCwgdm5vZGUsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucykge1xuXHRcdHZhciBvbGRUYWcgPSBvbGQudGFnLCB0YWcgPSB2bm9kZS50YWdcblx0XHRpZiAob2xkVGFnID09PSB0YWcpIHtcblx0XHRcdHZub2RlLnN0YXRlID0gb2xkLnN0YXRlXG5cdFx0XHR2bm9kZS5fc3RhdGUgPSBvbGQuX3N0YXRlXG5cdFx0XHR2bm9kZS5ldmVudHMgPSBvbGQuZXZlbnRzXG5cdFx0XHRpZiAoIXJlY3ljbGluZyAmJiBzaG91bGROb3RVcGRhdGUodm5vZGUsIG9sZCkpIHJldHVyblxuXHRcdFx0aWYgKHR5cGVvZiBvbGRUYWcgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIHtcblx0XHRcdFx0XHRpZiAocmVjeWNsaW5nKSB7XG5cdFx0XHRcdFx0XHR2bm9kZS5zdGF0ZSA9IHt9XG5cdFx0XHRcdFx0XHRpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgdXBkYXRlTGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRcdH1cblx0XHRcdFx0c3dpdGNoIChvbGRUYWcpIHtcblx0XHRcdFx0XHRjYXNlIFwiI1wiOiB1cGRhdGVUZXh0KG9sZCwgdm5vZGUpOyBicmVha1xuXHRcdFx0XHRcdGNhc2UgXCI8XCI6IHVwZGF0ZUhUTUwocGFyZW50LCBvbGQsIHZub2RlLCBuZXh0U2libGluZyk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIltcIjogdXBkYXRlRnJhZ21lbnQocGFyZW50LCBvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpOyBicmVha1xuXHRcdFx0XHRcdGRlZmF1bHQ6IHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgdXBkYXRlQ29tcG9uZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJlbW92ZU5vZGUob2xkLCBudWxsKVxuXHRcdFx0Y3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVUZXh0KG9sZCwgdm5vZGUpIHtcblx0XHRpZiAob2xkLmNoaWxkcmVuLnRvU3RyaW5nKCkgIT09IHZub2RlLmNoaWxkcmVuLnRvU3RyaW5nKCkpIHtcblx0XHRcdG9sZC5kb20ubm9kZVZhbHVlID0gdm5vZGUuY2hpbGRyZW5cblx0XHR9XG5cdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUhUTUwocGFyZW50LCBvbGQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4gIT09IHZub2RlLmNoaWxkcmVuKSB7XG5cdFx0XHR0b0ZyYWdtZW50KG9sZClcblx0XHRcdGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHRcdGVsc2Ugdm5vZGUuZG9tID0gb2xkLmRvbSwgdm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocGFyZW50LCBvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHR1cGRhdGVOb2RlcyhwYXJlbnQsIG9sZC5jaGlsZHJlbiwgdm5vZGUuY2hpbGRyZW4sIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHR2YXIgZG9tU2l6ZSA9IDAsIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHR2bm9kZS5kb20gPSBudWxsXG5cdFx0aWYgKGNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV1cblx0XHRcdFx0aWYgKGNoaWxkICE9IG51bGwgJiYgY2hpbGQuZG9tICE9IG51bGwpIHtcblx0XHRcdFx0XHRpZiAodm5vZGUuZG9tID09IG51bGwpIHZub2RlLmRvbSA9IGNoaWxkLmRvbVxuXHRcdFx0XHRcdGRvbVNpemUgKz0gY2hpbGQuZG9tU2l6ZSB8fCAxXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChkb21TaXplICE9PSAxKSB2bm9kZS5kb21TaXplID0gZG9tU2l6ZVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVFbGVtZW50KG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5zKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0bnMgPSBnZXROYW1lU3BhY2Uodm5vZGUpIHx8IG5zXG5cdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJ0ZXh0YXJlYVwiKSB7XG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgPT0gbnVsbCkgdm5vZGUuYXR0cnMgPSB7fVxuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHR2bm9kZS5hdHRycy52YWx1ZSA9IHZub2RlLnRleHQgLy9GSVhNRSBoYW5kbGUwIG11bHRpcGxlIGNoaWxkcmVuXG5cdFx0XHRcdHZub2RlLnRleHQgPSB1bmRlZmluZWRcblx0XHRcdH1cblx0XHR9XG5cdFx0dXBkYXRlQXR0cnModm5vZGUsIG9sZC5hdHRycywgdm5vZGUuYXR0cnMsIG5zKVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHZub2RlLmF0dHJzLmNvbnRlbnRlZGl0YWJsZSAhPSBudWxsKSB7XG5cdFx0XHRzZXRDb250ZW50RWRpdGFibGUodm5vZGUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKG9sZC50ZXh0ICE9IG51bGwgJiYgdm5vZGUudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT09IFwiXCIpIHtcblx0XHRcdGlmIChvbGQudGV4dC50b1N0cmluZygpICE9PSB2bm9kZS50ZXh0LnRvU3RyaW5nKCkpIG9sZC5kb20uZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB2bm9kZS50ZXh0XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKG9sZC50ZXh0ICE9IG51bGwpIG9sZC5jaGlsZHJlbiA9IFtWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9sZC50ZXh0LCB1bmRlZmluZWQsIG9sZC5kb20uZmlyc3RDaGlsZCldXG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB2bm9kZS5jaGlsZHJlbiA9IFtWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHZub2RlLnRleHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKV1cblx0XHRcdHVwZGF0ZU5vZGVzKGVsZW1lbnQsIG9sZC5jaGlsZHJlbiwgdm5vZGUuY2hpbGRyZW4sIHJlY3ljbGluZywgaG9va3MsIG51bGwsIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpIHtcblx0XHRpZiAocmVjeWNsaW5nKSB7XG5cdFx0XHRpbml0Q29tcG9uZW50KHZub2RlLCBob29rcylcblx0XHR9IGVsc2Uge1xuXHRcdFx0dm5vZGUuaW5zdGFuY2UgPSBWbm9kZS5ub3JtYWxpemUodm5vZGUuX3N0YXRlLnZpZXcuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHRcdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5fc3RhdGUsIHZub2RlLCBob29rcylcblx0XHR9XG5cdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdGlmIChvbGQuaW5zdGFuY2UgPT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLmluc3RhbmNlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLmluc3RhbmNlLCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0dm5vZGUuZG9tID0gdm5vZGUuaW5zdGFuY2UuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gdm5vZGUuaW5zdGFuY2UuZG9tU2l6ZVxuXHRcdH1cblx0XHRlbHNlIGlmIChvbGQuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQuaW5zdGFuY2UsIG51bGwpXG5cdFx0XHR2bm9kZS5kb20gPSB1bmRlZmluZWRcblx0XHRcdHZub2RlLmRvbVNpemUgPSAwXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGlzUmVjeWNsYWJsZShvbGQsIHZub2Rlcykge1xuXHRcdGlmIChvbGQucG9vbCAhPSBudWxsICYmIE1hdGguYWJzKG9sZC5wb29sLmxlbmd0aCAtIHZub2Rlcy5sZW5ndGgpIDw9IE1hdGguYWJzKG9sZC5sZW5ndGggLSB2bm9kZXMubGVuZ3RoKSkge1xuXHRcdFx0dmFyIG9sZENoaWxkcmVuTGVuZ3RoID0gb2xkWzBdICYmIG9sZFswXS5jaGlsZHJlbiAmJiBvbGRbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdHZhciBwb29sQ2hpbGRyZW5MZW5ndGggPSBvbGQucG9vbFswXSAmJiBvbGQucG9vbFswXS5jaGlsZHJlbiAmJiBvbGQucG9vbFswXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0dmFyIHZub2Rlc0NoaWxkcmVuTGVuZ3RoID0gdm5vZGVzWzBdICYmIHZub2Rlc1swXS5jaGlsZHJlbiAmJiB2bm9kZXNbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdGlmIChNYXRoLmFicyhwb29sQ2hpbGRyZW5MZW5ndGggLSB2bm9kZXNDaGlsZHJlbkxlbmd0aCkgPD0gTWF0aC5hYnMob2xkQ2hpbGRyZW5MZW5ndGggLSB2bm9kZXNDaGlsZHJlbkxlbmd0aCkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblx0ZnVuY3Rpb24gZ2V0S2V5TWFwKHZub2RlcywgZW5kKSB7XG5cdFx0dmFyIG1hcCA9IHt9LCBpID0gMFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIGtleTIgPSB2bm9kZS5rZXlcblx0XHRcdFx0aWYgKGtleTIgIT0gbnVsbCkgbWFwW2tleTJdID0gaVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWFwXG5cdH1cblx0ZnVuY3Rpb24gdG9GcmFnbWVudCh2bm9kZSkge1xuXHRcdHZhciBjb3VudDAgPSB2bm9kZS5kb21TaXplXG5cdFx0aWYgKGNvdW50MCAhPSBudWxsIHx8IHZub2RlLmRvbSA9PSBudWxsKSB7XG5cdFx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdFx0aWYgKGNvdW50MCA+IDApIHtcblx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHR3aGlsZSAoLS1jb3VudDApIGZyYWdtZW50LmFwcGVuZENoaWxkKGRvbS5uZXh0U2libGluZylcblx0XHRcdFx0ZnJhZ21lbnQuaW5zZXJ0QmVmb3JlKGRvbSwgZnJhZ21lbnQuZmlyc3RDaGlsZClcblx0XHRcdH1cblx0XHRcdHJldHVybiBmcmFnbWVudFxuXHRcdH1cblx0XHRlbHNlIHJldHVybiB2bm9kZS5kb21cblx0fVxuXHRmdW5jdGlvbiBnZXROZXh0U2libGluZyh2bm9kZXMsIGksIG5leHRTaWJsaW5nKSB7XG5cdFx0Zm9yICg7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh2bm9kZXNbaV0gIT0gbnVsbCAmJiB2bm9kZXNbaV0uZG9tICE9IG51bGwpIHJldHVybiB2bm9kZXNbaV0uZG9tXG5cdFx0fVxuXHRcdHJldHVybiBuZXh0U2libGluZ1xuXHR9XG5cdGZ1bmN0aW9uIGluc2VydE5vZGUocGFyZW50LCBkb20sIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG5leHRTaWJsaW5nICYmIG5leHRTaWJsaW5nLnBhcmVudE5vZGUpIHBhcmVudC5pbnNlcnRCZWZvcmUoZG9tLCBuZXh0U2libGluZylcblx0XHRlbHNlIHBhcmVudC5hcHBlbmRDaGlsZChkb20pXG5cdH1cblx0ZnVuY3Rpb24gc2V0Q29udGVudEVkaXRhYmxlKHZub2RlKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0udGFnID09PSBcIjxcIikge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjaGlsZHJlblswXS5jaGlsZHJlblxuXHRcdFx0aWYgKHZub2RlLmRvbS5pbm5lckhUTUwgIT09IGNvbnRlbnQpIHZub2RlLmRvbS5pbm5lckhUTUwgPSBjb250ZW50XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHZub2RlLnRleHQgIT0gbnVsbCB8fCBjaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuLmxlbmd0aCAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGQgbm9kZSBvZiBhIGNvbnRlbnRlZGl0YWJsZSBtdXN0IGJlIHRydXN0ZWRcIilcblx0fVxuXHQvL3JlbW92ZVxuXHRmdW5jdGlvbiByZW1vdmVOb2Rlcyh2bm9kZXMsIHN0YXJ0LCBlbmQsIGNvbnRleHQpIHtcblx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAodm5vZGUuc2tpcCkgdm5vZGUuc2tpcCA9IGZhbHNlXG5cdFx0XHRcdGVsc2UgcmVtb3ZlTm9kZSh2bm9kZSwgY29udGV4dClcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZSh2bm9kZSwgY29udGV4dCkge1xuXHRcdHZhciBleHBlY3RlZCA9IDEsIGNhbGxlZCA9IDBcblx0XHRpZiAodm5vZGUuYXR0cnMgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9uYmVmb3JlcmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2bm9kZS5hdHRycy5vbmJlZm9yZXJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHBlY3RlZCsrXG5cdFx0XHRcdHJlc3VsdC50aGVuKGNvbnRpbnVhdGlvbiwgY29udGludWF0aW9uKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9uYmVmb3JlcmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2bm9kZS5fc3RhdGUub25iZWZvcmVyZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0ZXhwZWN0ZWQrK1xuXHRcdFx0XHRyZXN1bHQudGhlbihjb250aW51YXRpb24sIGNvbnRpbnVhdGlvbilcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29udGludWF0aW9uKClcblx0XHRmdW5jdGlvbiBjb250aW51YXRpb24oKSB7XG5cdFx0XHRpZiAoKytjYWxsZWQgPT09IGV4cGVjdGVkKSB7XG5cdFx0XHRcdG9ucmVtb3ZlKHZub2RlKVxuXHRcdFx0XHRpZiAodm5vZGUuZG9tKSB7XG5cdFx0XHRcdFx0dmFyIGNvdW50MCA9IHZub2RlLmRvbVNpemUgfHwgMVxuXHRcdFx0XHRcdGlmIChjb3VudDAgPiAxKSB7XG5cdFx0XHRcdFx0XHR2YXIgZG9tID0gdm5vZGUuZG9tXG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1jb3VudDApIHtcblx0XHRcdFx0XHRcdFx0cmVtb3ZlTm9kZUZyb21ET00oZG9tLm5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZW1vdmVOb2RlRnJvbURPTSh2bm9kZS5kb20pXG5cdFx0XHRcdFx0aWYgKGNvbnRleHQgIT0gbnVsbCAmJiB2bm9kZS5kb21TaXplID09IG51bGwgJiYgIWhhc0ludGVncmF0aW9uTWV0aG9kcyh2bm9kZS5hdHRycykgJiYgdHlwZW9mIHZub2RlLnRhZyA9PT0gXCJzdHJpbmdcIikgeyAvL1RPRE8gdGVzdCBjdXN0b20gZWxlbWVudHNcblx0XHRcdFx0XHRcdGlmICghY29udGV4dC5wb29sKSBjb250ZXh0LnBvb2wgPSBbdm5vZGVdXG5cdFx0XHRcdFx0XHRlbHNlIGNvbnRleHQucG9vbC5wdXNoKHZub2RlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZW1vdmVOb2RlRnJvbURPTShub2RlKSB7XG5cdFx0dmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZVxuXHRcdGlmIChwYXJlbnQgIT0gbnVsbCkgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpXG5cdH1cblx0ZnVuY3Rpb24gb25yZW1vdmUodm5vZGUpIHtcblx0XHRpZiAodm5vZGUuYXR0cnMgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHZub2RlLmF0dHJzLm9ucmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRpZiAodHlwZW9mIHZub2RlLl9zdGF0ZS5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5fc3RhdGUub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkgb25yZW1vdmUodm5vZGUuaW5zdGFuY2UpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG5cdFx0XHRcdFx0aWYgKGNoaWxkICE9IG51bGwpIG9ucmVtb3ZlKGNoaWxkKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vYXR0cnMyXG5cdGZ1bmN0aW9uIHNldEF0dHJzKHZub2RlLCBhdHRyczIsIG5zKSB7XG5cdFx0Zm9yICh2YXIga2V5MiBpbiBhdHRyczIpIHtcblx0XHRcdHNldEF0dHIodm5vZGUsIGtleTIsIG51bGwsIGF0dHJzMltrZXkyXSwgbnMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldEF0dHIodm5vZGUsIGtleTIsIG9sZCwgdmFsdWUsIG5zKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb21cblx0XHRpZiAoa2V5MiA9PT0gXCJrZXlcIiB8fCBrZXkyID09PSBcImlzXCIgfHwgKG9sZCA9PT0gdmFsdWUgJiYgIWlzRm9ybUF0dHJpYnV0ZSh2bm9kZSwga2V5MikpICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgaXNMaWZlY3ljbGVNZXRob2Qoa2V5MikpIHJldHVyblxuXHRcdHZhciBuc0xhc3RJbmRleCA9IGtleTIuaW5kZXhPZihcIjpcIilcblx0XHRpZiAobnNMYXN0SW5kZXggPiAtMSAmJiBrZXkyLnN1YnN0cigwLCBuc0xhc3RJbmRleCkgPT09IFwieGxpbmtcIikge1xuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwga2V5Mi5zbGljZShuc0xhc3RJbmRleCArIDEpLCB2YWx1ZSlcblx0XHR9XG5cdFx0ZWxzZSBpZiAoa2V5MlswXSA9PT0gXCJvXCIgJiYga2V5MlsxXSA9PT0gXCJuXCIgJiYgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB2YWx1ZSlcblx0XHRlbHNlIGlmIChrZXkyID09PSBcInN0eWxlXCIpIHVwZGF0ZVN0eWxlKGVsZW1lbnQsIG9sZCwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5MiBpbiBlbGVtZW50ICYmICFpc0F0dHJpYnV0ZShrZXkyKSAmJiBucyA9PT0gdW5kZWZpbmVkICYmICFpc0N1c3RvbUVsZW1lbnQodm5vZGUpKSB7XG5cdFx0XHRpZiAoa2V5MiA9PT0gXCJ2YWx1ZVwiKSB7XG5cdFx0XHRcdHZhciBub3JtYWxpemVkMCA9IFwiXCIgKyB2YWx1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWltcGxpY2l0LWNvZXJjaW9uXG5cdFx0XHRcdC8vc2V0dGluZyBpbnB1dFt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSBieSB0eXBpbmcgb24gZm9jdXNlZCBlbGVtZW50IG1vdmVzIGN1cnNvciB0byBlbmQgaW4gQ2hyb21lXG5cdFx0XHRcdGlmICgodm5vZGUudGFnID09PSBcImlucHV0XCIgfHwgdm5vZGUudGFnID09PSBcInRleHRhcmVhXCIpICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZDAgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHQvL3NldHRpbmcgc2VsZWN0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIHdoaWxlIGhhdmluZyBzZWxlY3Qgb3BlbiBibGlua3Mgc2VsZWN0IGRyb3Bkb3duIGluIENocm9tZVxuXHRcdFx0XHRpZiAodm5vZGUudGFnID09PSBcInNlbGVjdFwiKSB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRpZiAodm5vZGUuZG9tLnNlbGVjdGVkSW5kZXggPT09IC0xICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKG9sZCAhPT0gbnVsbCAmJiB2bm9kZS5kb20udmFsdWUgPT09IG5vcm1hbGl6ZWQwICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9zZXR0aW5nIG9wdGlvblt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJvcHRpb25cIiAmJiBvbGQgIT0gbnVsbCAmJiB2bm9kZS5kb20udmFsdWUgPT09IG5vcm1hbGl6ZWQwKSByZXR1cm5cblx0XHRcdH1cblx0XHRcdC8vIElmIHlvdSBhc3NpZ24gYW4gaW5wdXQgdHlwZTEgdGhhdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFIDExIHdpdGggYW4gYXNzaWdubWVudCBleHByZXNzaW9uLCBhbiBlcnJvcjAgd2lsbCBvY2N1ci5cblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiAmJiBrZXkyID09PSBcInR5cGVcIikge1xuXHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyLCB2YWx1ZSlcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRlbGVtZW50W2tleTJdID0gdmFsdWVcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuXHRcdFx0XHRpZiAodmFsdWUpIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIsIFwiXCIpXG5cdFx0XHRcdGVsc2UgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5Milcblx0XHRcdH1cblx0XHRcdGVsc2UgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiA9PT0gXCJjbGFzc05hbWVcIiA/IFwiY2xhc3NcIiA6IGtleTIsIHZhbHVlKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRMYXRlQXR0cnModm5vZGUpIHtcblx0XHR2YXIgYXR0cnMyID0gdm5vZGUuYXR0cnNcblx0XHRpZiAodm5vZGUudGFnID09PSBcInNlbGVjdFwiICYmIGF0dHJzMiAhPSBudWxsKSB7XG5cdFx0XHRpZiAoXCJ2YWx1ZVwiIGluIGF0dHJzMikgc2V0QXR0cih2bm9kZSwgXCJ2YWx1ZVwiLCBudWxsLCBhdHRyczIudmFsdWUsIHVuZGVmaW5lZClcblx0XHRcdGlmIChcInNlbGVjdGVkSW5kZXhcIiBpbiBhdHRyczIpIHNldEF0dHIodm5vZGUsIFwic2VsZWN0ZWRJbmRleFwiLCBudWxsLCBhdHRyczIuc2VsZWN0ZWRJbmRleCwgdW5kZWZpbmVkKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVBdHRycyh2bm9kZSwgb2xkLCBhdHRyczIsIG5zKSB7XG5cdFx0aWYgKGF0dHJzMiAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIGF0dHJzMikge1xuXHRcdFx0XHRzZXRBdHRyKHZub2RlLCBrZXkyLCBvbGQgJiYgb2xkW2tleTJdLCBhdHRyczJba2V5Ml0sIG5zKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAob2xkICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTIgaW4gb2xkKSB7XG5cdFx0XHRcdGlmIChhdHRyczIgPT0gbnVsbCB8fCAhKGtleTIgaW4gYXR0cnMyKSkge1xuXHRcdFx0XHRcdGlmIChrZXkyID09PSBcImNsYXNzTmFtZVwiKSBrZXkyID0gXCJjbGFzc1wiXG5cdFx0XHRcdFx0aWYgKGtleTJbMF0gPT09IFwib1wiICYmIGtleTJbMV0gPT09IFwiblwiICYmICFpc0xpZmVjeWNsZU1ldGhvZChrZXkyKSkgdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHVuZGVmaW5lZClcblx0XHRcdFx0XHRlbHNlIGlmIChrZXkyICE9PSBcImtleVwiKSB2bm9kZS5kb20ucmVtb3ZlQXR0cmlidXRlKGtleTIpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gaXNGb3JtQXR0cmlidXRlKHZub2RlLCBhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwidmFsdWVcIiB8fCBhdHRyID09PSBcImNoZWNrZWRcIiB8fCBhdHRyID09PSBcInNlbGVjdGVkSW5kZXhcIiB8fCBhdHRyID09PSBcInNlbGVjdGVkXCIgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0fVxuXHRmdW5jdGlvbiBpc0xpZmVjeWNsZU1ldGhvZChhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwib25pbml0XCIgfHwgYXR0ciA9PT0gXCJvbmNyZWF0ZVwiIHx8IGF0dHIgPT09IFwib251cGRhdGVcIiB8fCBhdHRyID09PSBcIm9ucmVtb3ZlXCIgfHwgYXR0ciA9PT0gXCJvbmJlZm9yZXJlbW92ZVwiIHx8IGF0dHIgPT09IFwib25iZWZvcmV1cGRhdGVcIlxuXHR9XG5cdGZ1bmN0aW9uIGlzQXR0cmlidXRlKGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJocmVmXCIgfHwgYXR0ciA9PT0gXCJsaXN0XCIgfHwgYXR0ciA9PT0gXCJmb3JtXCIgfHwgYXR0ciA9PT0gXCJ3aWR0aFwiIHx8IGF0dHIgPT09IFwiaGVpZ2h0XCIvLyB8fCBhdHRyID09PSBcInR5cGVcIlxuXHR9XG5cdGZ1bmN0aW9uIGlzQ3VzdG9tRWxlbWVudCh2bm9kZSl7XG5cdFx0cmV0dXJuIHZub2RlLmF0dHJzLmlzIHx8IHZub2RlLnRhZy5pbmRleE9mKFwiLVwiKSA+IC0xXG5cdH1cblx0ZnVuY3Rpb24gaGFzSW50ZWdyYXRpb25NZXRob2RzKHNvdXJjZSkge1xuXHRcdHJldHVybiBzb3VyY2UgIT0gbnVsbCAmJiAoc291cmNlLm9uY3JlYXRlIHx8IHNvdXJjZS5vbnVwZGF0ZSB8fCBzb3VyY2Uub25iZWZvcmVyZW1vdmUgfHwgc291cmNlLm9ucmVtb3ZlKVxuXHR9XG5cdC8vc3R5bGVcblx0ZnVuY3Rpb24gdXBkYXRlU3R5bGUoZWxlbWVudCwgb2xkLCBzdHlsZSkge1xuXHRcdGlmIChvbGQgPT09IHN0eWxlKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiLCBvbGQgPSBudWxsXG5cdFx0aWYgKHN0eWxlID09IG51bGwpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCJcblx0XHRlbHNlIGlmICh0eXBlb2Ygc3R5bGUgPT09IFwic3RyaW5nXCIpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IHN0eWxlXG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIG9sZCA9PT0gXCJzdHJpbmdcIikgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBzdHlsZSkge1xuXHRcdFx0XHRlbGVtZW50LnN0eWxlW2tleTJdID0gc3R5bGVba2V5Ml1cblx0XHRcdH1cblx0XHRcdGlmIChvbGQgIT0gbnVsbCAmJiB0eXBlb2Ygb2xkICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleTIgaW4gb2xkKSB7XG5cdFx0XHRcdFx0aWYgKCEoa2V5MiBpbiBzdHlsZSkpIGVsZW1lbnQuc3R5bGVba2V5Ml0gPSBcIlwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9ldmVudFxuXHRmdW5jdGlvbiB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdmFsdWUpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbVxuXHRcdHZhciBjYWxsYmFjayA9IHR5cGVvZiBvbmV2ZW50ICE9PSBcImZ1bmN0aW9uXCIgPyB2YWx1ZSA6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2YWx1ZS5jYWxsKGVsZW1lbnQsIGUpXG5cdFx0XHRvbmV2ZW50LmNhbGwoZWxlbWVudCwgZSlcblx0XHRcdHJldHVybiByZXN1bHRcblx0XHR9XG5cdFx0aWYgKGtleTIgaW4gZWxlbWVudCkgZWxlbWVudFtrZXkyXSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gY2FsbGJhY2sgOiBudWxsXG5cdFx0ZWxzZSB7XG5cdFx0XHR2YXIgZXZlbnROYW1lID0ga2V5Mi5zbGljZSgyKVxuXHRcdFx0aWYgKHZub2RlLmV2ZW50cyA9PT0gdW5kZWZpbmVkKSB2bm9kZS5ldmVudHMgPSB7fVxuXHRcdFx0aWYgKHZub2RlLmV2ZW50c1trZXkyXSA9PT0gY2FsbGJhY2spIHJldHVyblxuXHRcdFx0aWYgKHZub2RlLmV2ZW50c1trZXkyXSAhPSBudWxsKSBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB2bm9kZS5ldmVudHNba2V5Ml0sIGZhbHNlKVxuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHZub2RlLmV2ZW50c1trZXkyXSA9IGNhbGxiYWNrXG5cdFx0XHRcdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHZub2RlLmV2ZW50c1trZXkyXSwgZmFsc2UpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vbGlmZWN5Y2xlXG5cdGZ1bmN0aW9uIGluaXRMaWZlY3ljbGUoc291cmNlLCB2bm9kZSwgaG9va3MpIHtcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbmluaXQgPT09IFwiZnVuY3Rpb25cIikgc291cmNlLm9uaW5pdC5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiKSBob29rcy5wdXNoKHNvdXJjZS5vbmNyZWF0ZS5iaW5kKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlTGlmZWN5Y2xlKHNvdXJjZSwgdm5vZGUsIGhvb2tzKSB7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub251cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgaG9va3MucHVzaChzb3VyY2Uub251cGRhdGUuYmluZCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHR9XG5cdGZ1bmN0aW9uIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSB7XG5cdFx0dmFyIGZvcmNlVm5vZGVVcGRhdGUsIGZvcmNlQ29tcG9uZW50VXBkYXRlXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9uYmVmb3JldXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGZvcmNlVm5vZGVVcGRhdGUgPSB2bm9kZS5hdHRycy5vbmJlZm9yZXVwZGF0ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSwgb2xkKVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2bm9kZS5fc3RhdGUub25iZWZvcmV1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgZm9yY2VDb21wb25lbnRVcGRhdGUgPSB2bm9kZS5fc3RhdGUub25iZWZvcmV1cGRhdGUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUsIG9sZClcblx0XHRpZiAoIShmb3JjZVZub2RlVXBkYXRlID09PSB1bmRlZmluZWQgJiYgZm9yY2VDb21wb25lbnRVcGRhdGUgPT09IHVuZGVmaW5lZCkgJiYgIWZvcmNlVm5vZGVVcGRhdGUgJiYgIWZvcmNlQ29tcG9uZW50VXBkYXRlKSB7XG5cdFx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0XHRcdHZub2RlLmluc3RhbmNlID0gb2xkLmluc3RhbmNlXG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXHRmdW5jdGlvbiByZW5kZXIoZG9tLCB2bm9kZXMpIHtcblx0XHRpZiAoIWRvbSkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBET00gZWxlbWVudCBiZWluZyBwYXNzZWQgdG8gbS5yb3V0ZS9tLm1vdW50L20ucmVuZGVyIGlzIG5vdCB1bmRlZmluZWQuXCIpXG5cdFx0dmFyIGhvb2tzID0gW11cblx0XHR2YXIgYWN0aXZlID0gJGRvYy5hY3RpdmVFbGVtZW50XG5cdFx0dmFyIG5hbWVzcGFjZSA9IGRvbS5uYW1lc3BhY2VVUklcblx0XHQvLyBGaXJzdCB0aW1lMCByZW5kZXJpbmcgaW50byBhIG5vZGUgY2xlYXJzIGl0IG91dFxuXHRcdGlmIChkb20udm5vZGVzID09IG51bGwpIGRvbS50ZXh0Q29udGVudCA9IFwiXCJcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkodm5vZGVzKSkgdm5vZGVzID0gW3Zub2Rlc11cblx0XHR1cGRhdGVOb2Rlcyhkb20sIGRvbS52bm9kZXMsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlcyksIGZhbHNlLCBob29rcywgbnVsbCwgbmFtZXNwYWNlID09PSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiA/IHVuZGVmaW5lZCA6IG5hbWVzcGFjZSlcblx0XHRkb20udm5vZGVzID0gdm5vZGVzXG5cdFx0Ly8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gcmV0dXJuIG51bGwgaW4gSUUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L2FjdGl2ZUVsZW1lbnRcblx0XHRpZiAoYWN0aXZlICE9IG51bGwgJiYgJGRvYy5hY3RpdmVFbGVtZW50ICE9PSBhY3RpdmUpIGFjdGl2ZS5mb2N1cygpXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykgaG9va3NbaV0oKVxuXHR9XG5cdHJldHVybiB7cmVuZGVyOiByZW5kZXIsIHNldEV2ZW50Q2FsbGJhY2s6IHNldEV2ZW50Q2FsbGJhY2t9XG59XG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaykge1xuXHQvLzYwZnBzIHRyYW5zbGF0ZXMgdG8gMTYuNm1zLCByb3VuZCBpdCBkb3duIHNpbmNlIHNldFRpbWVvdXQgcmVxdWlyZXMgaW50XG5cdHZhciB0aW1lID0gMTZcblx0dmFyIGxhc3QgPSAwLCBwZW5kaW5nID0gbnVsbFxuXHR2YXIgdGltZW91dCA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IFwiZnVuY3Rpb25cIiA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHNldFRpbWVvdXRcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpXG5cdFx0aWYgKGxhc3QgPT09IDAgfHwgbm93IC0gbGFzdCA+PSB0aW1lKSB7XG5cdFx0XHRsYXN0ID0gbm93XG5cdFx0XHRjYWxsYmFjaygpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcblx0XHRcdHBlbmRpbmcgPSB0aW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwZW5kaW5nID0gbnVsbFxuXHRcdFx0XHRjYWxsYmFjaygpXG5cdFx0XHRcdGxhc3QgPSBEYXRlLm5vdygpXG5cdFx0XHR9LCB0aW1lIC0gKG5vdyAtIGxhc3QpKVxuXHRcdH1cblx0fVxufVxudmFyIF8xMSA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIHJlbmRlclNlcnZpY2UgPSBjb3JlUmVuZGVyZXIoJHdpbmRvdylcblx0cmVuZGVyU2VydmljZS5zZXRFdmVudENhbGxiYWNrKGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAoZS5yZWRyYXcgPT09IGZhbHNlKSBlLnJlZHJhdyA9IHVuZGVmaW5lZFxuXHRcdGVsc2UgcmVkcmF3KClcblx0fSlcblx0dmFyIGNhbGxiYWNrcyA9IFtdXG5cdGZ1bmN0aW9uIHN1YnNjcmliZShrZXkxLCBjYWxsYmFjaykge1xuXHRcdHVuc3Vic2NyaWJlKGtleTEpXG5cdFx0Y2FsbGJhY2tzLnB1c2goa2V5MSwgdGhyb3R0bGUoY2FsbGJhY2spKVxuXHR9XG5cdGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGtleTEpIHtcblx0XHR2YXIgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihrZXkxKVxuXHRcdGlmIChpbmRleCA+IC0xKSBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAyKVxuXHR9XG5cdGZ1bmN0aW9uIHJlZHJhdygpIHtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMikge1xuXHRcdFx0Y2FsbGJhY2tzW2ldKClcblx0XHR9XG5cdH1cblx0cmV0dXJuIHtzdWJzY3JpYmU6IHN1YnNjcmliZSwgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlLCByZWRyYXc6IHJlZHJhdywgcmVuZGVyOiByZW5kZXJTZXJ2aWNlLnJlbmRlcn1cbn1cbnZhciByZWRyYXdTZXJ2aWNlID0gXzExKHdpbmRvdylcbnJlcXVlc3RTZXJ2aWNlLnNldENvbXBsZXRpb25DYWxsYmFjayhyZWRyYXdTZXJ2aWNlLnJlZHJhdylcbnZhciBfMTYgPSBmdW5jdGlvbihyZWRyYXdTZXJ2aWNlMCkge1xuXHRyZXR1cm4gZnVuY3Rpb24ocm9vdCwgY29tcG9uZW50KSB7XG5cdFx0aWYgKGNvbXBvbmVudCA9PT0gbnVsbCkge1xuXHRcdFx0cmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIFtdKVxuXHRcdFx0cmVkcmF3U2VydmljZTAudW5zdWJzY3JpYmUocm9vdClcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHRpZiAoY29tcG9uZW50LnZpZXcgPT0gbnVsbCAmJiB0eXBlb2YgY29tcG9uZW50ICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcIm0ubW91bnQoZWxlbWVudCwgY29tcG9uZW50KSBleHBlY3RzIGEgY29tcG9uZW50LCBub3QgYSB2bm9kZVwiKVxuXHRcdFxuXHRcdHZhciBydW4wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgVm5vZGUoY29tcG9uZW50KSlcblx0XHR9XG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjApXG5cdFx0cmVkcmF3U2VydmljZTAucmVkcmF3KClcblx0fVxufVxubS5tb3VudCA9IF8xNihyZWRyYXdTZXJ2aWNlKVxudmFyIFByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcbnZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdGlmIChzdHJpbmcgPT09IFwiXCIgfHwgc3RyaW5nID09IG51bGwpIHJldHVybiB7fVxuXHRpZiAoc3RyaW5nLmNoYXJBdCgwKSA9PT0gXCI/XCIpIHN0cmluZyA9IHN0cmluZy5zbGljZSgxKVxuXHR2YXIgZW50cmllcyA9IHN0cmluZy5zcGxpdChcIiZcIiksIGRhdGEwID0ge30sIGNvdW50ZXJzID0ge31cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGVudHJ5ID0gZW50cmllc1tpXS5zcGxpdChcIj1cIilcblx0XHR2YXIga2V5NSA9IGRlY29kZVVSSUNvbXBvbmVudChlbnRyeVswXSlcblx0XHR2YXIgdmFsdWUgPSBlbnRyeS5sZW5ndGggPT09IDIgPyBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMV0pIDogXCJcIlxuXHRcdGlmICh2YWx1ZSA9PT0gXCJ0cnVlXCIpIHZhbHVlID0gdHJ1ZVxuXHRcdGVsc2UgaWYgKHZhbHVlID09PSBcImZhbHNlXCIpIHZhbHVlID0gZmFsc2Vcblx0XHR2YXIgbGV2ZWxzID0ga2V5NS5zcGxpdCgvXFxdXFxbP3xcXFsvKVxuXHRcdHZhciBjdXJzb3IgPSBkYXRhMFxuXHRcdGlmIChrZXk1LmluZGV4T2YoXCJbXCIpID4gLTEpIGxldmVscy5wb3AoKVxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbal0sIG5leHRMZXZlbCA9IGxldmVsc1tqICsgMV1cblx0XHRcdHZhciBpc051bWJlciA9IG5leHRMZXZlbCA9PSBcIlwiIHx8ICFpc05hTihwYXJzZUludChuZXh0TGV2ZWwsIDEwKSlcblx0XHRcdHZhciBpc1ZhbHVlID0gaiA9PT0gbGV2ZWxzLmxlbmd0aCAtIDFcblx0XHRcdGlmIChsZXZlbCA9PT0gXCJcIikge1xuXHRcdFx0XHR2YXIga2V5NSA9IGxldmVscy5zbGljZSgwLCBqKS5qb2luKClcblx0XHRcdFx0aWYgKGNvdW50ZXJzW2tleTVdID09IG51bGwpIGNvdW50ZXJzW2tleTVdID0gMFxuXHRcdFx0XHRsZXZlbCA9IGNvdW50ZXJzW2tleTVdKytcblx0XHRcdH1cblx0XHRcdGlmIChjdXJzb3JbbGV2ZWxdID09IG51bGwpIHtcblx0XHRcdFx0Y3Vyc29yW2xldmVsXSA9IGlzVmFsdWUgPyB2YWx1ZSA6IGlzTnVtYmVyID8gW10gOiB7fVxuXHRcdFx0fVxuXHRcdFx0Y3Vyc29yID0gY3Vyc29yW2xldmVsXVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTBcbn1cbnZhciBjb3JlUm91dGVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgc3VwcG9ydHNQdXNoU3RhdGUgPSB0eXBlb2YgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSA9PT0gXCJmdW5jdGlvblwiXG5cdHZhciBjYWxsQXN5bmMwID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogc2V0VGltZW91dFxuXHRmdW5jdGlvbiBub3JtYWxpemUxKGZyYWdtZW50MCkge1xuXHRcdHZhciBkYXRhID0gJHdpbmRvdy5sb2NhdGlvbltmcmFnbWVudDBdLnJlcGxhY2UoLyg/OiVbYS1mODldW2EtZjAtOV0pKy9naW0sIGRlY29kZVVSSUNvbXBvbmVudClcblx0XHRpZiAoZnJhZ21lbnQwID09PSBcInBhdGhuYW1lXCIgJiYgZGF0YVswXSAhPT0gXCIvXCIpIGRhdGEgPSBcIi9cIiArIGRhdGFcblx0XHRyZXR1cm4gZGF0YVxuXHR9XG5cdHZhciBhc3luY0lkXG5cdGZ1bmN0aW9uIGRlYm91bmNlQXN5bmMoY2FsbGJhY2swKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKGFzeW5jSWQgIT0gbnVsbCkgcmV0dXJuXG5cdFx0XHRhc3luY0lkID0gY2FsbEFzeW5jMChmdW5jdGlvbigpIHtcblx0XHRcdFx0YXN5bmNJZCA9IG51bGxcblx0XHRcdFx0Y2FsbGJhY2swKClcblx0XHRcdH0pXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoLCBxdWVyeURhdGEsIGhhc2hEYXRhKSB7XG5cdFx0dmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpXG5cdFx0dmFyIGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIilcblx0XHR2YXIgcGF0aEVuZCA9IHF1ZXJ5SW5kZXggPiAtMSA/IHF1ZXJ5SW5kZXggOiBoYXNoSW5kZXggPiAtMSA/IGhhc2hJbmRleCA6IHBhdGgubGVuZ3RoXG5cdFx0aWYgKHF1ZXJ5SW5kZXggPiAtMSkge1xuXHRcdFx0dmFyIHF1ZXJ5RW5kID0gaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiBwYXRoLmxlbmd0aFxuXHRcdFx0dmFyIHF1ZXJ5UGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKHF1ZXJ5SW5kZXggKyAxLCBxdWVyeUVuZCkpXG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIHF1ZXJ5UGFyYW1zKSBxdWVyeURhdGFba2V5NF0gPSBxdWVyeVBhcmFtc1trZXk0XVxuXHRcdH1cblx0XHRpZiAoaGFzaEluZGV4ID4gLTEpIHtcblx0XHRcdHZhciBoYXNoUGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKGhhc2hJbmRleCArIDEpKVxuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBoYXNoUGFyYW1zKSBoYXNoRGF0YVtrZXk0XSA9IGhhc2hQYXJhbXNba2V5NF1cblx0XHR9XG5cdFx0cmV0dXJuIHBhdGguc2xpY2UoMCwgcGF0aEVuZClcblx0fVxuXHR2YXIgcm91dGVyID0ge3ByZWZpeDogXCIjIVwifVxuXHRyb3V0ZXIuZ2V0UGF0aCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0eXBlMiA9IHJvdXRlci5wcmVmaXguY2hhckF0KDApXG5cdFx0c3dpdGNoICh0eXBlMikge1xuXHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJoYXNoXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0Y2FzZSBcIj9cIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJzZWFyY2hcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcImhhc2hcIilcblx0XHRcdGRlZmF1bHQ6IHJldHVybiBub3JtYWxpemUxKFwicGF0aG5hbWVcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcInNlYXJjaFwiKSArIG5vcm1hbGl6ZTEoXCJoYXNoXCIpXG5cdFx0fVxuXHR9XG5cdHJvdXRlci5zZXRQYXRoID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdHZhciBxdWVyeURhdGEgPSB7fSwgaGFzaERhdGEgPSB7fVxuXHRcdHBhdGggPSBwYXJzZVBhdGgocGF0aCwgcXVlcnlEYXRhLCBoYXNoRGF0YSlcblx0XHRpZiAoZGF0YSAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIGRhdGEpIHF1ZXJ5RGF0YVtrZXk0XSA9IGRhdGFba2V5NF1cblx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoLzooW15cXC9dKykvZywgZnVuY3Rpb24obWF0Y2gyLCB0b2tlbikge1xuXHRcdFx0XHRkZWxldGUgcXVlcnlEYXRhW3Rva2VuXVxuXHRcdFx0XHRyZXR1cm4gZGF0YVt0b2tlbl1cblx0XHRcdH0pXG5cdFx0fVxuXHRcdHZhciBxdWVyeSA9IGJ1aWxkUXVlcnlTdHJpbmcocXVlcnlEYXRhKVxuXHRcdGlmIChxdWVyeSkgcGF0aCArPSBcIj9cIiArIHF1ZXJ5XG5cdFx0dmFyIGhhc2ggPSBidWlsZFF1ZXJ5U3RyaW5nKGhhc2hEYXRhKVxuXHRcdGlmIChoYXNoKSBwYXRoICs9IFwiI1wiICsgaGFzaFxuXHRcdGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkge1xuXHRcdFx0dmFyIHN0YXRlID0gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdGUgOiBudWxsXG5cdFx0XHR2YXIgdGl0bGUgPSBvcHRpb25zID8gb3B0aW9ucy50aXRsZSA6IG51bGxcblx0XHRcdCR3aW5kb3cub25wb3BzdGF0ZSgpXG5cdFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpICR3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCByb3V0ZXIucHJlZml4ICsgcGF0aClcblx0XHRcdGVsc2UgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIHJvdXRlci5wcmVmaXggKyBwYXRoKVxuXHRcdH1cblx0XHRlbHNlICR3aW5kb3cubG9jYXRpb24uaHJlZiA9IHJvdXRlci5wcmVmaXggKyBwYXRoXG5cdH1cblx0cm91dGVyLmRlZmluZVJvdXRlcyA9IGZ1bmN0aW9uKHJvdXRlcywgcmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZVJvdXRlKCkge1xuXHRcdFx0dmFyIHBhdGggPSByb3V0ZXIuZ2V0UGF0aCgpXG5cdFx0XHR2YXIgcGFyYW1zID0ge31cblx0XHRcdHZhciBwYXRobmFtZSA9IHBhcnNlUGF0aChwYXRoLCBwYXJhbXMsIHBhcmFtcylcblx0XHRcdHZhciBzdGF0ZSA9ICR3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuXHRcdFx0aWYgKHN0YXRlICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yICh2YXIgayBpbiBzdGF0ZSkgcGFyYW1zW2tdID0gc3RhdGVba11cblx0XHRcdH1cblx0XHRcdGZvciAodmFyIHJvdXRlMCBpbiByb3V0ZXMpIHtcblx0XHRcdFx0dmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKFwiXlwiICsgcm91dGUwLnJlcGxhY2UoLzpbXlxcL10rP1xcLnszfS9nLCBcIiguKj8pXCIpLnJlcGxhY2UoLzpbXlxcL10rL2csIFwiKFteXFxcXC9dKylcIikgKyBcIlxcLz8kXCIpXG5cdFx0XHRcdGlmIChtYXRjaGVyLnRlc3QocGF0aG5hbWUpKSB7XG5cdFx0XHRcdFx0cGF0aG5hbWUucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBrZXlzID0gcm91dGUwLm1hdGNoKC86W15cXC9dKy9nKSB8fCBbXVxuXHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxLCAtMilcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRwYXJhbXNba2V5c1tpXS5yZXBsYWNlKC86fFxcLi9nLCBcIlwiKV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWVzW2ldKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzb2x2ZShyb3V0ZXNbcm91dGUwXSwgcGFyYW1zLCBwYXRoLCByb3V0ZTApXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVqZWN0KHBhdGgsIHBhcmFtcylcblx0XHR9XG5cdFx0aWYgKHN1cHBvcnRzUHVzaFN0YXRlKSAkd2luZG93Lm9ucG9wc3RhdGUgPSBkZWJvdW5jZUFzeW5jKHJlc29sdmVSb3V0ZSlcblx0XHRlbHNlIGlmIChyb3V0ZXIucHJlZml4LmNoYXJBdCgwKSA9PT0gXCIjXCIpICR3aW5kb3cub25oYXNoY2hhbmdlID0gcmVzb2x2ZVJvdXRlXG5cdFx0cmVzb2x2ZVJvdXRlKClcblx0fVxuXHRyZXR1cm4gcm91dGVyXG59XG52YXIgXzIwID0gZnVuY3Rpb24oJHdpbmRvdywgcmVkcmF3U2VydmljZTApIHtcblx0dmFyIHJvdXRlU2VydmljZSA9IGNvcmVSb3V0ZXIoJHdpbmRvdylcblx0dmFyIGlkZW50aXR5ID0gZnVuY3Rpb24odikge3JldHVybiB2fVxuXHR2YXIgcmVuZGVyMSwgY29tcG9uZW50LCBhdHRyczMsIGN1cnJlbnRQYXRoLCBsYXN0VXBkYXRlXG5cdHZhciByb3V0ZSA9IGZ1bmN0aW9uKHJvb3QsIGRlZmF1bHRSb3V0ZSwgcm91dGVzKSB7XG5cdFx0aWYgKHJvb3QgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBET00gZWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgdG8gYG0ucm91dGVgIGlzIG5vdCB1bmRlZmluZWRcIilcblx0XHR2YXIgcnVuMSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHJlbmRlcjEgIT0gbnVsbCkgcmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIHJlbmRlcjEoVm5vZGUoY29tcG9uZW50LCBhdHRyczMua2V5LCBhdHRyczMpKSlcblx0XHR9XG5cdFx0dmFyIGJhaWwgPSBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRpZiAocGF0aCAhPT0gZGVmYXVsdFJvdXRlKSByb3V0ZVNlcnZpY2Uuc2V0UGF0aChkZWZhdWx0Um91dGUsIG51bGwsIHtyZXBsYWNlOiB0cnVlfSlcblx0XHRcdGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgZGVmYXVsdCByb3V0ZSBcIiArIGRlZmF1bHRSb3V0ZSlcblx0XHR9XG5cdFx0cm91dGVTZXJ2aWNlLmRlZmluZVJvdXRlcyhyb3V0ZXMsIGZ1bmN0aW9uKHBheWxvYWQsIHBhcmFtcywgcGF0aCkge1xuXHRcdFx0dmFyIHVwZGF0ZSA9IGxhc3RVcGRhdGUgPSBmdW5jdGlvbihyb3V0ZVJlc29sdmVyLCBjb21wKSB7XG5cdFx0XHRcdGlmICh1cGRhdGUgIT09IGxhc3RVcGRhdGUpIHJldHVyblxuXHRcdFx0XHRjb21wb25lbnQgPSBjb21wICE9IG51bGwgJiYgKHR5cGVvZiBjb21wLnZpZXcgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgY29tcCA9PT0gXCJmdW5jdGlvblwiKT8gY29tcCA6IFwiZGl2XCJcblx0XHRcdFx0YXR0cnMzID0gcGFyYW1zLCBjdXJyZW50UGF0aCA9IHBhdGgsIGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0XHRcdHJlbmRlcjEgPSAocm91dGVSZXNvbHZlci5yZW5kZXIgfHwgaWRlbnRpdHkpLmJpbmQocm91dGVSZXNvbHZlcilcblx0XHRcdFx0cnVuMSgpXG5cdFx0XHR9XG5cdFx0XHRpZiAocGF5bG9hZC52aWV3IHx8IHR5cGVvZiBwYXlsb2FkID09PSBcImZ1bmN0aW9uXCIpIHVwZGF0ZSh7fSwgcGF5bG9hZClcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAocGF5bG9hZC5vbm1hdGNoKSB7XG5cdFx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKHBheWxvYWQub25tYXRjaChwYXJhbXMsIHBhdGgpKS50aGVuKGZ1bmN0aW9uKHJlc29sdmVkKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGUocGF5bG9hZCwgcmVzb2x2ZWQpXG5cdFx0XHRcdFx0fSwgYmFpbClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHVwZGF0ZShwYXlsb2FkLCBcImRpdlwiKVxuXHRcdFx0fVxuXHRcdH0sIGJhaWwpXG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjEpXG5cdH1cblx0cm91dGUuc2V0ID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdGlmIChsYXN0VXBkYXRlICE9IG51bGwpIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cdFx0XHRvcHRpb25zLnJlcGxhY2UgPSB0cnVlXG5cdFx0fVxuXHRcdGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0cm91dGVTZXJ2aWNlLnNldFBhdGgocGF0aCwgZGF0YSwgb3B0aW9ucylcblx0fVxuXHRyb3V0ZS5nZXQgPSBmdW5jdGlvbigpIHtyZXR1cm4gY3VycmVudFBhdGh9XG5cdHJvdXRlLnByZWZpeCA9IGZ1bmN0aW9uKHByZWZpeDApIHtyb3V0ZVNlcnZpY2UucHJlZml4ID0gcHJlZml4MH1cblx0cm91dGUubGluayA9IGZ1bmN0aW9uKHZub2RlMSkge1xuXHRcdHZub2RlMS5kb20uc2V0QXR0cmlidXRlKFwiaHJlZlwiLCByb3V0ZVNlcnZpY2UucHJlZml4ICsgdm5vZGUxLmF0dHJzLmhyZWYpXG5cdFx0dm5vZGUxLmRvbS5vbmNsaWNrID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSB8fCBlLndoaWNoID09PSAyKSByZXR1cm5cblx0XHRcdGUucHJldmVudERlZmF1bHQoKVxuXHRcdFx0ZS5yZWRyYXcgPSBmYWxzZVxuXHRcdFx0dmFyIGhyZWYgPSB0aGlzLmdldEF0dHJpYnV0ZShcImhyZWZcIilcblx0XHRcdGlmIChocmVmLmluZGV4T2Yocm91dGVTZXJ2aWNlLnByZWZpeCkgPT09IDApIGhyZWYgPSBocmVmLnNsaWNlKHJvdXRlU2VydmljZS5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0cm91dGUuc2V0KGhyZWYsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRcdH1cblx0fVxuXHRyb3V0ZS5wYXJhbSA9IGZ1bmN0aW9uKGtleTMpIHtcblx0XHRpZih0eXBlb2YgYXR0cnMzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBrZXkzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gYXR0cnMzW2tleTNdXG5cdFx0cmV0dXJuIGF0dHJzM1xuXHR9XG5cdHJldHVybiByb3V0ZVxufVxubS5yb3V0ZSA9IF8yMCh3aW5kb3csIHJlZHJhd1NlcnZpY2UpXG5tLndpdGhBdHRyID0gZnVuY3Rpb24oYXR0ck5hbWUsIGNhbGxiYWNrMSwgY29udGV4dCkge1xuXHRyZXR1cm4gZnVuY3Rpb24oZSkge1xuXHRcdGNhbGxiYWNrMS5jYWxsKGNvbnRleHQgfHwgdGhpcywgYXR0ck5hbWUgaW4gZS5jdXJyZW50VGFyZ2V0ID8gZS5jdXJyZW50VGFyZ2V0W2F0dHJOYW1lXSA6IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpKVxuXHR9XG59XG52YXIgXzI4ID0gY29yZVJlbmRlcmVyKHdpbmRvdylcbm0ucmVuZGVyID0gXzI4LnJlbmRlclxubS5yZWRyYXcgPSByZWRyYXdTZXJ2aWNlLnJlZHJhd1xubS5yZXF1ZXN0ID0gcmVxdWVzdFNlcnZpY2UucmVxdWVzdFxubS5qc29ucCA9IHJlcXVlc3RTZXJ2aWNlLmpzb25wXG5tLnBhcnNlUXVlcnlTdHJpbmcgPSBwYXJzZVF1ZXJ5U3RyaW5nXG5tLmJ1aWxkUXVlcnlTdHJpbmcgPSBidWlsZFF1ZXJ5U3RyaW5nXG5tLnZlcnNpb24gPSBcIjEuMS42XCJcbm0udm5vZGUgPSBWbm9kZVxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBtXG5lbHNlIHdpbmRvdy5tID0gbVxufSgpKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL21pdGhyaWwvbWl0aHJpbC5qcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUpBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBSkE7QUFNQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/*!***********************************************!*\
  !*** ./node_modules/underscore/underscore.js ***!
  \***********************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n//     Underscore.js 1.9.0\n//     http://underscorejs.org\n//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function () {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` (`self`) in the browser, `global`\n  // on the server, or `this` in some virtual machines. We use `self`\n  // instead of `window` for `WebWorker` support.\n  var root = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self.self === self && self || (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global.global === global && global || this || {};\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype,\n      ObjProto = Object.prototype;\n  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push = ArrayProto.push,\n      slice = ArrayProto.slice,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeCreate = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function Ctor() {};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function _(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for their old module API. If we're in\n  // the browser, add `_` as a global object.\n  // (`nodeType` is checked to ensure that `module`\n  // and `exports` are not HTML elements.)\n  if (typeof exports != 'undefined' && !exports.nodeType) {\n    if (typeof module != 'undefined' && !module.nodeType && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.9.0';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function optimizeCb(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1:\n        return function (value) {\n          return func.call(context, value);\n        };\n      // The 2-argument case is omitted because we’re not using it.\n      case 3:\n        return function (value, index, collection) {\n          return func.call(context, value, index, collection);\n        };\n      case 4:\n        return function (accumulator, value, index, collection) {\n          return func.call(context, accumulator, value, index, collection);\n        };\n    }\n    return function () {\n      return func.apply(context, arguments);\n    };\n  };\n\n  var builtinIteratee;\n\n  // An internal function to generate callbacks that can be applied to each\n  // element in a collection, returning the desired result — either `identity`,\n  // an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function cb(value, context, argCount) {\n    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);\n    return _.property(value);\n  };\n\n  // External wrapper for our callback generator. Users may customize\n  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.\n  // This abstraction hides the internal-only argCount argument.\n  _.iteratee = builtinIteratee = function builtinIteratee(value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // Some functions take a variable number of arguments, or a few expected\n  // arguments at the beginning and then a variable number of values to operate\n  // on. This helper accumulates all remaining arguments past the function’s\n  // argument length (or an explicit `startIndex`), into an array that becomes\n  // the last argument. Similar to ES6’s \"rest parameter\".\n  var restArguments = function restArguments(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function () {\n      var length = Math.max(arguments.length - startIndex, 0),\n          rest = Array(length),\n          index = 0;\n      for (; index < length; index++) {\n        rest[index] = arguments[index + startIndex];\n      }\n      switch (startIndex) {\n        case 0:\n          return func.call(this, rest);\n        case 1:\n          return func.call(this, arguments[0], rest);\n        case 2:\n          return func.call(this, arguments[0], arguments[1], rest);\n      }\n      var args = Array(startIndex + 1);\n      for (index = 0; index < startIndex; index++) {\n        args[index] = arguments[index];\n      }\n      args[startIndex] = rest;\n      return func.apply(this, args);\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function baseCreate(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor();\n    Ctor.prototype = null;\n    return result;\n  };\n\n  var shallowProperty = function shallowProperty(key) {\n    return function (obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  var deepGet = function deepGet(obj, path) {\n    var length = path.length;\n    for (var i = 0; i < length; i++) {\n      if (obj == null) return void 0;\n      obj = obj[path[i]];\n    }\n    return length ? obj : void 0;\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object.\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var getLength = shallowProperty('length');\n  var isArrayLike = function isArrayLike(collection) {\n    var length = getLength(collection);\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function (obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function (obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  var createReduce = function createReduce(dir) {\n    // Wrap code that reassigns argument variables in a separate function than\n    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)\n    var reducer = function reducer(obj, iteratee, memo, initial) {\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      if (!initial) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    };\n\n    return function (obj, iteratee, memo, context) {\n      var initial = arguments.length >= 3;\n      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);\n    };\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function (obj, predicate, context) {\n    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;\n    var key = keyFinder(obj, predicate, context);\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function (obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function (value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function (obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function (obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function (obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given item (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function (obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return _.indexOf(obj, item, fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = restArguments(function (obj, path, args) {\n    var contextPath, func;\n    if (_.isFunction(path)) {\n      func = path;\n    } else if (_.isArray(path)) {\n      contextPath = path.slice(0, -1);\n      path = path[path.length - 1];\n    }\n    return _.map(obj, function (context) {\n      var method = func;\n      if (!method) {\n        if (contextPath && contextPath.length) {\n          context = deepGet(context, contextPath);\n        }\n        if (context == null) return void 0;\n        method = context[path];\n      }\n      return method == null ? method : method.apply(context, args);\n    });\n  });\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function (obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function (obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function (obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function (obj, iteratee, context) {\n    var result = -Infinity,\n        lastComputed = -Infinity,\n        value,\n        computed;\n    if (iteratee == null || typeof iteratee == 'number' && _typeof(obj[0]) != 'object' && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function (v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function (obj, iteratee, context) {\n    var result = Infinity,\n        lastComputed = Infinity,\n        value,\n        computed;\n    if (iteratee == null || typeof iteratee == 'number' && _typeof(obj[0]) != 'object' && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function (v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection.\n  _.shuffle = function (obj) {\n    return _.sample(obj, Infinity);\n  };\n\n  // Sample **n** random values from a collection using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function (obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);\n    var length = getLength(sample);\n    n = Math.max(Math.min(n, length), 0);\n    var last = length - 1;\n    for (var index = 0; index < n; index++) {\n      var rand = _.random(index, last);\n      var temp = sample[index];\n      sample[index] = sample[rand];\n      sample[rand] = temp;\n    }\n    return sample.slice(0, n);\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function (obj, iteratee, context) {\n    var index = 0;\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function (value, key, list) {\n      return {\n        value: value,\n        index: index++,\n        criteria: iteratee(value, key, list)\n      };\n    }).sort(function (left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function group(behavior, partition) {\n    return function (obj, iteratee, context) {\n      var result = partition ? [[], []] : {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function (value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function (result, value, key) {\n    if (_.has(result, key)) result[key].push(value);else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function (result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function (result, value, key) {\n    if (_.has(result, key)) result[key]++;else result[key] = 1;\n  });\n\n  var reStrSymbol = /[^\\ud800-\\udfff]|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff]/g;\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function (obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (_.isString(obj)) {\n      // Keep surrogate pair characters together\n      return obj.match(reStrSymbol);\n    }\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function (obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = group(function (result, value, pass) {\n    result[pass ? 0 : 1].push(value);\n  }, true);\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function (array, n, guard) {\n    if (array == null || array.length < 1) return void 0;\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function (array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function (array, n, guard) {\n    if (array == null || array.length < 1) return void 0;\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function (array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function (array) {\n    return _.filter(array, Boolean);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function flatten(input, shallow, strict, output) {\n    output = output || [];\n    var idx = output.length;\n    for (var i = 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        // Flatten current level of array or arguments object.\n        if (shallow) {\n          var j = 0,\n              len = value.length;\n          while (j < len) {\n            output[idx++] = value[j++];\n          }\n        } else {\n          flatten(value, shallow, strict, output);\n          idx = output.length;\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function (array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = restArguments(function (array, otherArrays) {\n    return _.difference(array, otherArrays);\n  });\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // The faster algorithm will not work with an iteratee if the iteratee\n  // is not a one-to-one function, so providing an iteratee will disable\n  // the faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function (array, isSorted, iteratee, context) {\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted && !iteratee) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = restArguments(function (arrays) {\n    return _.uniq(flatten(arrays, true, true));\n  });\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function (array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      var j;\n      for (j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = restArguments(function (array, rest) {\n    rest = flatten(rest, true, true);\n    return _.filter(array, function (value) {\n      return !_.contains(rest, value);\n    });\n  });\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices.\n  _.unzip = function (array) {\n    var length = array && _.max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = restArguments(_.unzip);\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values. Passing by pairs is the reverse of _.pairs.\n  _.object = function (list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions.\n  var createPredicateIndexFinder = function createPredicateIndexFinder(dir) {\n    return function (array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  };\n\n  // Returns the first index on an array-like that passes a predicate test.\n  _.findIndex = createPredicateIndexFinder(1);\n  _.findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function (array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0,\n        high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1;else high = mid;\n    }\n    return low;\n  };\n\n  // Generator function to create the indexOf and lastIndexOf functions.\n  var createIndexFinder = function createIndexFinder(dir, predicateFind, sortedIndex) {\n    return function (array, item, idx) {\n      var i = 0,\n          length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n          i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  };\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function (start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    if (!step) {\n      step = stop < start ? -1 : 1;\n    }\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Chunk a single array into multiple arrays, each containing `count` or fewer\n  // items.\n  _.chunk = function (array, count) {\n    if (count == null || count < 1) return [];\n    var result = [];\n    var i = 0,\n        length = array.length;\n    while (i < length) {\n      result.push(slice.call(array, i, i += count));\n    }\n    return result;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments.\n  var executeBound = function executeBound(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = restArguments(function (func, context, args) {\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var bound = restArguments(function (callArgs) {\n      return executeBound(func, bound, context, this, args.concat(callArgs));\n    });\n    return bound;\n  });\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder by default, allowing any combination of arguments to be\n  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.\n  _.partial = restArguments(function (func, boundArgs) {\n    var placeholder = _.partial.placeholder;\n    var bound = function bound() {\n      var position = 0,\n          length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) {\n        args.push(arguments[position++]);\n      }return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  });\n\n  _.partial.placeholder = _;\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = restArguments(function (obj, keys) {\n    keys = flatten(keys, false, false);\n    var index = keys.length;\n    if (index < 1) throw new Error('bindAll must be passed function names');\n    while (index--) {\n      var key = keys[index];\n      obj[key] = _.bind(obj[key], obj);\n    }\n  });\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function (func, hasher) {\n    var memoize = function memoize(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = restArguments(function (func, wait, args) {\n    return setTimeout(function () {\n      return func.apply(null, args);\n    }, wait);\n  });\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function (func, wait, options) {\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function later() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n\n    var throttled = function throttled() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n\n    throttled.cancel = function () {\n      clearTimeout(timeout);\n      previous = 0;\n      timeout = context = args = null;\n    };\n\n    return throttled;\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function (func, wait, immediate) {\n    var timeout, result;\n\n    var later = function later(context, args) {\n      timeout = null;\n      if (args) result = func.apply(context, args);\n    };\n\n    var debounced = restArguments(function (args) {\n      if (timeout) clearTimeout(timeout);\n      if (immediate) {\n        var callNow = !timeout;\n        timeout = setTimeout(later, wait);\n        if (callNow) result = func.apply(this, args);\n      } else {\n        timeout = _.delay(later, wait, this, args);\n      }\n\n      return result;\n    });\n\n    debounced.cancel = function () {\n      clearTimeout(timeout);\n      timeout = null;\n    };\n\n    return debounced;\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function (func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function (predicate) {\n    return function () {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function () {\n    var args = arguments;\n    var start = args.length - 1;\n    return function () {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) {\n        result = args[i].call(this, result);\n      }return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function (times, func) {\n    return function () {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function (times, func) {\n    var memo;\n    return function () {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  _.restArguments = restArguments;\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  var collectNonEnumProps = function collectNonEnumProps(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  };\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`.\n  _.keys = function (obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) {\n      if (_.has(obj, key)) keys.push(key);\n    } // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function (obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) {\n      keys.push(key);\n    } // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function (obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object.\n  // In contrast to _.map it returns an object.\n  _.mapObject = function (obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = _.keys(obj),\n        length = keys.length,\n        results = {};\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys[index];\n      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  // The opposite of _.object.\n  _.pairs = function (obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function (obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`.\n  _.functions = _.methods = function (obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function createAssigner(keysFunc, defaults) {\n    return function (obj) {\n      var length = arguments.length;\n      if (defaults) obj = Object(obj);\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!defaults || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s).\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test.\n  _.findKey = function (obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj),\n        key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Internal pick helper function to determine if `obj` has key `key`.\n  var keyInObj = function keyInObj(value, key, obj) {\n    return key in obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = restArguments(function (obj, keys) {\n    var result = {},\n        iteratee = keys[0];\n    if (obj == null) return result;\n    if (_.isFunction(iteratee)) {\n      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);\n      keys = _.allKeys(obj);\n    } else {\n      iteratee = keyInObj;\n      keys = flatten(keys, false, false);\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  });\n\n  // Return a copy of the object without the blacklisted properties.\n  _.omit = restArguments(function (obj, keys) {\n    var iteratee = keys[0],\n        context;\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n      if (keys.length > 1) context = keys[1];\n    } else {\n      keys = _.map(flatten(keys, false, false), String);\n      iteratee = function iteratee(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  });\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  _.create = function (prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) _.extendOwn(result, props);\n    return result;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function (obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function (obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function (object, attrs) {\n    var keys = _.keys(attrs),\n        length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq, deepEq;\n  eq = function eq(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // `null` or `undefined` only equal to itself (strict comparison).\n    if (a == null || b == null) return false;\n    // `NaN`s are equivalent, but non-reflexive.\n    if (a !== a) return b !== b;\n    // Exhaust primitive checks\n    var type = typeof a === 'undefined' ? 'undefined' : _typeof(a);\n    if (type !== 'function' && type !== 'object' && (typeof b === 'undefined' ? 'undefined' : _typeof(b)) != 'object') return false;\n    return deepEq(a, b, aStack, bStack);\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  deepEq = function deepEq(a, b, aStack, bStack) {\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN.\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n      case '[object Symbol]':\n        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) != 'object' || (typeof b === 'undefined' ? 'undefined' : _typeof(b)) != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor,\n          bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && 'constructor' in a && 'constructor' in b) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a),\n          key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function (a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function (obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function (obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function (obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function (obj) {\n    var type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function (name) {\n    _['is' + name] = function (obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function (obj) {\n      return _.has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).\n  var nodelist = root.document && root.document.childNodes;\n  if (typeof /./ != 'function' && (typeof Int8Array === 'undefined' ? 'undefined' : _typeof(Int8Array)) != 'object' && typeof nodelist != 'function') {\n    _.isFunction = function (obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function (obj) {\n    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function (obj) {\n    return _.isNumber(obj) && isNaN(obj);\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function (obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function (obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function (obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function (obj, path) {\n    if (!_.isArray(path)) {\n      return obj != null && hasOwnProperty.call(obj, path);\n    }\n    var length = path.length;\n    for (var i = 0; i < length; i++) {\n      var key = path[i];\n      if (obj == null || !hasOwnProperty.call(obj, key)) {\n        return false;\n      }\n      obj = obj[key];\n    }\n    return !!length;\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function () {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function (value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function (value) {\n    return function () {\n      return value;\n    };\n  };\n\n  _.noop = function () {};\n\n  // Creates a function that, when passed an object, will traverse that object’s\n  // properties down the given `path`, specified as an array of keys or indexes.\n  _.property = function (path) {\n    if (!_.isArray(path)) {\n      return shallowProperty(path);\n    }\n    return function (obj) {\n      return deepGet(obj, path);\n    };\n  };\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function (obj) {\n    if (obj == null) {\n      return function () {};\n    }\n    return function (path) {\n      return !_.isArray(path) ? obj[path] : deepGet(obj, path);\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  _.matcher = _.matches = function (attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function (obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function (n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) {\n      accum[i] = iteratee(i);\n    }return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function (min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function () {\n    return new Date().getTime();\n  };\n\n  // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function createEscaper(map) {\n    var escaper = function escaper(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped.\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function (string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // Traverses the children of `obj` along `path`. If a child is a function, it\n  // is invoked with its parent as context. Returns the value of the final\n  // child, or `fallback` if any child is undefined.\n  _.result = function (obj, path, fallback) {\n    if (!_.isArray(path)) path = [path];\n    var length = path.length;\n    if (!length) {\n      return _.isFunction(fallback) ? fallback.call(obj) : fallback;\n    }\n    for (var i = 0; i < length; i++) {\n      var prop = obj == null ? void 0 : obj[path[i]];\n      if (prop === void 0) {\n        prop = fallback;\n        i = length; // Ensure we don't continue iterating.\n      }\n      obj = _.isFunction(prop) ? prop.call(obj) : prop;\n    }\n    return obj;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function (prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /<%=([\\s\\S]+?)%>/g,\n    escape: /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\": \"'\",\n    '\\\\': '\\\\',\n    '\\r': 'r',\n    '\\n': 'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escapeRegExp = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function escapeChar(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function (text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offset.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" + \"print=function(){__p+=__j.call(arguments,'');};\\n\" + source + 'return __p;\\n';\n\n    var render;\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function template(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function (obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var chainResult = function chainResult(instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function (obj) {\n    _.each(_.functions(obj), function (name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function () {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return chainResult(this, func.apply(_, args));\n      };\n    });\n    return _;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function () {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return chainResult(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function (name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function () {\n      return chainResult(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function () {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n  _.prototype.toString = function () {\n    return String(this._wrapped);\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return _;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n})();\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ 3), __webpack_require__(/*! ./../webpack/buildin/module.js */ 13)(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzPzY0YWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gICAgIFVuZGVyc2NvcmUuanMgMS45LjBcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuLy8gICAgIChjKSAyMDA5LTIwMTggSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCAoYHNlbGZgKSBpbiB0aGUgYnJvd3NlciwgYGdsb2JhbGBcbiAgLy8gb24gdGhlIHNlcnZlciwgb3IgYHRoaXNgIGluIHNvbWUgdmlydHVhbCBtYWNoaW5lcy4gV2UgdXNlIGBzZWxmYFxuICAvLyBpbnN0ZWFkIG9mIGB3aW5kb3dgIGZvciBgV2ViV29ya2VyYCBzdXBwb3J0LlxuICB2YXIgcm9vdCA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmIHx8XG4gICAgICAgICAgICB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbC5nbG9iYWwgPT09IGdsb2JhbCAmJiBnbG9iYWwgfHxcbiAgICAgICAgICAgIHRoaXMgfHxcbiAgICAgICAgICAgIHt9O1xuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87XG5cbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIFN5bWJvbFByb3RvID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2wucHJvdG90eXBlIDogbnVsbDtcblxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgdmFyIHB1c2ggPSBBcnJheVByb3RvLnB1c2gsXG4gICAgICBzbGljZSA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgICB0b1N0cmluZyA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhciBuYXRpdmVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIG5hdGl2ZUtleXMgPSBPYmplY3Qua2V5cyxcbiAgICAgIG5hdGl2ZUNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbiAgLy8gTmFrZWQgZnVuY3Rpb24gcmVmZXJlbmNlIGZvciBzdXJyb2dhdGUtcHJvdG90eXBlLXN3YXBwaW5nLlxuICB2YXIgQ3RvciA9IGZ1bmN0aW9uKCl7fTtcblxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXykgcmV0dXJuIG9iajtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpIHJldHVybiBuZXcgXyhvYmopO1xuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZWlyIG9sZCBtb2R1bGUgQVBJLiBJZiB3ZSdyZSBpblxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QuXG4gIC8vIChgbm9kZVR5cGVgIGlzIGNoZWNrZWQgdG8gZW5zdXJlIHRoYXQgYG1vZHVsZWBcbiAgLy8gYW5kIGBleHBvcnRzYCBhcmUgbm90IEhUTUwgZWxlbWVudHMuKVxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgIWV4cG9ydHMubm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgIH1cbiAgICBleHBvcnRzLl8gPSBfO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuXyA9IF87XG4gIH1cblxuICAvLyBDdXJyZW50IHZlcnNpb24uXG4gIF8uVkVSU0lPTiA9ICcxLjkuMCc7XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVmZmljaWVudCAoZm9yIGN1cnJlbnQgZW5naW5lcykgdmVyc2lvblxuICAvLyBvZiB0aGUgcGFzc2VkLWluIGNhbGxiYWNrLCB0byBiZSByZXBlYXRlZGx5IGFwcGxpZWQgaW4gb3RoZXIgVW5kZXJzY29yZVxuICAvLyBmdW5jdGlvbnMuXG4gIHZhciBvcHRpbWl6ZUNiID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSByZXR1cm4gZnVuYztcbiAgICBzd2l0Y2ggKGFyZ0NvdW50ID09IG51bGwgPyAzIDogYXJnQ291bnQpIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIC8vIFRoZSAyLWFyZ3VtZW50IGNhc2UgaXMgb21pdHRlZCBiZWNhdXNlIHdl4oCZcmUgbm90IHVzaW5nIGl0LlxuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGJ1aWx0aW5JdGVyYXRlZTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBjYWxsYmFja3MgdGhhdCBjYW4gYmUgYXBwbGllZCB0byBlYWNoXG4gIC8vIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGRlc2lyZWQgcmVzdWx0IOKAlCBlaXRoZXIgYGlkZW50aXR5YCxcbiAgLy8gYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmIChfLml0ZXJhdGVlICE9PSBidWlsdGluSXRlcmF0ZWUpIHJldHVybiBfLml0ZXJhdGVlKHZhbHVlLCBjb250ZXh0KTtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIF8uaWRlbnRpdHk7XG4gICAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybiBvcHRpbWl6ZUNiKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCk7XG4gICAgaWYgKF8uaXNPYmplY3QodmFsdWUpICYmICFfLmlzQXJyYXkodmFsdWUpKSByZXR1cm4gXy5tYXRjaGVyKHZhbHVlKTtcbiAgICByZXR1cm4gXy5wcm9wZXJ0eSh2YWx1ZSk7XG4gIH07XG5cbiAgLy8gRXh0ZXJuYWwgd3JhcHBlciBmb3Igb3VyIGNhbGxiYWNrIGdlbmVyYXRvci4gVXNlcnMgbWF5IGN1c3RvbWl6ZVxuICAvLyBgXy5pdGVyYXRlZWAgaWYgdGhleSB3YW50IGFkZGl0aW9uYWwgcHJlZGljYXRlL2l0ZXJhdGVlIHNob3J0aGFuZCBzdHlsZXMuXG4gIC8vIFRoaXMgYWJzdHJhY3Rpb24gaGlkZXMgdGhlIGludGVybmFsLW9ubHkgYXJnQ291bnQgYXJndW1lbnQuXG4gIF8uaXRlcmF0ZWUgPSBidWlsdGluSXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBjYih2YWx1ZSwgY29udGV4dCwgSW5maW5pdHkpO1xuICB9O1xuXG4gIC8vIFNvbWUgZnVuY3Rpb25zIHRha2UgYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzLCBvciBhIGZldyBleHBlY3RlZFxuICAvLyBhcmd1bWVudHMgYXQgdGhlIGJlZ2lubmluZyBhbmQgdGhlbiBhIHZhcmlhYmxlIG51bWJlciBvZiB2YWx1ZXMgdG8gb3BlcmF0ZVxuICAvLyBvbi4gVGhpcyBoZWxwZXIgYWNjdW11bGF0ZXMgYWxsIHJlbWFpbmluZyBhcmd1bWVudHMgcGFzdCB0aGUgZnVuY3Rpb27igJlzXG4gIC8vIGFyZ3VtZW50IGxlbmd0aCAob3IgYW4gZXhwbGljaXQgYHN0YXJ0SW5kZXhgKSwgaW50byBhbiBhcnJheSB0aGF0IGJlY29tZXNcbiAgLy8gdGhlIGxhc3QgYXJndW1lbnQuIFNpbWlsYXIgdG8gRVM24oCZcyBcInJlc3QgcGFyYW1ldGVyXCIuXG4gIHZhciByZXN0QXJndW1lbnRzID0gZnVuY3Rpb24oZnVuYywgc3RhcnRJbmRleCkge1xuICAgIHN0YXJ0SW5kZXggPSBzdGFydEluZGV4ID09IG51bGwgPyBmdW5jLmxlbmd0aCAtIDEgOiArc3RhcnRJbmRleDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoYXJndW1lbnRzLmxlbmd0aCAtIHN0YXJ0SW5kZXgsIDApLFxuICAgICAgICAgIHJlc3QgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICByZXN0W2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCArIHN0YXJ0SW5kZXhdO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChzdGFydEluZGV4KSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCByZXN0KTtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3VtZW50c1swXSwgcmVzdCk7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgcmVzdCk7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IEFycmF5KHN0YXJ0SW5kZXggKyAxKTtcbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHN0YXJ0SW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgfVxuICAgICAgYXJnc1tzdGFydEluZGV4XSA9IHJlc3Q7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIGFub3RoZXIuXG4gIHZhciBiYXNlQ3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KHByb3RvdHlwZSkpIHJldHVybiB7fTtcbiAgICBpZiAobmF0aXZlQ3JlYXRlKSByZXR1cm4gbmF0aXZlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBDdG9yO1xuICAgIEN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBzaGFsbG93UHJvcGVydHkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBkZWVwR2V0ID0gZnVuY3Rpb24ob2JqLCBwYXRoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgIG9iaiA9IG9ialtwYXRoW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aCA/IG9iaiA6IHZvaWQgMDtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdC5cbiAgLy8gUmVsYXRlZDogaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGhcbiAgLy8gQXZvaWRzIGEgdmVyeSBuYXN0eSBpT1MgOCBKSVQgYnVnIG9uIEFSTS02NC4gIzIwOTRcbiAgdmFyIE1BWF9BUlJBWV9JTkRFWCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG4gIHZhciBnZXRMZW5ndGggPSBzaGFsbG93UHJvcGVydHkoJ2xlbmd0aCcpO1xuICB2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPj0gMCAmJiBsZW5ndGggPD0gTUFYX0FSUkFZX0lOREVYO1xuICB9O1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgcmF3IG9iamVjdHMgaW4gYWRkaXRpb24gdG8gYXJyYXktbGlrZXMuIFRyZWF0cyBhbGxcbiAgLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cbiAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGksIGxlbmd0aDtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2tleXNbaV1dLCBrZXlzW2ldLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50LlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIHJlc3VsdHNbaW5kZXhdID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDcmVhdGUgYSByZWR1Y2luZyBmdW5jdGlvbiBpdGVyYXRpbmcgbGVmdCBvciByaWdodC5cbiAgdmFyIGNyZWF0ZVJlZHVjZSA9IGZ1bmN0aW9uKGRpcikge1xuICAgIC8vIFdyYXAgY29kZSB0aGF0IHJlYXNzaWducyBhcmd1bWVudCB2YXJpYWJsZXMgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbiB0aGFuXG4gICAgLy8gdGhlIG9uZSB0aGF0IGFjY2Vzc2VzIGBhcmd1bWVudHMubGVuZ3RoYCB0byBhdm9pZCBhIHBlcmYgaGl0LiAoIzE5OTEpXG4gICAgdmFyIHJlZHVjZXIgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBpbml0aWFsKSB7XG4gICAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgIG1lbW8gPSBvYmpba2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBkaXI7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+PSAzO1xuICAgICAgcmV0dXJuIHJlZHVjZXIob2JqLCBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KSwgbWVtbywgaW5pdGlhbCk7XG4gICAgfTtcbiAgfTtcblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleUZpbmRlciA9IGlzQXJyYXlMaWtlKG9iaikgPyBfLmZpbmRJbmRleCA6IF8uZmluZEtleTtcbiAgICB2YXIga2V5ID0ga2V5RmluZGVyKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKG9iaiwgcGF0aCwgYXJncykge1xuICAgIHZhciBjb250ZXh0UGF0aCwgZnVuYztcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHBhdGgpKSB7XG4gICAgICBmdW5jID0gcGF0aDtcbiAgICB9IGVsc2UgaWYgKF8uaXNBcnJheShwYXRoKSkge1xuICAgICAgY29udGV4dFBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICAgIHBhdGggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciBtZXRob2QgPSBmdW5jO1xuICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgaWYgKGNvbnRleHRQYXRoICYmIGNvbnRleHRQYXRoLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnRleHQgPSBkZWVwR2V0KGNvbnRleHQsIGNvbnRleHRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dCA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgICAgICBtZXRob2QgPSBjb250ZXh0W3BhdGhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ldGhvZCA9PSBudWxsID8gbWV0aG9kIDogbWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsIHx8IHR5cGVvZiBpdGVyYXRlZSA9PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqWzBdICE9ICdvYmplY3QnICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2LCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHYsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2O1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eSwgbGFzdENvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCB8fCB0eXBlb2YgaXRlcmF0ZWUgPT0gJ251bWJlcicgJiYgdHlwZW9mIG9ialswXSAhPSAnb2JqZWN0JyAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odiwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2LCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gSW5maW5pdHkgJiYgcmVzdWx0ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHY7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFNodWZmbGUgYSBjb2xsZWN0aW9uLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5zYW1wbGUob2JqLCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24gdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxuICAvLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXG4gIC8vIElmICoqbioqIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnQuXG4gIC8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYG1hcGAuXG4gIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgdmFyIHNhbXBsZSA9IGlzQXJyYXlMaWtlKG9iaikgPyBfLmNsb25lKG9iaikgOiBfLnZhbHVlcyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoc2FtcGxlKTtcbiAgICBuID0gTWF0aC5tYXgoTWF0aC5taW4obiwgbGVuZ3RoKSwgMCk7XG4gICAgdmFyIGxhc3QgPSBsZW5ndGggLSAxO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBuOyBpbmRleCsrKSB7XG4gICAgICB2YXIgcmFuZCA9IF8ucmFuZG9tKGluZGV4LCBsYXN0KTtcbiAgICAgIHZhciB0ZW1wID0gc2FtcGxlW2luZGV4XTtcbiAgICAgIHNhbXBsZVtpbmRleF0gPSBzYW1wbGVbcmFuZF07XG4gICAgICBzYW1wbGVbcmFuZF0gPSB0ZW1wO1xuICAgIH1cbiAgICByZXR1cm4gc2FtcGxlLnNsaWNlKDAsIG4pO1xuICB9O1xuXG4gIC8vIFNvcnQgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiBwcm9kdWNlZCBieSBhbiBpdGVyYXRlZS5cbiAgXy5zb3J0QnkgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGxpc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgaW5kZXg6IGluZGV4KyssXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwga2V5LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XG4gICAgfSksICd2YWx1ZScpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgZm9yIGFnZ3JlZ2F0ZSBcImdyb3VwIGJ5XCIgb3BlcmF0aW9ucy5cbiAgdmFyIGdyb3VwID0gZnVuY3Rpb24oYmVoYXZpb3IsIHBhcnRpdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gcGFydGl0aW9uID8gW1tdLCBbXV0gOiB7fTtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwgdmFsdWUsIGtleSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTsgZWxzZSByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gIH0pO1xuXG4gIC8vIEluZGV4ZXMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiwgc2ltaWxhciB0byBgZ3JvdXBCeWAsIGJ1dCBmb3JcbiAgLy8gd2hlbiB5b3Uga25vdyB0aGF0IHlvdXIgaW5kZXggdmFsdWVzIHdpbGwgYmUgdW5pcXVlLlxuICBfLmluZGV4QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9KTtcblxuICAvLyBDb3VudHMgaW5zdGFuY2VzIG9mIGFuIG9iamVjdCB0aGF0IGdyb3VwIGJ5IGEgY2VydGFpbiBjcml0ZXJpb24uIFBhc3NcbiAgLy8gZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBjb3VudCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gIC8vIGNyaXRlcmlvbi5cbiAgXy5jb3VudEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0rKzsgZWxzZSByZXN1bHRba2V5XSA9IDE7XG4gIH0pO1xuXG4gIHZhciByZVN0clN5bWJvbCA9IC9bXlxcdWQ4MDAtXFx1ZGZmZl18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXXxbXFx1ZDgwMC1cXHVkZmZmXS9nO1xuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoXy5pc1N0cmluZyhvYmopKSB7XG4gICAgICAvLyBLZWVwIHN1cnJvZ2F0ZSBwYWlyIGNoYXJhY3RlcnMgdG9nZXRoZXJcbiAgICAgIHJldHVybiBvYmoubWF0Y2gocmVTdHJTeW1ib2wpO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBwYXNzKSB7XG4gICAgcmVzdWx0W3Bhc3MgPyAwIDogMV0ucHVzaCh2YWx1ZSk7XG4gIH0sIHRydWUpO1xuXG4gIC8vIEFycmF5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGZpcnN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgaGVhZGAgYW5kIGB0YWtlYC4gVGhlICoqZ3VhcmQqKiBjaGVja1xuICAvLyBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8uZmlyc3QgPSBfLmhlYWQgPSBfLnRha2UgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCB8fCBhcnJheS5sZW5ndGggPCAxKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsIHx8IGFycmF5Lmxlbmd0aCA8IDEpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBfLnJlc3QoYXJyYXksIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIG4pKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBCb29sZWFuKTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIHN0cmljdCwgb3V0cHV0KSB7XG4gICAgb3V0cHV0ID0gb3V0cHV0IHx8IFtdO1xuICAgIHZhciBpZHggPSBvdXRwdXQubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoaW5wdXQpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgLy8gRmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3QuXG4gICAgICAgIGlmIChzaGFsbG93KSB7XG4gICAgICAgICAgdmFyIGogPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGogPCBsZW4pIG91dHB1dFtpZHgrK10gPSB2YWx1ZVtqKytdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCwgb3V0cHV0KTtcbiAgICAgICAgICBpZHggPSBvdXRwdXQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgZmFsc2UpO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGFycmF5LCBvdGhlckFycmF5cykge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIG90aGVyQXJyYXlzKTtcbiAgfSk7XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBUaGUgZmFzdGVyIGFsZ29yaXRobSB3aWxsIG5vdCB3b3JrIHdpdGggYW4gaXRlcmF0ZWUgaWYgdGhlIGl0ZXJhdGVlXG4gIC8vIGlzIG5vdCBhIG9uZS10by1vbmUgZnVuY3Rpb24sIHNvIHByb3ZpZGluZyBhbiBpdGVyYXRlZSB3aWxsIGRpc2FibGVcbiAgLy8gdGhlIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuXG4gIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24oYXJyYXksIGlzU29ydGVkLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmICghXy5pc0Jvb2xlYW4oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0ZWU7XG4gICAgICBpdGVyYXRlZSA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhdGVlICE9IG51bGwpIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldLFxuICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaSwgYXJyYXkpIDogdmFsdWU7XG4gICAgICBpZiAoaXNTb3J0ZWQgJiYgIWl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghaSB8fCBzZWVuICE9PSBjb21wdXRlZCkgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhzZWVuLCBjb21wdXRlZCkpIHtcbiAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghXy5jb250YWlucyhyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihhcnJheXMpIHtcbiAgICByZXR1cm4gXy51bmlxKGZsYXR0ZW4oYXJyYXlzLCB0cnVlLCB0cnVlKSk7XG4gIH0pO1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgXy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgIGlmIChfLmNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpIGNvbnRpbnVlO1xuICAgICAgdmFyIGo7XG4gICAgICBmb3IgKGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oYXJyYXksIHJlc3QpIHtcbiAgICByZXN0ID0gZmxhdHRlbihyZXN0LCB0cnVlLCB0cnVlKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIENvbXBsZW1lbnQgb2YgXy56aXAuIFVuemlwIGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIGFuZCBncm91cHNcbiAgLy8gZWFjaCBhcnJheSdzIGVsZW1lbnRzIG9uIHNoYXJlZCBpbmRpY2VzLlxuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gcmVzdEFyZ3VtZW50cyhfLnVuemlwKTtcblxuICAvLyBDb252ZXJ0cyBsaXN0cyBpbnRvIG9iamVjdHMuIFBhc3MgZWl0aGVyIGEgc2luZ2xlIGFycmF5IG9mIGBba2V5LCB2YWx1ZV1gXG4gIC8vIHBhaXJzLCBvciB0d28gcGFyYWxsZWwgYXJyYXlzIG9mIHRoZSBzYW1lIGxlbmd0aCAtLSBvbmUgb2Yga2V5cywgYW5kIG9uZSBvZlxuICAvLyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMuIFBhc3NpbmcgYnkgcGFpcnMgaXMgdGhlIHJldmVyc2Ugb2YgXy5wYWlycy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyID0gZnVuY3Rpb24oZGlyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIHZhciBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdC5cbiAgXy5maW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGluZGV4T2YgYW5kIGxhc3RJbmRleE9mIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUluZGV4RmluZGVyID0gZnVuY3Rpb24oZGlyLCBwcmVkaWNhdGVGaW5kLCBzb3J0ZWRJbmRleCkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgaXRlbSwgaWR4KSB7XG4gICAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICBpZiAodHlwZW9mIGlkeCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgIGkgPSBpZHggPj0gMCA/IGlkeCA6IE1hdGgubWF4KGlkeCArIGxlbmd0aCwgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgXy5pc05hTik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksXG4gIC8vIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxuICBfLmluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigxLCBfLmZpbmRJbmRleCwgXy5zb3J0ZWRJbmRleCk7XG4gIF8ubGFzdEluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigtMSwgXy5maW5kTGFzdEluZGV4KTtcblxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuXG4gIF8ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChzdG9wID09IG51bGwpIHtcbiAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBpZiAoIXN0ZXApIHtcbiAgICAgIHN0ZXAgPSBzdG9wIDwgc3RhcnQgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgcmFuZ2UgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKywgc3RhcnQgKz0gc3RlcCkge1xuICAgICAgcmFuZ2VbaWR4XSA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvLyBDaHVuayBhIHNpbmdsZSBhcnJheSBpbnRvIG11bHRpcGxlIGFycmF5cywgZWFjaCBjb250YWluaW5nIGBjb3VudGAgb3IgZmV3ZXJcbiAgLy8gaXRlbXMuXG4gIF8uY2h1bmsgPSBmdW5jdGlvbihhcnJheSwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPT0gbnVsbCB8fCBjb3VudCA8IDEpIHJldHVybiBbXTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHNsaWNlLmNhbGwoYXJyYXksIGksIGkgKz0gY291bnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIERldGVybWluZXMgd2hldGhlciB0byBleGVjdXRlIGEgZnVuY3Rpb24gYXMgYSBjb25zdHJ1Y3RvclxuICAvLyBvciBhIG5vcm1hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gIHZhciBleGVjdXRlQm91bmQgPSBmdW5jdGlvbihzb3VyY2VGdW5jLCBib3VuZEZ1bmMsIGNvbnRleHQsIGNhbGxpbmdDb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCEoY2FsbGluZ0NvbnRleHQgaW5zdGFuY2VvZiBib3VuZEZ1bmMpKSByZXR1cm4gc291cmNlRnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB2YXIgc2VsZiA9IGJhc2VDcmVhdGUoc291cmNlRnVuYy5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBzb3VyY2VGdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGlmIChfLmlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ3MpIHtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGJvdW5kID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihjYWxsQXJncykge1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgY29udGV4dCwgdGhpcywgYXJncy5jb25jYXQoY2FsbEFyZ3MpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH0pO1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyIGJ5IGRlZmF1bHQsIGFsbG93aW5nIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMgdG8gYmVcbiAgLy8gcHJlLWZpbGxlZC4gU2V0IGBfLnBhcnRpYWwucGxhY2Vob2xkZXJgIGZvciBhIGN1c3RvbSBwbGFjZWhvbGRlciBhcmd1bWVudC5cbiAgXy5wYXJ0aWFsID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihmdW5jLCBib3VuZEFyZ3MpIHtcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSBfLnBhcnRpYWwucGxhY2Vob2xkZXI7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwLCBsZW5ndGggPSBib3VuZEFyZ3MubGVuZ3RoO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYm91bmRBcmdzW2ldID09PSBwbGFjZWhvbGRlciA/IGFyZ3VtZW50c1twb3NpdGlvbisrXSA6IGJvdW5kQXJnc1tpXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGFyZ3VtZW50cy5sZW5ndGgpIGFyZ3MucHVzaChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgdGhpcywgdGhpcywgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH0pO1xuXG4gIF8ucGFydGlhbC5wbGFjZWhvbGRlciA9IF87XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24ob2JqLCBrZXlzKSB7XG4gICAga2V5cyA9IGZsYXR0ZW4oa2V5cywgZmFsc2UsIGZhbHNlKTtcbiAgICB2YXIgaW5kZXggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAoaW5kZXggPCAxKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgb2JqW2tleV0gPSBfLmJpbmQob2JqW2tleV0sIG9iaik7XG4gICAgfVxuICB9KTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfSk7XG5cbiAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzXG4gIC8vIGNsZWFyZWQuXG4gIF8uZGVmZXIgPSBfLnBhcnRpYWwoXy5kZWxheSwgXywgMSk7XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXG4gIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxuICAvLyBhcyBtdWNoIGFzIGl0IGNhbiwgd2l0aG91dCBldmVyIGdvaW5nIG1vcmUgdGhhbiBvbmNlIHBlciBgd2FpdGAgZHVyYXRpb247XG4gIC8vIGJ1dCBpZiB5b3UnZCBsaWtlIHRvIGRpc2FibGUgdGhlIGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlLCBwYXNzXG4gIC8vIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxuICBfLnRocm90dGxlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgIHZhciB0aW1lb3V0LCBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIHRocm90dGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vdyA9IF8ubm93KCk7XG4gICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHByZXZpb3VzID0gbm93O1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHRocm90dGxlZC5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHByZXZpb3VzID0gMDtcbiAgICAgIHRpbWVvdXQgPSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiB0aHJvdHRsZWQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgaWYgKGFyZ3MpIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfTtcblxuICAgIHZhciBkZWJvdW5jZWQgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIGlmICh0aW1lb3V0KSBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICAgIHZhciBjYWxsTm93ID0gIXRpbWVvdXQ7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgICAgaWYgKGNhbGxOb3cpIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gXy5kZWxheShsYXRlciwgd2FpdCwgdGhpcywgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICBkZWJvdW5jZWQuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICBfLndyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIF8ucGFydGlhbCh3cmFwcGVyLCBmdW5jKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBwYXNzZWQtaW4gcHJlZGljYXRlLlxuICBfLm5lZ2F0ZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgc3RhcnQgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSBzdGFydDtcbiAgICAgIHZhciByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd2hpbGUgKGktLSkgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIG9uIGFuZCBhZnRlciB0aGUgTnRoIGNhbGwuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHVwIHRvIChidXQgbm90IGluY2x1ZGluZykgdGhlIE50aCBjYWxsLlxuICBfLmJlZm9yZSA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgdmFyIG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPiAwKSB7XG4gICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAodGltZXMgPD0gMSkgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICBfLm9uY2UgPSBfLnBhcnRpYWwoXy5iZWZvcmUsIDIpO1xuXG4gIF8ucmVzdEFyZ3VtZW50cyA9IHJlc3RBcmd1bWVudHM7XG5cbiAgLy8gT2JqZWN0IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gS2V5cyBpbiBJRSA8IDkgdGhhdCB3b24ndCBiZSBpdGVyYXRlZCBieSBgZm9yIGtleSBpbiAuLi5gIGFuZCB0aHVzIG1pc3NlZC5cbiAgdmFyIGhhc0VudW1CdWcgPSAhe3RvU3RyaW5nOiBudWxsfS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKTtcbiAgdmFyIG5vbkVudW1lcmFibGVQcm9wcyA9IFsndmFsdWVPZicsICdpc1Byb3RvdHlwZU9mJywgJ3RvU3RyaW5nJyxcbiAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLCAnaGFzT3duUHJvcGVydHknLCAndG9Mb2NhbGVTdHJpbmcnXTtcblxuICB2YXIgY29sbGVjdE5vbkVudW1Qcm9wcyA9IGZ1bmN0aW9uKG9iaiwga2V5cykge1xuICAgIHZhciBub25FbnVtSWR4ID0gbm9uRW51bWVyYWJsZVByb3BzLmxlbmd0aDtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBvYmouY29uc3RydWN0b3I7XG4gICAgdmFyIHByb3RvID0gXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgfHwgT2JqUHJvdG87XG5cbiAgICAvLyBDb25zdHJ1Y3RvciBpcyBhIHNwZWNpYWwgY2FzZS5cbiAgICB2YXIgcHJvcCA9ICdjb25zdHJ1Y3Rvcic7XG4gICAgaWYgKF8uaGFzKG9iaiwgcHJvcCkgJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIGtleXMucHVzaChwcm9wKTtcblxuICAgIHdoaWxlIChub25FbnVtSWR4LS0pIHtcbiAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbm9uRW51bUlkeF07XG4gICAgICBpZiAocHJvcCBpbiBvYmogJiYgb2JqW3Byb3BdICE9PSBwcm90b1twcm9wXSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkge1xuICAgICAgICBrZXlzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYC5cbiAgXy5rZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICBpZiAobmF0aXZlS2V5cykgcmV0dXJuIG5hdGl2ZUtleXMob2JqKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIGFsbCB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LlxuICBfLmFsbEtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICBfLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIG9iamVjdC5cbiAgLy8gSW4gY29udHJhc3QgdG8gXy5tYXAgaXQgcmV0dXJucyBhbiBvYmplY3QuXG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICByZXN1bHRzID0ge307XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICAvLyBUaGUgb3Bwb3NpdGUgb2YgXy5vYmplY3QuXG4gIF8ucGFpcnMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgcGFpcnMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhaXJzW2ldID0gW2tleXNbaV0sIG9ialtrZXlzW2ldXV07XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbiAgfTtcblxuICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gIF8uaW52ZXJ0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtvYmpba2V5c1tpXV1dID0ga2V5c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXG4gIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgLlxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoZGVmYXVsdHMpIG9iaiA9IE9iamVjdChvYmopO1xuICAgICAgaWYgKGxlbmd0aCA8IDIgfHwgb2JqID09IG51bGwpIHJldHVybiBvYmo7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdLFxuICAgICAgICAgICAga2V5cyA9IGtleXNGdW5jKHNvdXJjZSksXG4gICAgICAgICAgICBsID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKCFkZWZhdWx0cyB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzKTtcblxuICAvLyBBc3NpZ25zIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBvd24gcHJvcGVydGllcyBpbiB0aGUgcGFzc2VkLWluIG9iamVjdChzKS5cbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdC5cbiAgXy5maW5kS2V5ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaiksIGtleTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2tleV0sIGtleSwgb2JqKSkgcmV0dXJuIGtleTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgcGljayBoZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIGBvYmpgIGhhcyBrZXkgYGtleWAuXG4gIHZhciBrZXlJbk9iaiA9IGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgIHJldHVybiBrZXkgaW4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24ob2JqLCBrZXlzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBpdGVyYXRlZSA9IGtleXNbMF07XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPiAxKSBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGtleXNbMV0pO1xuICAgICAga2V5cyA9IF8uYWxsS2V5cyhvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGtleUluT2JqO1xuICAgICAga2V5cyA9IGZsYXR0ZW4oa2V5cywgZmFsc2UsIGZhbHNlKTtcbiAgICAgIG9iaiA9IE9iamVjdChvYmopO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGlmIChpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmopKSByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5vbWl0ID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihvYmosIGtleXMpIHtcbiAgICB2YXIgaXRlcmF0ZWUgPSBrZXlzWzBdLCBjb250ZXh0O1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpdGVyYXRlZSA9IF8ubmVnYXRlKGl0ZXJhdGVlKTtcbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDEpIGNvbnRleHQgPSBrZXlzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gXy5tYXAoZmxhdHRlbihrZXlzLCBmYWxzZSwgZmFsc2UpLCBTdHJpbmcpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJldHVybiAhXy5jb250YWlucyhrZXlzLCBrZXkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF8ucGljayhvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgfSk7XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cywgdHJ1ZSk7XG5cbiAgLy8gQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBwcm90b3R5cGUgb2JqZWN0LlxuICAvLyBJZiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgYXJlIHByb3ZpZGVkIHRoZW4gdGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuICAvLyBjcmVhdGVkIG9iamVjdC5cbiAgXy5jcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUsIHByb3BzKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICBpZiAocHJvcHMpIF8uZXh0ZW5kT3duKHJlc3VsdCwgcHJvcHMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmlzTWF0Y2ggPSBmdW5jdGlvbihvYmplY3QsIGF0dHJzKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMoYXR0cnMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAhbGVuZ3RoO1xuICAgIHZhciBvYmogPSBPYmplY3Qob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgdmFyIGVxLCBkZWVwRXE7XG4gIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAvLyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgb25seSBlcXVhbCB0byBpdHNlbGYgKHN0cmljdCBjb21wYXJpc29uKS5cbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgaWYgKGEgIT09IGEpIHJldHVybiBiICE9PSBiO1xuICAgIC8vIEV4aGF1c3QgcHJpbWl0aXZlIGNoZWNrc1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGE7XG4gICAgaWYgKHR5cGUgIT09ICdmdW5jdGlvbicgJiYgdHlwZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gZGVlcEVxKGEsIGIsIGFTdGFjaywgYlN0YWNrKTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICBkZWVwRXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU4uXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgICAgY2FzZSAnW29iamVjdCBTeW1ib2xdJzpcbiAgICAgICAgcmV0dXJuIFN5bWJvbFByb3RvLnZhbHVlT2YuY2FsbChhKSA9PT0gU3ltYm9sUHJvdG8udmFsdWVPZi5jYWxsKGIpO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvciwgaXNNYXAsIGlzV2Vha01hcCwgaXNTZXQsIGlzV2Vha1NldC5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InLCAnU3ltYm9sJywgJ01hcCcsICdXZWFrTWFwJywgJ1NldCcsICdXZWFrU2V0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgJyArIG5hbWUgKyAnXSc7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRGVmaW5lIGEgZmFsbGJhY2sgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIGluIGJyb3dzZXJzIChhaGVtLCBJRSA8IDkpLCB3aGVyZVxuICAvLyB0aGVyZSBpc24ndCBhbnkgaW5zcGVjdGFibGUgXCJBcmd1bWVudHNcIiB0eXBlLlxuICBpZiAoIV8uaXNBcmd1bWVudHMoYXJndW1lbnRzKSkge1xuICAgIF8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmhhcyhvYmosICdjYWxsZWUnKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLiBXb3JrIGFyb3VuZCBzb21lIHR5cGVvZiBidWdzIGluIG9sZCB2OCxcbiAgLy8gSUUgMTEgKCMxNjIxKSwgU2FmYXJpIDggKCMxOTI5KSwgYW5kIFBoYW50b21KUyAoIzIyMzYpLlxuICB2YXIgbm9kZWxpc3QgPSByb290LmRvY3VtZW50ICYmIHJvb3QuZG9jdW1lbnQuY2hpbGROb2RlcztcbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnICYmIHR5cGVvZiBub2RlbGlzdCAhPSAnZnVuY3Rpb24nKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gIV8uaXNTeW1ib2wob2JqKSAmJiBpc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xuICB9O1xuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD9cbiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgaXNOYU4ob2JqKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwgcGF0aCkge1xuICAgIGlmICghXy5pc0FycmF5KHBhdGgpKSB7XG4gICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHBhdGgpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHBhdGhbaV07XG4gICAgICBpZiAob2JqID09IG51bGwgfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iaiA9IG9ialtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gISFsZW5ndGg7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRlZXMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvLyBQcmVkaWNhdGUtZ2VuZXJhdGluZyBmdW5jdGlvbnMuIE9mdGVuIHVzZWZ1bCBvdXRzaWRlIG9mIFVuZGVyc2NvcmUuXG4gIF8uY29uc3RhbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9O1xuXG4gIF8ubm9vcCA9IGZ1bmN0aW9uKCl7fTtcblxuICAvLyBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBwYXNzZWQgYW4gb2JqZWN0LCB3aWxsIHRyYXZlcnNlIHRoYXQgb2JqZWN04oCZc1xuICAvLyBwcm9wZXJ0aWVzIGRvd24gdGhlIGdpdmVuIGBwYXRoYCwgc3BlY2lmaWVkIGFzIGFuIGFycmF5IG9mIGtleXMgb3IgaW5kZXhlcy5cbiAgXy5wcm9wZXJ0eSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBpZiAoIV8uaXNBcnJheShwYXRoKSkge1xuICAgICAgcmV0dXJuIHNoYWxsb3dQcm9wZXJ0eShwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIGRlZXBHZXQob2JqLCBwYXRoKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKXt9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgcmV0dXJuICFfLmlzQXJyYXkocGF0aCkgPyBvYmpbcGF0aF0gOiBkZWVwR2V0KG9iaiwgcGF0aCk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2ZcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgLy8gTGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciBlc2NhcGluZy5cbiAgdmFyIGVzY2FwZU1hcCA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmI3gyNzsnLFxuICAgICdgJzogJyYjeDYwOydcbiAgfTtcbiAgdmFyIHVuZXNjYXBlTWFwID0gXy5pbnZlcnQoZXNjYXBlTWFwKTtcblxuICAvLyBGdW5jdGlvbnMgZm9yIGVzY2FwaW5nIGFuZCB1bmVzY2FwaW5nIHN0cmluZ3MgdG8vZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG4gIHZhciBjcmVhdGVFc2NhcGVyID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGVzY2FwZXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hcFttYXRjaF07XG4gICAgfTtcbiAgICAvLyBSZWdleGVzIGZvciBpZGVudGlmeWluZyBhIGtleSB0aGF0IG5lZWRzIHRvIGJlIGVzY2FwZWQuXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gVHJhdmVyc2VzIHRoZSBjaGlsZHJlbiBvZiBgb2JqYCBhbG9uZyBgcGF0aGAuIElmIGEgY2hpbGQgaXMgYSBmdW5jdGlvbiwgaXRcbiAgLy8gaXMgaW52b2tlZCB3aXRoIGl0cyBwYXJlbnQgYXMgY29udGV4dC4gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZpbmFsXG4gIC8vIGNoaWxkLCBvciBgZmFsbGJhY2tgIGlmIGFueSBjaGlsZCBpcyB1bmRlZmluZWQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqLCBwYXRoLCBmYWxsYmFjaykge1xuICAgIGlmICghXy5pc0FycmF5KHBhdGgpKSBwYXRoID0gW3BhdGhdO1xuICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgcmV0dXJuIF8uaXNGdW5jdGlvbihmYWxsYmFjaykgPyBmYWxsYmFjay5jYWxsKG9iaikgOiBmYWxsYmFjaztcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9ialtwYXRoW2ldXTtcbiAgICAgIGlmIChwcm9wID09PSB2b2lkIDApIHtcbiAgICAgICAgcHJvcCA9IGZhbGxiYWNrO1xuICAgICAgICBpID0gbGVuZ3RoOyAvLyBFbnN1cmUgd2UgZG9uJ3QgY29udGludWUgaXRlcmF0aW5nLlxuICAgICAgfVxuICAgICAgb2JqID0gXy5pc0Z1bmN0aW9uKHByb3ApID8gcHJvcC5jYWxsKG9iaikgOiBwcm9wO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGludGVnZXIgaWQgKHVuaXF1ZSB3aXRoaW4gdGhlIGVudGlyZSBjbGllbnQgc2Vzc2lvbikuXG4gIC8vIFVzZWZ1bCBmb3IgdGVtcG9yYXJ5IERPTSBpZHMuXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuICBfLnVuaXF1ZUlkID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIGlkID0gKytpZENvdW50ZXIgKyAnJztcbiAgICByZXR1cm4gcHJlZml4ID8gcHJlZml4ICsgaWQgOiBpZDtcbiAgfTtcblxuICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMsIGNoYW5nZSB0aGVcbiAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgZXZhbHVhdGU6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGU6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZTogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgJ1xccic6ICdyJyxcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlUmVnRXhwID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XG4gIH07XG5cbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgLy8gTkI6IGBvbGRTZXR0aW5nc2Agb25seSBleGlzdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgc2V0dGluZ3MsIG9sZFNldHRpbmdzKSB7XG4gICAgaWYgKCFzZXR0aW5ncyAmJiBvbGRTZXR0aW5ncykgc2V0dGluZ3MgPSBvbGRTZXR0aW5ncztcbiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXG4gICAgdmFyIG1hdGNoZXIgPSBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UoZXNjYXBlUmVnRXhwLCBlc2NhcGVDaGFyKTtcbiAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgaW50ZXJwb2xhdGUgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuICAgICAgfVxuXG4gICAgICAvLyBBZG9iZSBWTXMgbmVlZCB0aGUgbWF0Y2ggcmV0dXJuZWQgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBvZmZzZXQuXG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcblxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG4gICAgICBzb3VyY2UgKyAncmV0dXJuIF9fcDtcXG4nO1xuXG4gICAgdmFyIHJlbmRlcjtcbiAgICB0cnkge1xuICAgICAgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICAgIHZhciBhcmd1bWVudCA9IHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonO1xuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgYXJndW1lbnQgKyAnKXtcXG4nICsgc291cmNlICsgJ30nO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9O1xuXG4gIC8vIEFkZCBhIFwiY2hhaW5cIiBmdW5jdGlvbi4gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGluc3RhbmNlID0gXyhvYmopO1xuICAgIGluc3RhbmNlLl9jaGFpbiA9IHRydWU7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIC8vIE9PUFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciBjaGFpblJlc3VsdCA9IGZ1bmN0aW9uKGluc3RhbmNlLCBvYmopIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX2NoYWluID8gXyhvYmopLmNoYWluKCkgOiBvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHlvdXIgb3duIGN1c3RvbSBmdW5jdGlvbnMgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm1peGluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXy5lYWNoKF8uZnVuY3Rpb25zKG9iaiksIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gX1tuYW1lXSA9IG9ialtuYW1lXTtcbiAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW3RoaXMuX3dyYXBwZWRdO1xuICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBjaGFpblJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIF87XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiBjaGFpblJlc3VsdCh0aGlzLCBvYmopO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFkZCBhbGwgYWNjZXNzb3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydjb25jYXQnLCAnam9pbicsICdzbGljZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjaGFpblJlc3VsdCh0aGlzLCBtZXRob2QuYXBwbHkodGhpcy5fd3JhcHBlZCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuXG4gIF8ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gUHJvdmlkZSB1bndyYXBwaW5nIHByb3h5IGZvciBzb21lIG1ldGhvZHMgdXNlZCBpbiBlbmdpbmUgb3BlcmF0aW9uc1xuICAvLyBzdWNoIGFzIGFyaXRobWV0aWMgYW5kIEpTT04gc3RyaW5naWZpY2F0aW9uLlxuICBfLnByb3RvdHlwZS52YWx1ZU9mID0gXy5wcm90b3R5cGUudG9KU09OID0gXy5wcm90b3R5cGUudmFsdWU7XG5cbiAgXy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gU3RyaW5nKHRoaXMuX3dyYXBwZWQpO1xuICB9O1xuXG4gIC8vIEFNRCByZWdpc3RyYXRpb24gaGFwcGVucyBhdCB0aGUgZW5kIGZvciBjb21wYXRpYmlsaXR5IHdpdGggQU1EIGxvYWRlcnNcbiAgLy8gdGhhdCBtYXkgbm90IGVuZm9yY2UgbmV4dC10dXJuIHNlbWFudGljcyBvbiBtb2R1bGVzLiBFdmVuIHRob3VnaCBnZW5lcmFsXG4gIC8vIHByYWN0aWNlIGZvciBBTUQgcmVnaXN0cmF0aW9uIGlzIHRvIGJlIGFub255bW91cywgdW5kZXJzY29yZSByZWdpc3RlcnNcbiAgLy8gYXMgYSBuYW1lZCBtb2R1bGUgYmVjYXVzZSwgbGlrZSBqUXVlcnksIGl0IGlzIGEgYmFzZSBsaWJyYXJ5IHRoYXQgaXNcbiAgLy8gcG9wdWxhciBlbm91Z2ggdG8gYmUgYnVuZGxlZCBpbiBhIHRoaXJkIHBhcnR5IGxpYiwgYnV0IG5vdCBiZSBwYXJ0IG9mXG4gIC8vIGFuIEFNRCBsb2FkIHJlcXVlc3QuIFRob3NlIGNhc2VzIGNvdWxkIGdlbmVyYXRlIGFuIGVycm9yIHdoZW4gYW5cbiAgLy8gYW5vbnltb3VzIGRlZmluZSgpIGlzIGNhbGxlZCBvdXRzaWRlIG9mIGEgbG9hZGVyIHJlcXVlc3QuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59KCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanMiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQkE7QUFDQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/*!*******************!*\
  !*** ./src/fn.js ***!
  \*******************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _arguments = arguments;\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar optional = function optional(value) {\n  var isPresent = function isPresent() {\n    return !!value;\n  };\n  var map = function map(fn) {\n    return isPresent() ? optional(fn(value)) : optional(null);\n  };\n  var ifPresent = function ifPresent(fn) {\n    return isPresent() ? fn(value) : null;\n  };\n  return {\n    isPresent: isPresent,\n    map: map,\n    ifPresent: ifPresent\n  };\n};\n\nvar plus = function plus(a, b) {\n  return a + b;\n};\n\nvar range = function range(startInclusive, endExclusive) {\n  var result = [];\n  for (var i = startInclusive; i < endExclusive; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nvar nFrom = function nFrom(start, number) {\n  return range(start, start + number);\n};\n\nvar interval = function interval(startInclusive, endInclusive) {\n  return range(startInclusive, endInclusive + 1);\n};\n\nvar zipWith = function zipWith(fn) {\n  for (var _len = arguments.length, arrs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    arrs[_key - 1] = arguments[_key];\n  }\n\n  _arguments.l;\n  return range(0, Math.min.apply(Math, _toConsumableArray(arrs.map(function (arr) {\n    return arr.length;\n  })))).map(function (i) {\n    return fn.apply(undefined, _toConsumableArray(arrs.map(function (arr) {\n      return arr[i];\n    })));\n  });\n};\n\nvar tail = function tail(arr) {\n  return arr[arr.length - 1];\n};\n\nvar head = function head(arr) {\n  return arr[0];\n};\n\nvar isEmpty = function isEmpty(arr) {\n  return arr.length === 0;\n};\n\nvar withoutLast = function withoutLast() {\n  var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  return arr.length > 1 ? arr.slice(0, arr.length - 1) : [];\n};\n\nvar flatten = function flatten(arr) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n\n  var merged = [];\n  for (var step = 0; step < depth; step++) {\n    if (merged.length === 0) {\n      merged = arr.slice(0);\n    }\n    var l1 = merged.length;\n    merged = [].concat.apply([], merged);\n    var l2 = merged.length;\n    if (l1 === l2) break;\n  }\n  return merged;\n};\n\nvar foldLeft = function foldLeft(arr, start, fn) {\n  return arr.reduce(fn, start);\n};\nvar foldRight = function foldRight(arr, start, fn) {\n  return arr.reverse().reduce(fn, start);\n};\n\nvar and = function and(acc, curr) {\n  return acc && curr;\n};\nvar not = function not(fn) {\n  return !fn;\n};\n\nvar id = function id(n) {\n  return n;\n};\nvar succ = function succ(n) {\n  return n + 1;\n};\nvar pred = function pred(n) {\n  return n - 1;\n};\n\nvar directions = [id, succ, pred];\n\nvar contains = function contains(arr, e) {\n  return arr.indexOf(e) >= 0;\n};\n\nvar without = function without(arr1, arr2) {\n  return arr1.filter(function (e) {\n    return !contains(arr2, e);\n  });\n};\n\nvar unique = function unique(arr) {\n  var r = [];\n  arr.forEach(function (e) {\n    return !contains(r, e) ? r.push(e) : 0;\n  });\n  return r;\n};\n\nvar reverse = function reverse(arr) {\n  return range(0, arr.length).map(function (i) {\n    return arr.length - 1 - i;\n  }).map(function (i) {\n    return arr[i];\n  });\n};\n\nexports.default = {\n  flatten: flatten,\n  foldLeft: foldLeft,\n  foldRight: foldRight,\n  and: and,\n  withoutLast: withoutLast,\n  head: head,\n  tail: tail,\n  nFrom: nFrom,\n  range: range,\n  interval: interval,\n  optional: optional,\n  plus: plus,\n  id: id,\n  succ: succ,\n  pred: pred,\n  zipWith: zipWith,\n  not: not,\n  isEmpty: isEmpty,\n  contains: contains,\n  without: without,\n  unique: unique,\n  reverse: reverse\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvZm4uanM/YWQxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgb3B0aW9uYWwgPSB2YWx1ZSA9PiB7XG4gIHZhciBpc1ByZXNlbnQgPSAoKSA9PiAhIXZhbHVlO1xuICB2YXIgbWFwID0gZm4gPT4gKGlzUHJlc2VudCgpID8gb3B0aW9uYWwoZm4odmFsdWUpKSA6IG9wdGlvbmFsKG51bGwpKTtcbiAgdmFyIGlmUHJlc2VudCA9IGZuID0+IChpc1ByZXNlbnQoKSA/IGZuKHZhbHVlKSA6IG51bGwpO1xuICByZXR1cm4ge1xuICAgIGlzUHJlc2VudCxcbiAgICBtYXAsXG4gICAgaWZQcmVzZW50XG4gIH07XG59O1xuXG52YXIgcGx1cyA9IChhLCBiKSA9PiBhICsgYjtcblxudmFyIHJhbmdlID0gKHN0YXJ0SW5jbHVzaXZlLCBlbmRFeGNsdXNpdmUpID0+IHtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gc3RhcnRJbmNsdXNpdmU7IGkgPCBlbmRFeGNsdXNpdmU7IGkrKykge1xuICAgIHJlc3VsdC5wdXNoKGkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgbkZyb20gPSAoc3RhcnQsIG51bWJlcikgPT4ge1xuICByZXR1cm4gcmFuZ2Uoc3RhcnQsIHN0YXJ0ICsgbnVtYmVyKTtcbn07XG5cbnZhciBpbnRlcnZhbCA9IChzdGFydEluY2x1c2l2ZSwgZW5kSW5jbHVzaXZlKSA9PiB7XG4gIHJldHVybiByYW5nZShzdGFydEluY2x1c2l2ZSwgZW5kSW5jbHVzaXZlICsgMSk7XG59O1xuXG52YXIgemlwV2l0aCA9IChmbiwgLi4uYXJycykgPT4ge1xuICBhcmd1bWVudHMubDtcbiAgcmV0dXJuIHJhbmdlKDAsIE1hdGgubWluKC4uLmFycnMubWFwKGFyciA9PiBhcnIubGVuZ3RoKSkpLm1hcChpID0+XG4gICAgZm4oLi4uYXJycy5tYXAoYXJyID0+IGFycltpXSkpXG4gICk7XG59O1xuXG52YXIgdGFpbCA9IGFyciA9PiB7XG4gIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xufTtcblxudmFyIGhlYWQgPSBhcnIgPT4ge1xuICByZXR1cm4gYXJyWzBdO1xufTtcblxudmFyIGlzRW1wdHkgPSBhcnIgPT4ge1xuICByZXR1cm4gYXJyLmxlbmd0aCA9PT0gMDtcbn07XG5cbnZhciB3aXRob3V0TGFzdCA9IChhcnIgPSBbXSkgPT4ge1xuICByZXR1cm4gYXJyLmxlbmd0aCA+IDEgPyBhcnIuc2xpY2UoMCwgYXJyLmxlbmd0aCAtIDEpIDogW107XG59O1xuXG52YXIgZmxhdHRlbiA9IChhcnIsIGRlcHRoID0gMTAwKSA9PiB7XG4gIHZhciBtZXJnZWQgPSBbXTtcbiAgZm9yIChsZXQgc3RlcCA9IDA7IHN0ZXAgPCBkZXB0aDsgc3RlcCsrKSB7XG4gICAgaWYgKG1lcmdlZC5sZW5ndGggPT09IDApIHtcbiAgICAgIG1lcmdlZCA9IGFyci5zbGljZSgwKTtcbiAgICB9XG4gICAgbGV0IGwxID0gbWVyZ2VkLmxlbmd0aDtcbiAgICBtZXJnZWQgPSBbXS5jb25jYXQuYXBwbHkoW10sIG1lcmdlZCk7XG4gICAgbGV0IGwyID0gbWVyZ2VkLmxlbmd0aDtcbiAgICBpZiAobDEgPT09IGwyKSBicmVhaztcbiAgfVxuICByZXR1cm4gbWVyZ2VkO1xufTtcblxudmFyIGZvbGRMZWZ0ID0gKGFyciwgc3RhcnQsIGZuKSA9PiB7XG4gIHJldHVybiBhcnIucmVkdWNlKGZuLCBzdGFydCk7XG59O1xudmFyIGZvbGRSaWdodCA9IChhcnIsIHN0YXJ0LCBmbikgPT4ge1xuICByZXR1cm4gYXJyLnJldmVyc2UoKS5yZWR1Y2UoZm4sIHN0YXJ0KTtcbn07XG5cbnZhciBhbmQgPSAoYWNjLCBjdXJyKSA9PiBhY2MgJiYgY3VycjtcbnZhciBub3QgPSBmbiA9PiAhZm47XG5cbnZhciBpZCA9IG4gPT4gbjtcbnZhciBzdWNjID0gbiA9PiBuICsgMTtcbnZhciBwcmVkID0gbiA9PiBuIC0gMTtcblxudmFyIGRpcmVjdGlvbnMgPSBbaWQsIHN1Y2MsIHByZWRdO1xuXG5jb25zdCBjb250YWlucyA9IChhcnIsIGUpID0+IHtcbiAgcmV0dXJuIGFyci5pbmRleE9mKGUpID49IDA7XG59O1xuXG5jb25zdCB3aXRob3V0ID0gKGFycjEsIGFycjIpID0+IHtcbiAgcmV0dXJuIGFycjEuZmlsdGVyKGUgPT4gIWNvbnRhaW5zKGFycjIsIGUpKTtcbn07XG5cbmNvbnN0IHVuaXF1ZSA9IGFyciA9PiB7XG4gIGxldCByID0gW107XG4gIGFyci5mb3JFYWNoKGUgPT4gKCFjb250YWlucyhyLCBlKSA/IHIucHVzaChlKSA6IDApKTtcbiAgcmV0dXJuIHI7XG59O1xuXG5jb25zdCByZXZlcnNlID0gYXJyID0+XG4gIHJhbmdlKDAsIGFyci5sZW5ndGgpXG4gICAgLm1hcChpID0+IGFyci5sZW5ndGggLSAxIC0gaSlcbiAgICAubWFwKGkgPT4gYXJyW2ldKTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBmbGF0dGVuLFxuICBmb2xkTGVmdCxcbiAgZm9sZFJpZ2h0LFxuICBhbmQsXG4gIHdpdGhvdXRMYXN0LFxuICBoZWFkLFxuICB0YWlsLFxuICBuRnJvbSxcbiAgcmFuZ2UsXG4gIGludGVydmFsLFxuICBvcHRpb25hbCxcbiAgcGx1cyxcbiAgaWQsXG4gIHN1Y2MsXG4gIHByZWQsXG4gIHppcFdpdGgsXG4gIG5vdCxcbiAgaXNFbXB0eSxcbiAgY29udGFpbnMsXG4gIHdpdGhvdXQsXG4gIHVuaXF1ZSxcbiAgcmV2ZXJzZVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZm4uanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBSEE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF0QkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcz9mY2RmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/*!*****************************************************!*\
  !*** ./node_modules/fast-json-patch/lib/helpers.js ***!
  \*****************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar __extends = undefined && undefined.__extends || function (d, b) {\n    for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n    }function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/*!\r\n * https://github.com/Starcounter-Jack/JSON-Patch\r\n * (c) 2017 Joachim Wester\r\n * MIT license\r\n */\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(obj, key) {\n    return _hasOwnProperty.call(obj, key);\n}\nexports.hasOwnProperty = hasOwnProperty;\nfunction _objectKeys(obj) {\n    if (Array.isArray(obj)) {\n        var keys = new Array(obj.length);\n        for (var k = 0; k < keys.length; k++) {\n            keys[k] = \"\" + k;\n        }\n        return keys;\n    }\n    if (Object.keys) {\n        return Object.keys(obj);\n    }\n    var keys = [];\n    for (var i in obj) {\n        if (hasOwnProperty(obj, i)) {\n            keys.push(i);\n        }\n    }\n    return keys;\n}\nexports._objectKeys = _objectKeys;\n;\n/**\r\n* Deeply clone the object.\r\n* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)\r\n* @param  {any} obj value to clone\r\n* @return {any} cloned obj\r\n*/\nfunction _deepClone(obj) {\n    switch (typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) {\n        case \"object\":\n            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\n        case \"undefined\":\n            return null; //this is how JSON.stringify behaves for array items\n        default:\n            return obj; //no need to clone primitives\n    }\n}\nexports._deepClone = _deepClone;\n//3x faster than cached /^\\d+$/.test(str)\nfunction isInteger(str) {\n    var i = 0;\n    var len = str.length;\n    var charCode;\n    while (i < len) {\n        charCode = str.charCodeAt(i);\n        if (charCode >= 48 && charCode <= 57) {\n            i++;\n            continue;\n        }\n        return false;\n    }\n    return true;\n}\nexports.isInteger = isInteger;\n/**\r\n* Escapes a json pointer path\r\n* @param path The raw pointer\r\n* @return the Escaped path\r\n*/\nfunction escapePathComponent(path) {\n    if (path.indexOf('/') === -1 && path.indexOf('~') === -1) return path;\n    return path.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\nexports.escapePathComponent = escapePathComponent;\n/**\r\n * Unescapes a json pointer path\r\n * @param path The escaped pointer\r\n * @return The unescaped path\r\n */\nfunction unescapePathComponent(path) {\n    return path.replace(/~1/g, '/').replace(/~0/g, '~');\n}\nexports.unescapePathComponent = unescapePathComponent;\nfunction _getPathRecursive(root, obj) {\n    var found;\n    for (var key in root) {\n        if (hasOwnProperty(root, key)) {\n            if (root[key] === obj) {\n                return escapePathComponent(key) + '/';\n            } else if (_typeof(root[key]) === 'object') {\n                found = _getPathRecursive(root[key], obj);\n                if (found != '') {\n                    return escapePathComponent(key) + '/' + found;\n                }\n            }\n        }\n    }\n    return '';\n}\nexports._getPathRecursive = _getPathRecursive;\nfunction getPath(root, obj) {\n    if (root === obj) {\n        return '/';\n    }\n    var path = _getPathRecursive(root, obj);\n    if (path === '') {\n        throw new Error(\"Object not found in root\");\n    }\n    return '/' + path;\n}\nexports.getPath = getPath;\n/**\r\n* Recursively checks whether an object has any undefined values inside.\r\n*/\nfunction hasUndefined(obj) {\n    if (obj === undefined) {\n        return true;\n    }\n    if (obj) {\n        if (Array.isArray(obj)) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (hasUndefined(obj[i])) {\n                    return true;\n                }\n            }\n        } else if ((typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === \"object\") {\n            var objKeys = _objectKeys(obj);\n            var objKeysLength = objKeys.length;\n            for (var i = 0; i < objKeysLength; i++) {\n                if (hasUndefined(obj[objKeys[i]])) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nexports.hasUndefined = hasUndefined;\nvar PatchError = function (_super) {\n    __extends(PatchError, _super);\n    function PatchError(message, name, index, operation, tree) {\n        _super.call(this, message);\n        this.message = message;\n        this.name = name;\n        this.index = index;\n        this.operation = operation;\n        this.tree = tree;\n    }\n    return PatchError;\n}(Error);\nexports.PatchError = PatchError;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvZmFzdC1qc29uLXBhdGNoL2xpYi9oZWxwZXJzLmpzP2FjZjUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxuLyohXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9TdGFyY291bnRlci1KYWNrL0pTT04tUGF0Y2hcclxuICogKGMpIDIwMTcgSm9hY2hpbSBXZXN0ZXJcclxuICogTUlUIGxpY2Vuc2VcclxuICovXHJcbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIGtleSkge1xyXG4gICAgcmV0dXJuIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcclxufVxyXG5leHBvcnRzLmhhc093blByb3BlcnR5ID0gaGFzT3duUHJvcGVydHk7XHJcbmZ1bmN0aW9uIF9vYmplY3RLZXlzKG9iaikge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xyXG4gICAgICAgIHZhciBrZXlzID0gbmV3IEFycmF5KG9iai5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwga2V5cy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICBrZXlzW2tdID0gXCJcIiArIGs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgfVxyXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XHJcbiAgICB9XHJcbiAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqLCBpKSkge1xyXG4gICAgICAgICAgICBrZXlzLnB1c2goaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGtleXM7XHJcbn1cclxuZXhwb3J0cy5fb2JqZWN0S2V5cyA9IF9vYmplY3RLZXlzO1xyXG47XHJcbi8qKlxyXG4qIERlZXBseSBjbG9uZSB0aGUgb2JqZWN0LlxyXG4qIGh0dHBzOi8vanNwZXJmLmNvbS9kZWVwLWNvcHktdnMtanNvbi1zdHJpbmdpZnktanNvbi1wYXJzZS8yNSAocmVjdXJzaXZlRGVlcENvcHkpXHJcbiogQHBhcmFtICB7YW55fSBvYmogdmFsdWUgdG8gY2xvbmVcclxuKiBAcmV0dXJuIHthbnl9IGNsb25lZCBvYmpcclxuKi9cclxuZnVuY3Rpb24gX2RlZXBDbG9uZShvYmopIHtcclxuICAgIHN3aXRjaCAodHlwZW9mIG9iaikge1xyXG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7IC8vRmFzdGVyIHRoYW4gRVM1IGNsb25lIC0gaHR0cDovL2pzcGVyZi5jb20vZGVlcC1jbG9uaW5nLW9mLW9iamVjdHMvNVxyXG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vdGhpcyBpcyBob3cgSlNPTi5zdHJpbmdpZnkgYmVoYXZlcyBmb3IgYXJyYXkgaXRlbXNcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gb2JqOyAvL25vIG5lZWQgdG8gY2xvbmUgcHJpbWl0aXZlc1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuX2RlZXBDbG9uZSA9IF9kZWVwQ2xvbmU7XHJcbi8vM3ggZmFzdGVyIHRoYW4gY2FjaGVkIC9eXFxkKyQvLnRlc3Qoc3RyKVxyXG5mdW5jdGlvbiBpc0ludGVnZXIoc3RyKSB7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcclxuICAgIHZhciBjaGFyQ29kZTtcclxuICAgIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICAgICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZXhwb3J0cy5pc0ludGVnZXIgPSBpc0ludGVnZXI7XHJcbi8qKlxyXG4qIEVzY2FwZXMgYSBqc29uIHBvaW50ZXIgcGF0aFxyXG4qIEBwYXJhbSBwYXRoIFRoZSByYXcgcG9pbnRlclxyXG4qIEByZXR1cm4gdGhlIEVzY2FwZWQgcGF0aFxyXG4qL1xyXG5mdW5jdGlvbiBlc2NhcGVQYXRoQ29tcG9uZW50KHBhdGgpIHtcclxuICAgIGlmIChwYXRoLmluZGV4T2YoJy8nKSA9PT0gLTEgJiYgcGF0aC5pbmRleE9mKCd+JykgPT09IC0xKVxyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XHJcbn1cclxuZXhwb3J0cy5lc2NhcGVQYXRoQ29tcG9uZW50ID0gZXNjYXBlUGF0aENvbXBvbmVudDtcclxuLyoqXHJcbiAqIFVuZXNjYXBlcyBhIGpzb24gcG9pbnRlciBwYXRoXHJcbiAqIEBwYXJhbSBwYXRoIFRoZSBlc2NhcGVkIHBvaW50ZXJcclxuICogQHJldHVybiBUaGUgdW5lc2NhcGVkIHBhdGhcclxuICovXHJcbmZ1bmN0aW9uIHVuZXNjYXBlUGF0aENvbXBvbmVudChwYXRoKSB7XHJcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9+MS9nLCAnLycpLnJlcGxhY2UoL34wL2csICd+Jyk7XHJcbn1cclxuZXhwb3J0cy51bmVzY2FwZVBhdGhDb21wb25lbnQgPSB1bmVzY2FwZVBhdGhDb21wb25lbnQ7XHJcbmZ1bmN0aW9uIF9nZXRQYXRoUmVjdXJzaXZlKHJvb3QsIG9iaikge1xyXG4gICAgdmFyIGZvdW5kO1xyXG4gICAgZm9yICh2YXIga2V5IGluIHJvb3QpIHtcclxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkocm9vdCwga2V5KSkge1xyXG4gICAgICAgICAgICBpZiAocm9vdFtrZXldID09PSBvYmopIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSkgKyAnLyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJvb3Rba2V5XSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gX2dldFBhdGhSZWN1cnNpdmUocm9vdFtrZXldLCBvYmopO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kICE9ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSArICcvJyArIGZvdW5kO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuICcnO1xyXG59XHJcbmV4cG9ydHMuX2dldFBhdGhSZWN1cnNpdmUgPSBfZ2V0UGF0aFJlY3Vyc2l2ZTtcclxuZnVuY3Rpb24gZ2V0UGF0aChyb290LCBvYmopIHtcclxuICAgIGlmIChyb290ID09PSBvYmopIHtcclxuICAgICAgICByZXR1cm4gJy8nO1xyXG4gICAgfVxyXG4gICAgdmFyIHBhdGggPSBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290LCBvYmopO1xyXG4gICAgaWYgKHBhdGggPT09ICcnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0IG5vdCBmb3VuZCBpbiByb290XCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICcvJyArIHBhdGg7XHJcbn1cclxuZXhwb3J0cy5nZXRQYXRoID0gZ2V0UGF0aDtcclxuLyoqXHJcbiogUmVjdXJzaXZlbHkgY2hlY2tzIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhbnkgdW5kZWZpbmVkIHZhbHVlcyBpbnNpZGUuXHJcbiovXHJcbmZ1bmN0aW9uIGhhc1VuZGVmaW5lZChvYmopIHtcclxuICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKG9iaikge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc1VuZGVmaW5lZChvYmpbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICB2YXIgb2JqS2V5cyA9IF9vYmplY3RLZXlzKG9iaik7XHJcbiAgICAgICAgICAgIHZhciBvYmpLZXlzTGVuZ3RoID0gb2JqS2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqS2V5c0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzVW5kZWZpbmVkKG9ialtvYmpLZXlzW2ldXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5leHBvcnRzLmhhc1VuZGVmaW5lZCA9IGhhc1VuZGVmaW5lZDtcclxudmFyIFBhdGNoRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFBhdGNoRXJyb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQYXRjaEVycm9yKG1lc3NhZ2UsIG5hbWUsIGluZGV4LCBvcGVyYXRpb24sIHRyZWUpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uID0gb3BlcmF0aW9uO1xyXG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUGF0Y2hFcnJvcjtcclxufShFcnJvcikpO1xyXG5leHBvcnRzLlBhdGNoRXJyb3IgPSBQYXRjaEVycm9yO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2Zhc3QtanNvbi1wYXRjaC9saWIvaGVscGVycy5qcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/*!******************************************!*\
  !*** ./node_modules/deep-equal/index.js ***!
  \******************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar pSlice = Array.prototype.slice;\nvar objectKeys = __webpack_require__(/*! ./lib/keys.js */ 28);\nvar isArguments = __webpack_require__(/*! ./lib/is_arguments.js */ 29);\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n    // 7.3. Other pairs that do not both pass typeof value == 'object',\n    // equivalence is determined by ==.\n  } else if (!actual || !expected || (typeof actual === 'undefined' ? 'undefined' : _typeof(actual)) != 'object' && (typeof expected === 'undefined' ? 'undefined' : _typeof(expected)) != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n    // 7.4. For all other Object pairs, including Array objects, equivalence is\n    // determined by having the same number of owned properties (as verified\n    // with Object.prototype.hasOwnProperty.call), the same set of keys\n    // (although not necessarily the same order), equivalent values for every\n    // corresponding key, and an identical 'prototype' property. Note: this\n    // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n};\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer(x) {\n  if (!x || (typeof x === 'undefined' ? 'undefined' : _typeof(x)) !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {\n    //happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length) return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i]) return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return (typeof a === 'undefined' ? 'undefined' : _typeof(a)) === (typeof b === 'undefined' ? 'undefined' : _typeof(b));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9pbmRleC5qcz8yYzBiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4vbGliL2tleXMuanMnKTtcbnZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vbGliL2lzX2FyZ3VtZW50cy5qcycpO1xuXG52YXIgZGVlcEVxdWFsID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgb3B0cykge1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBEYXRlICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zLiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkIHx8IHR5cGVvZiBhY3R1YWwgIT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkICE9ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9wdHMuc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjQuIEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgb3B0cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyICh4KSB7XG4gIGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHgubGVuZ3RoICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHguY29weSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgeC5zbGljZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoeC5sZW5ndGggPiAwICYmIHR5cGVvZiB4WzBdICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgb3B0cykge1xuICB2YXIgaSwga2V5O1xuICBpZiAoaXNVbmRlZmluZWRPck51bGwoYSkgfHwgaXNVbmRlZmluZWRPck51bGwoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHJldHVybiBmYWxzZTtcbiAgLy9+fn5JJ3ZlIG1hbmFnZWQgdG8gYnJlYWsgT2JqZWN0LmtleXMgdGhyb3VnaCBzY3Jld3kgYXJndW1lbnRzIHBhc3NpbmcuXG4gIC8vICAgQ29udmVydGluZyB0byBhcnJheSBzb2x2ZXMgdGhlIHByb2JsZW0uXG4gIGlmIChpc0FyZ3VtZW50cyhhKSkge1xuICAgIGlmICghaXNBcmd1bWVudHMoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gZGVlcEVxdWFsKGEsIGIsIG9wdHMpO1xuICB9XG4gIGlmIChpc0J1ZmZlcihhKSkge1xuICAgIGlmICghaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciBrYSA9IG9iamVjdEtleXMoYSksXG4gICAgICAgIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgfSBjYXRjaCAoZSkgey8vaGFwcGVucyB3aGVuIG9uZSBpcyBhIHN0cmluZyBsaXRlcmFsIGFuZCB0aGUgb3RoZXIgaXNuJ3RcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBvcHRzKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGI7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvaW5kZXguanMiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/*!**************************************************!*\
  !*** ./node_modules/fast-json-patch/lib/core.js ***!
  \**************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar equalsOptions = { strict: true };\nvar _equals = __webpack_require__(/*! deep-equal */ 5);\nvar areEquals = function areEquals(a, b) {\n    return _equals(a, b, equalsOptions);\n};\nvar helpers_1 = __webpack_require__(/*! ./helpers */ 4);\nexports.JsonPatchError = helpers_1.PatchError;\nexports.deepClone = helpers_1._deepClone;\n/* We use a Javascript hash to store each\r\n function. Each hash entry (property) uses\r\n the operation identifiers specified in rfc6902.\r\n In this way, we can map each patch operation\r\n to its dedicated function in efficient way.\r\n */\n/* The operations applicable to an object */\nvar objOps = {\n    add: function add(obj, key, document) {\n        obj[key] = this.value;\n        return { newDocument: document };\n    },\n    remove: function remove(obj, key, document) {\n        var removed = obj[key];\n        delete obj[key];\n        return { newDocument: document, removed: removed };\n    },\n    replace: function replace(obj, key, document) {\n        var removed = obj[key];\n        obj[key] = this.value;\n        return { newDocument: document, removed: removed };\n    },\n    move: function move(obj, key, document) {\n        /* in case move target overwrites an existing value,\r\n        return the removed value, this can be taxing performance-wise,\r\n        and is potentially unneeded */\n        var removed = getValueByPointer(document, this.path);\n        if (removed) {\n            removed = helpers_1._deepClone(removed);\n        }\n        var originalValue = applyOperation(document, { op: \"remove\", path: this.from }).removed;\n        applyOperation(document, { op: \"add\", path: this.path, value: originalValue });\n        return { newDocument: document, removed: removed };\n    },\n    copy: function copy(obj, key, document) {\n        var valueToCopy = getValueByPointer(document, this.from);\n        // enforce copy by value so further operations don't affect source (see issue #177)\n        applyOperation(document, { op: \"add\", path: this.path, value: helpers_1._deepClone(valueToCopy) });\n        return { newDocument: document };\n    },\n    test: function test(obj, key, document) {\n        return { newDocument: document, test: areEquals(obj[key], this.value) };\n    },\n    _get: function _get(obj, key, document) {\n        this.value = obj[key];\n        return { newDocument: document };\n    }\n};\n/* The operations applicable to an array. Many are the same as for the object */\nvar arrOps = {\n    add: function add(arr, i, document) {\n        if (helpers_1.isInteger(i)) {\n            arr.splice(i, 0, this.value);\n        } else {\n            arr[i] = this.value;\n        }\n        // this may be needed when using '-' in an array\n        return { newDocument: document, index: i };\n    },\n    remove: function remove(arr, i, document) {\n        var removedList = arr.splice(i, 1);\n        return { newDocument: document, removed: removedList[0] };\n    },\n    replace: function replace(arr, i, document) {\n        var removed = arr[i];\n        arr[i] = this.value;\n        return { newDocument: document, removed: removed };\n    },\n    move: objOps.move,\n    copy: objOps.copy,\n    test: objOps.test,\n    _get: objOps._get\n};\n/**\r\n * Retrieves a value from a JSON document by a JSON pointer.\r\n * Returns the value.\r\n *\r\n * @param document The document to get the value from\r\n * @param pointer an escaped JSON pointer\r\n * @return The retrieved value\r\n */\nfunction getValueByPointer(document, pointer) {\n    if (pointer == '') {\n        return document;\n    }\n    var getOriginalDestination = { op: \"_get\", path: pointer };\n    applyOperation(document, getOriginalDestination);\n    return getOriginalDestination.value;\n}\nexports.getValueByPointer = getValueByPointer;\n/**\r\n * Apply a single JSON Patch Operation on a JSON document.\r\n * Returns the {newDocument, result} of the operation.\r\n * It modifies the `document` and `operation` objects - it gets the values by reference.\r\n * If you would like to avoid touching your values, clone them:\r\n * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.\r\n *\r\n * @param document The document to patch\r\n * @param operation The operation to apply\r\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\r\n * @param mutateDocument Whether to mutate the original document or clone it before applying\r\n * @return `{newDocument, result}` after the operation\r\n */\nfunction applyOperation(document, operation, validateOperation, mutateDocument) {\n    if (validateOperation === void 0) {\n        validateOperation = false;\n    }\n    if (mutateDocument === void 0) {\n        mutateDocument = true;\n    }\n    if (validateOperation) {\n        if (typeof validateOperation == 'function') {\n            validateOperation(operation, 0, document, operation.path);\n        } else {\n            validator(operation, 0);\n        }\n    }\n    /* ROOT OPERATIONS */\n    if (operation.path === \"\") {\n        var returnValue = { newDocument: document };\n        if (operation.op === 'add') {\n            returnValue.newDocument = operation.value;\n            return returnValue;\n        } else if (operation.op === 'replace') {\n            returnValue.newDocument = operation.value;\n            returnValue.removed = document; //document we removed\n            return returnValue;\n        } else if (operation.op === 'move' || operation.op === 'copy') {\n            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field\n            if (operation.op === 'move') {\n                returnValue.removed = document;\n            }\n            return returnValue;\n        } else if (operation.op === 'test') {\n            returnValue.test = areEquals(document, operation.value);\n            if (returnValue.test === false) {\n                throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\n            }\n            returnValue.newDocument = document;\n            return returnValue;\n        } else if (operation.op === 'remove') {\n            returnValue.removed = document;\n            returnValue.newDocument = null;\n            return returnValue;\n        } else if (operation.op === '_get') {\n            operation.value = document;\n            return returnValue;\n        } else {\n            if (validateOperation) {\n                throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', 0, operation, document);\n            } else {\n                return returnValue;\n            }\n        }\n    } /* END ROOT OPERATIONS */\n    else {\n            if (!mutateDocument) {\n                document = helpers_1._deepClone(document);\n            }\n            var path = operation.path || \"\";\n            var keys = path.split('/');\n            var obj = document;\n            var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift\n            var len = keys.length;\n            var existingPathFragment = undefined;\n            var key = void 0;\n            var validateFunction = void 0;\n            if (typeof validateOperation == 'function') {\n                validateFunction = validateOperation;\n            } else {\n                validateFunction = validator;\n            }\n            while (true) {\n                key = keys[t];\n                if (validateOperation) {\n                    if (existingPathFragment === undefined) {\n                        if (obj[key] === undefined) {\n                            existingPathFragment = keys.slice(0, t).join('/');\n                        } else if (t == len - 1) {\n                            existingPathFragment = operation.path;\n                        }\n                        if (existingPathFragment !== undefined) {\n                            validateFunction(operation, 0, document, existingPathFragment);\n                        }\n                    }\n                }\n                t++;\n                if (Array.isArray(obj)) {\n                    if (key === '-') {\n                        key = obj.length;\n                    } else {\n                        if (validateOperation && !helpers_1.isInteger(key)) {\n                            throw new exports.JsonPatchError(\"Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\", \"OPERATION_PATH_ILLEGAL_ARRAY_INDEX\", 0, operation.path, operation);\n                        } // only parse key when it's an integer for `arr.prop` to work\n                        else if (helpers_1.isInteger(key)) {\n                                key = ~~key;\n                            }\n                    }\n                    if (t >= len) {\n                        if (validateOperation && operation.op === \"add\" && key > obj.length) {\n                            throw new exports.JsonPatchError(\"The specified index MUST NOT be greater than the number of elements in the array\", \"OPERATION_VALUE_OUT_OF_BOUNDS\", 0, operation.path, operation);\n                        }\n                        var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch\n                        if (returnValue.test === false) {\n                            throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\n                        }\n                        return returnValue;\n                    }\n                } else {\n                    if (key && key.indexOf('~') != -1) {\n                        key = helpers_1.unescapePathComponent(key);\n                    }\n                    if (t >= len) {\n                        var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch\n                        if (returnValue.test === false) {\n                            throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\n                        }\n                        return returnValue;\n                    }\n                }\n                obj = obj[key];\n            }\n        }\n}\nexports.applyOperation = applyOperation;\n/**\r\n * Apply a full JSON Patch array on a JSON document.\r\n * Returns the {newDocument, result} of the patch.\r\n * It modifies the `document` object and `patch` - it gets the values by reference.\r\n * If you would like to avoid touching your values, clone them:\r\n * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.\r\n *\r\n * @param document The document to patch\r\n * @param patch The patch to apply\r\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\r\n * @param mutateDocument Whether to mutate the original document or clone it before applying\r\n * @return An array of `{newDocument, result}` after the patch\r\n */\nfunction applyPatch(document, patch, validateOperation, mutateDocument) {\n    if (mutateDocument === void 0) {\n        mutateDocument = true;\n    }\n    if (validateOperation) {\n        if (!Array.isArray(patch)) {\n            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');\n        }\n    }\n    if (!mutateDocument) {\n        document = helpers_1._deepClone(document);\n    }\n    var results = new Array(patch.length);\n    for (var i = 0, length_1 = patch.length; i < length_1; i++) {\n        results[i] = applyOperation(document, patch[i], validateOperation);\n        document = results[i].newDocument; // in case root was replaced\n    }\n    results.newDocument = document;\n    return results;\n}\nexports.applyPatch = applyPatch;\n/**\r\n * Apply a single JSON Patch Operation on a JSON document.\r\n * Returns the updated document.\r\n * Suitable as a reducer.\r\n *\r\n * @param document The document to patch\r\n * @param operation The operation to apply\r\n * @return The updated document\r\n */\nfunction applyReducer(document, operation) {\n    var operationResult = applyOperation(document, operation);\n    if (operationResult.test === false) {\n        throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\n    }\n    return operationResult.newDocument;\n}\nexports.applyReducer = applyReducer;\n/**\r\n * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.\r\n * @param {object} operation - operation object (patch)\r\n * @param {number} index - index of operation in the sequence\r\n * @param {object} [document] - object where the operation is supposed to be applied\r\n * @param {string} [existingPathFragment] - comes along with `document`\r\n */\nfunction validator(operation, index, document, existingPathFragment) {\n    if ((typeof operation === 'undefined' ? 'undefined' : _typeof(operation)) !== 'object' || operation === null || Array.isArray(operation)) {\n        throw new exports.JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);\n    } else if (!objOps[operation.op]) {\n        throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);\n    } else if (typeof operation.path !== 'string') {\n        throw new exports.JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);\n    } else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {\n        // paths that aren't empty string should start with \"/\"\n        throw new exports.JsonPatchError('Operation `path` property must start with \"/\"', 'OPERATION_PATH_INVALID', index, operation, document);\n    } else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {\n        throw new exports.JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);\n    } else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {\n        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);\n    } else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && helpers_1.hasUndefined(operation.value)) {\n        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);\n    } else if (document) {\n        if (operation.op == \"add\") {\n            var pathLen = operation.path.split(\"/\").length;\n            var existingPathLen = existingPathFragment.split(\"/\").length;\n            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {\n                throw new exports.JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);\n            }\n        } else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {\n            if (operation.path !== existingPathFragment) {\n                throw new exports.JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);\n            }\n        } else if (operation.op === 'move' || operation.op === 'copy') {\n            var existingValue = { op: \"_get\", path: operation.from, value: undefined };\n            var error = validate([existingValue], document);\n            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {\n                throw new exports.JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);\n            }\n        }\n    }\n}\nexports.validator = validator;\n/**\r\n * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.\r\n * If error is encountered, returns a JsonPatchError object\r\n * @param sequence\r\n * @param document\r\n * @returns {JsonPatchError|undefined}\r\n */\nfunction validate(sequence, document, externalValidator) {\n    try {\n        if (!Array.isArray(sequence)) {\n            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');\n        }\n        if (document) {\n            //clone document and sequence so that we can safely try applying operations\n            applyPatch(helpers_1._deepClone(document), helpers_1._deepClone(sequence), externalValidator || true);\n        } else {\n            externalValidator = externalValidator || validator;\n            for (var i = 0; i < sequence.length; i++) {\n                externalValidator(sequence[i], i, document, undefined);\n            }\n        }\n    } catch (e) {\n        if (e instanceof exports.JsonPatchError) {\n            return e;\n        } else {\n            throw e;\n        }\n    }\n}\nexports.validate = validate;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvZmFzdC1qc29uLXBhdGNoL2xpYi9jb3JlLmpzPzAzYmUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGVxdWFsc09wdGlvbnMgPSB7IHN0cmljdDogdHJ1ZSB9O1xyXG52YXIgX2VxdWFscyA9IHJlcXVpcmUoJ2RlZXAtZXF1YWwnKTtcclxudmFyIGFyZUVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICByZXR1cm4gX2VxdWFscyhhLCBiLCBlcXVhbHNPcHRpb25zKTtcclxufTtcclxudmFyIGhlbHBlcnNfMSA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xyXG5leHBvcnRzLkpzb25QYXRjaEVycm9yID0gaGVscGVyc18xLlBhdGNoRXJyb3I7XHJcbmV4cG9ydHMuZGVlcENsb25lID0gaGVscGVyc18xLl9kZWVwQ2xvbmU7XHJcbi8qIFdlIHVzZSBhIEphdmFzY3JpcHQgaGFzaCB0byBzdG9yZSBlYWNoXHJcbiBmdW5jdGlvbi4gRWFjaCBoYXNoIGVudHJ5IChwcm9wZXJ0eSkgdXNlc1xyXG4gdGhlIG9wZXJhdGlvbiBpZGVudGlmaWVycyBzcGVjaWZpZWQgaW4gcmZjNjkwMi5cclxuIEluIHRoaXMgd2F5LCB3ZSBjYW4gbWFwIGVhY2ggcGF0Y2ggb3BlcmF0aW9uXHJcbiB0byBpdHMgZGVkaWNhdGVkIGZ1bmN0aW9uIGluIGVmZmljaWVudCB3YXkuXHJcbiAqL1xyXG4vKiBUaGUgb3BlcmF0aW9ucyBhcHBsaWNhYmxlIHRvIGFuIG9iamVjdCAqL1xyXG52YXIgb2JqT3BzID0ge1xyXG4gICAgYWRkOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XHJcbiAgICAgICAgb2JqW2tleV0gPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xyXG4gICAgfSxcclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xyXG4gICAgICAgIHZhciByZW1vdmVkID0gb2JqW2tleV07XHJcbiAgICAgICAgZGVsZXRlIG9ialtrZXldO1xyXG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xyXG4gICAgfSxcclxuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcclxuICAgICAgICB2YXIgcmVtb3ZlZCA9IG9ialtrZXldO1xyXG4gICAgICAgIG9ialtrZXldID0gdGhpcy52YWx1ZTtcclxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcclxuICAgIH0sXHJcbiAgICBtb3ZlOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XHJcbiAgICAgICAgLyogaW4gY2FzZSBtb3ZlIHRhcmdldCBvdmVyd3JpdGVzIGFuIGV4aXN0aW5nIHZhbHVlLFxyXG4gICAgICAgIHJldHVybiB0aGUgcmVtb3ZlZCB2YWx1ZSwgdGhpcyBjYW4gYmUgdGF4aW5nIHBlcmZvcm1hbmNlLXdpc2UsXHJcbiAgICAgICAgYW5kIGlzIHBvdGVudGlhbGx5IHVubmVlZGVkICovXHJcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgdGhpcy5wYXRoKTtcclxuICAgICAgICBpZiAocmVtb3ZlZCkge1xyXG4gICAgICAgICAgICByZW1vdmVkID0gaGVscGVyc18xLl9kZWVwQ2xvbmUocmVtb3ZlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvcmlnaW5hbFZhbHVlID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHsgb3A6IFwicmVtb3ZlXCIsIHBhdGg6IHRoaXMuZnJvbSB9KS5yZW1vdmVkO1xyXG4gICAgICAgIGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCB7IG9wOiBcImFkZFwiLCBwYXRoOiB0aGlzLnBhdGgsIHZhbHVlOiBvcmlnaW5hbFZhbHVlIH0pO1xyXG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xyXG4gICAgfSxcclxuICAgIGNvcHk6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcclxuICAgICAgICB2YXIgdmFsdWVUb0NvcHkgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgdGhpcy5mcm9tKTtcclxuICAgICAgICAvLyBlbmZvcmNlIGNvcHkgYnkgdmFsdWUgc28gZnVydGhlciBvcGVyYXRpb25zIGRvbid0IGFmZmVjdCBzb3VyY2UgKHNlZSBpc3N1ZSAjMTc3KVxyXG4gICAgICAgIGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCB7IG9wOiBcImFkZFwiLCBwYXRoOiB0aGlzLnBhdGgsIHZhbHVlOiBoZWxwZXJzXzEuX2RlZXBDbG9uZSh2YWx1ZVRvQ29weSkgfSk7XHJcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XHJcbiAgICB9LFxyXG4gICAgdGVzdDogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xyXG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgdGVzdDogYXJlRXF1YWxzKG9ialtrZXldLCB0aGlzLnZhbHVlKSB9O1xyXG4gICAgfSxcclxuICAgIF9nZXQ6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gb2JqW2tleV07XHJcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XHJcbiAgICB9XHJcbn07XHJcbi8qIFRoZSBvcGVyYXRpb25zIGFwcGxpY2FibGUgdG8gYW4gYXJyYXkuIE1hbnkgYXJlIHRoZSBzYW1lIGFzIGZvciB0aGUgb2JqZWN0ICovXHJcbnZhciBhcnJPcHMgPSB7XHJcbiAgICBhZGQ6IGZ1bmN0aW9uIChhcnIsIGksIGRvY3VtZW50KSB7XHJcbiAgICAgICAgaWYgKGhlbHBlcnNfMS5pc0ludGVnZXIoaSkpIHtcclxuICAgICAgICAgICAgYXJyLnNwbGljZShpLCAwLCB0aGlzLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFycltpXSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRoaXMgbWF5IGJlIG5lZWRlZCB3aGVuIHVzaW5nICctJyBpbiBhbiBhcnJheVxyXG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgaW5kZXg6IGkgfTtcclxuICAgIH0sXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChhcnIsIGksIGRvY3VtZW50KSB7XHJcbiAgICAgICAgdmFyIHJlbW92ZWRMaXN0ID0gYXJyLnNwbGljZShpLCAxKTtcclxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWRMaXN0WzBdIH07XHJcbiAgICB9LFxyXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcclxuICAgICAgICB2YXIgcmVtb3ZlZCA9IGFycltpXTtcclxuICAgICAgICBhcnJbaV0gPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xyXG4gICAgfSxcclxuICAgIG1vdmU6IG9iak9wcy5tb3ZlLFxyXG4gICAgY29weTogb2JqT3BzLmNvcHksXHJcbiAgICB0ZXN0OiBvYmpPcHMudGVzdCxcclxuICAgIF9nZXQ6IG9iak9wcy5fZ2V0XHJcbn07XHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgYSB2YWx1ZSBmcm9tIGEgSlNPTiBkb2N1bWVudCBieSBhIEpTT04gcG9pbnRlci5cclxuICogUmV0dXJucyB0aGUgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tXHJcbiAqIEBwYXJhbSBwb2ludGVyIGFuIGVzY2FwZWQgSlNPTiBwb2ludGVyXHJcbiAqIEByZXR1cm4gVGhlIHJldHJpZXZlZCB2YWx1ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIHBvaW50ZXIpIHtcclxuICAgIGlmIChwb2ludGVyID09ICcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xyXG4gICAgfVxyXG4gICAgdmFyIGdldE9yaWdpbmFsRGVzdGluYXRpb24gPSB7IG9wOiBcIl9nZXRcIiwgcGF0aDogcG9pbnRlciB9O1xyXG4gICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIGdldE9yaWdpbmFsRGVzdGluYXRpb24pO1xyXG4gICAgcmV0dXJuIGdldE9yaWdpbmFsRGVzdGluYXRpb24udmFsdWU7XHJcbn1cclxuZXhwb3J0cy5nZXRWYWx1ZUJ5UG9pbnRlciA9IGdldFZhbHVlQnlQb2ludGVyO1xyXG4vKipcclxuICogQXBwbHkgYSBzaW5nbGUgSlNPTiBQYXRjaCBPcGVyYXRpb24gb24gYSBKU09OIGRvY3VtZW50LlxyXG4gKiBSZXR1cm5zIHRoZSB7bmV3RG9jdW1lbnQsIHJlc3VsdH0gb2YgdGhlIG9wZXJhdGlvbi5cclxuICogSXQgbW9kaWZpZXMgdGhlIGBkb2N1bWVudGAgYW5kIGBvcGVyYXRpb25gIG9iamVjdHMgLSBpdCBnZXRzIHRoZSB2YWx1ZXMgYnkgcmVmZXJlbmNlLlxyXG4gKiBJZiB5b3Ugd291bGQgbGlrZSB0byBhdm9pZCB0b3VjaGluZyB5b3VyIHZhbHVlcywgY2xvbmUgdGhlbTpcclxuICogYGpzb25wYXRjaC5hcHBseU9wZXJhdGlvbihkb2N1bWVudCwganNvbnBhdGNoLl9kZWVwQ2xvbmUob3BlcmF0aW9uKSlgLlxyXG4gKlxyXG4gKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIHBhdGNoXHJcbiAqIEBwYXJhbSBvcGVyYXRpb24gVGhlIG9wZXJhdGlvbiB0byBhcHBseVxyXG4gKiBAcGFyYW0gdmFsaWRhdGVPcGVyYXRpb24gYGZhbHNlYCBpcyB3aXRob3V0IHZhbGlkYXRpb24sIGB0cnVlYCB0byB1c2UgZGVmYXVsdCBqc29ucGF0Y2gncyB2YWxpZGF0aW9uLCBvciB5b3UgY2FuIHBhc3MgYSBgdmFsaWRhdGVPcGVyYXRpb25gIGNhbGxiYWNrIHRvIGJlIHVzZWQgZm9yIHZhbGlkYXRpb24uXHJcbiAqIEBwYXJhbSBtdXRhdGVEb2N1bWVudCBXaGV0aGVyIHRvIG11dGF0ZSB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgb3IgY2xvbmUgaXQgYmVmb3JlIGFwcGx5aW5nXHJcbiAqIEByZXR1cm4gYHtuZXdEb2N1bWVudCwgcmVzdWx0fWAgYWZ0ZXIgdGhlIG9wZXJhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIG9wZXJhdGlvbiwgdmFsaWRhdGVPcGVyYXRpb24sIG11dGF0ZURvY3VtZW50KSB7XHJcbiAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gPT09IHZvaWQgMCkgeyB2YWxpZGF0ZU9wZXJhdGlvbiA9IGZhbHNlOyB9XHJcbiAgICBpZiAobXV0YXRlRG9jdW1lbnQgPT09IHZvaWQgMCkgeyBtdXRhdGVEb2N1bWVudCA9IHRydWU7IH1cclxuICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVPcGVyYXRpb24gPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZU9wZXJhdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBvcGVyYXRpb24ucGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YWxpZGF0b3Iob3BlcmF0aW9uLCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiBST09UIE9QRVJBVElPTlMgKi9cclxuICAgIGlmIChvcGVyYXRpb24ucGF0aCA9PT0gXCJcIikge1xyXG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XHJcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ2FkZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBvcGVyYXRpb24udmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAncmVwbGFjZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBvcGVyYXRpb24udmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnJlbW92ZWQgPSBkb2N1bWVudDsgLy9kb2N1bWVudCB3ZSByZW1vdmVkXHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAnbW92ZScgfHwgb3BlcmF0aW9uLm9wID09PSAnY29weScpIHtcclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgb3BlcmF0aW9uLmZyb20pOyAvLyBnZXQgdGhlIHZhbHVlIGJ5IGpzb24tcG9pbnRlciBpbiBgZnJvbWAgZmllbGRcclxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ21vdmUnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICd0ZXN0Jykge1xyXG4gICAgICAgICAgICByZXR1cm5WYWx1ZS50ZXN0ID0gYXJlRXF1YWxzKGRvY3VtZW50LCBvcGVyYXRpb24udmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiVGVzdCBvcGVyYXRpb24gZmFpbGVkXCIsICdURVNUX09QRVJBVElPTl9GQUlMRUQnLCAwLCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IGRvY3VtZW50O1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ3JlbW92ZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlZCA9IGRvY3VtZW50O1xyXG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAnX2dldCcpIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uLnZhbHVlID0gZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgb3BgIHByb3BlcnR5IGlzIG5vdCBvbmUgb2Ygb3BlcmF0aW9ucyBkZWZpbmVkIGluIFJGQy02OTAyJywgJ09QRVJBVElPTl9PUF9JTlZBTElEJywgMCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IC8qIEVORCBST09UIE9QRVJBVElPTlMgKi9cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICghbXV0YXRlRG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQgPSBoZWxwZXJzXzEuX2RlZXBDbG9uZShkb2N1bWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXRoID0gb3BlcmF0aW9uLnBhdGggfHwgXCJcIjtcclxuICAgICAgICB2YXIga2V5cyA9IHBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgICB2YXIgb2JqID0gZG9jdW1lbnQ7XHJcbiAgICAgICAgdmFyIHQgPSAxOyAvL3NraXAgZW1wdHkgZWxlbWVudCAtIGh0dHA6Ly9qc3BlcmYuY29tL3RvLXNoaWZ0LW9yLW5vdC10by1zaGlmdFxyXG4gICAgICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcclxuICAgICAgICB2YXIgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIGtleSA9IHZvaWQgMDtcclxuICAgICAgICB2YXIgdmFsaWRhdGVGdW5jdGlvbiA9IHZvaWQgMDtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRlT3BlcmF0aW9uID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbiA9IHZhbGlkYXRlT3BlcmF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbiA9IHZhbGlkYXRvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAga2V5ID0ga2V5c1t0XTtcclxuICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nUGF0aEZyYWdtZW50ID0ga2V5cy5zbGljZSgwLCB0KS5qb2luKCcvJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPT0gbGVuIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1BhdGhGcmFnbWVudCA9IG9wZXJhdGlvbi5wYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uKG9wZXJhdGlvbiwgMCwgZG9jdW1lbnQsIGV4aXN0aW5nUGF0aEZyYWdtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdCsrO1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnLScpIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBvYmoubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uICYmICFoZWxwZXJzXzEuaXNJbnRlZ2VyKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJFeHBlY3RlZCBhbiB1bnNpZ25lZCBiYXNlLTEwIGludGVnZXIgdmFsdWUsIG1ha2luZyB0aGUgbmV3IHJlZmVyZW5jZWQgdmFsdWUgdGhlIGFycmF5IGVsZW1lbnQgd2l0aCB0aGUgemVyby1iYXNlZCBpbmRleFwiLCBcIk9QRVJBVElPTl9QQVRIX0lMTEVHQUxfQVJSQVlfSU5ERVhcIiwgMCwgb3BlcmF0aW9uLnBhdGgsIG9wZXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBvbmx5IHBhcnNlIGtleSB3aGVuIGl0J3MgYW4gaW50ZWdlciBmb3IgYGFyci5wcm9wYCB0byB3b3JrXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGVscGVyc18xLmlzSW50ZWdlcihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IH5+a2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0ID49IGxlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiAmJiBvcGVyYXRpb24ub3AgPT09IFwiYWRkXCIgJiYga2V5ID4gb2JqLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRoZSBzcGVjaWZpZWQgaW5kZXggTVVTVCBOT1QgYmUgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5XCIsIFwiT1BFUkFUSU9OX1ZBTFVFX09VVF9PRl9CT1VORFNcIiwgMCwgb3BlcmF0aW9uLnBhdGgsIG9wZXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGFyck9wc1tvcGVyYXRpb24ub3BdLmNhbGwob3BlcmF0aW9uLCBvYmosIGtleSwgZG9jdW1lbnQpOyAvLyBBcHBseSBwYXRjaFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZS50ZXN0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgMCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgJiYga2V5LmluZGV4T2YoJ34nKSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGhlbHBlcnNfMS51bmVzY2FwZVBhdGhDb21wb25lbnQoa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0ID49IGxlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IG9iak9wc1tvcGVyYXRpb24ub3BdLmNhbGwob3BlcmF0aW9uLCBvYmosIGtleSwgZG9jdW1lbnQpOyAvLyBBcHBseSBwYXRjaFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZS50ZXN0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgMCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvYmogPSBvYmpba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5hcHBseU9wZXJhdGlvbiA9IGFwcGx5T3BlcmF0aW9uO1xyXG4vKipcclxuICogQXBwbHkgYSBmdWxsIEpTT04gUGF0Y2ggYXJyYXkgb24gYSBKU09OIGRvY3VtZW50LlxyXG4gKiBSZXR1cm5zIHRoZSB7bmV3RG9jdW1lbnQsIHJlc3VsdH0gb2YgdGhlIHBhdGNoLlxyXG4gKiBJdCBtb2RpZmllcyB0aGUgYGRvY3VtZW50YCBvYmplY3QgYW5kIGBwYXRjaGAgLSBpdCBnZXRzIHRoZSB2YWx1ZXMgYnkgcmVmZXJlbmNlLlxyXG4gKiBJZiB5b3Ugd291bGQgbGlrZSB0byBhdm9pZCB0b3VjaGluZyB5b3VyIHZhbHVlcywgY2xvbmUgdGhlbTpcclxuICogYGpzb25wYXRjaC5hcHBseVBhdGNoKGRvY3VtZW50LCBqc29ucGF0Y2guX2RlZXBDbG9uZShwYXRjaCkpYC5cclxuICpcclxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxyXG4gKiBAcGFyYW0gcGF0Y2ggVGhlIHBhdGNoIHRvIGFwcGx5XHJcbiAqIEBwYXJhbSB2YWxpZGF0ZU9wZXJhdGlvbiBgZmFsc2VgIGlzIHdpdGhvdXQgdmFsaWRhdGlvbiwgYHRydWVgIHRvIHVzZSBkZWZhdWx0IGpzb25wYXRjaCdzIHZhbGlkYXRpb24sIG9yIHlvdSBjYW4gcGFzcyBhIGB2YWxpZGF0ZU9wZXJhdGlvbmAgY2FsbGJhY2sgdG8gYmUgdXNlZCBmb3IgdmFsaWRhdGlvbi5cclxuICogQHBhcmFtIG11dGF0ZURvY3VtZW50IFdoZXRoZXIgdG8gbXV0YXRlIHRoZSBvcmlnaW5hbCBkb2N1bWVudCBvciBjbG9uZSBpdCBiZWZvcmUgYXBwbHlpbmdcclxuICogQHJldHVybiBBbiBhcnJheSBvZiBge25ld0RvY3VtZW50LCByZXN1bHR9YCBhZnRlciB0aGUgcGF0Y2hcclxuICovXHJcbmZ1bmN0aW9uIGFwcGx5UGF0Y2goZG9jdW1lbnQsIHBhdGNoLCB2YWxpZGF0ZU9wZXJhdGlvbiwgbXV0YXRlRG9jdW1lbnQpIHtcclxuICAgIGlmIChtdXRhdGVEb2N1bWVudCA9PT0gdm9pZCAwKSB7IG11dGF0ZURvY3VtZW50ID0gdHJ1ZTsgfVxyXG4gICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignUGF0Y2ggc2VxdWVuY2UgbXVzdCBiZSBhbiBhcnJheScsICdTRVFVRU5DRV9OT1RfQU5fQVJSQVknKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XHJcbiAgICAgICAgZG9jdW1lbnQgPSBoZWxwZXJzXzEuX2RlZXBDbG9uZShkb2N1bWVudCk7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShwYXRjaC5sZW5ndGgpO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gcGF0Y2gubGVuZ3RoOyBpIDwgbGVuZ3RoXzE7IGkrKykge1xyXG4gICAgICAgIHJlc3VsdHNbaV0gPSBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgcGF0Y2hbaV0sIHZhbGlkYXRlT3BlcmF0aW9uKTtcclxuICAgICAgICBkb2N1bWVudCA9IHJlc3VsdHNbaV0ubmV3RG9jdW1lbnQ7IC8vIGluIGNhc2Ugcm9vdCB3YXMgcmVwbGFjZWRcclxuICAgIH1cclxuICAgIHJlc3VsdHMubmV3RG9jdW1lbnQgPSBkb2N1bWVudDtcclxuICAgIHJldHVybiByZXN1bHRzO1xyXG59XHJcbmV4cG9ydHMuYXBwbHlQYXRjaCA9IGFwcGx5UGF0Y2g7XHJcbi8qKlxyXG4gKiBBcHBseSBhIHNpbmdsZSBKU09OIFBhdGNoIE9wZXJhdGlvbiBvbiBhIEpTT04gZG9jdW1lbnQuXHJcbiAqIFJldHVybnMgdGhlIHVwZGF0ZWQgZG9jdW1lbnQuXHJcbiAqIFN1aXRhYmxlIGFzIGEgcmVkdWNlci5cclxuICpcclxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxyXG4gKiBAcGFyYW0gb3BlcmF0aW9uIFRoZSBvcGVyYXRpb24gdG8gYXBwbHlcclxuICogQHJldHVybiBUaGUgdXBkYXRlZCBkb2N1bWVudFxyXG4gKi9cclxuZnVuY3Rpb24gYXBwbHlSZWR1Y2VyKGRvY3VtZW50LCBvcGVyYXRpb24pIHtcclxuICAgIHZhciBvcGVyYXRpb25SZXN1bHQgPSBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgb3BlcmF0aW9uKTtcclxuICAgIGlmIChvcGVyYXRpb25SZXN1bHQudGVzdCA9PT0gZmFsc2UpIHtcclxuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgMCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3BlcmF0aW9uUmVzdWx0Lm5ld0RvY3VtZW50O1xyXG59XHJcbmV4cG9ydHMuYXBwbHlSZWR1Y2VyID0gYXBwbHlSZWR1Y2VyO1xyXG4vKipcclxuICogVmFsaWRhdGVzIGEgc2luZ2xlIG9wZXJhdGlvbi4gQ2FsbGVkIGZyb20gYGpzb25wYXRjaC52YWxpZGF0ZWAuIFRocm93cyBgSnNvblBhdGNoRXJyb3JgIGluIGNhc2Ugb2YgYW4gZXJyb3IuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcGVyYXRpb24gLSBvcGVyYXRpb24gb2JqZWN0IChwYXRjaClcclxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2Ygb3BlcmF0aW9uIGluIHRoZSBzZXF1ZW5jZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gW2RvY3VtZW50XSAtIG9iamVjdCB3aGVyZSB0aGUgb3BlcmF0aW9uIGlzIHN1cHBvc2VkIHRvIGJlIGFwcGxpZWRcclxuICogQHBhcmFtIHtzdHJpbmd9IFtleGlzdGluZ1BhdGhGcmFnbWVudF0gLSBjb21lcyBhbG9uZyB3aXRoIGBkb2N1bWVudGBcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRvcihvcGVyYXRpb24sIGluZGV4LCBkb2N1bWVudCwgZXhpc3RpbmdQYXRoRnJhZ21lbnQpIHtcclxuICAgIGlmICh0eXBlb2Ygb3BlcmF0aW9uICE9PSAnb2JqZWN0JyB8fCBvcGVyYXRpb24gPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShvcGVyYXRpb24pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBpcyBub3QgYW4gb2JqZWN0JywgJ09QRVJBVElPTl9OT1RfQU5fT0JKRUNUJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIW9iak9wc1tvcGVyYXRpb24ub3BdKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgb3BgIHByb3BlcnR5IGlzIG5vdCBvbmUgb2Ygb3BlcmF0aW9ucyBkZWZpbmVkIGluIFJGQy02OTAyJywgJ09QRVJBVElPTl9PUF9JTlZBTElEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIG9wZXJhdGlvbi5wYXRoICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYHBhdGhgIHByb3BlcnR5IGlzIG5vdCBhIHN0cmluZycsICdPUEVSQVRJT05fUEFUSF9JTlZBTElEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3BlcmF0aW9uLnBhdGguaW5kZXhPZignLycpICE9PSAwICYmIG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAvLyBwYXRocyB0aGF0IGFyZW4ndCBlbXB0eSBzdHJpbmcgc2hvdWxkIHN0YXJ0IHdpdGggXCIvXCJcclxuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBwYXRoYCBwcm9wZXJ0eSBtdXN0IHN0YXJ0IHdpdGggXCIvXCInLCAnT1BFUkFUSU9OX1BBVEhfSU5WQUxJRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChvcGVyYXRpb24ub3AgPT09ICdtb3ZlJyB8fCBvcGVyYXRpb24ub3AgPT09ICdjb3B5JykgJiYgdHlwZW9mIG9wZXJhdGlvbi5mcm9tICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYGZyb21gIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IChhcHBsaWNhYmxlIGluIGBtb3ZlYCBhbmQgYGNvcHlgIG9wZXJhdGlvbnMpJywgJ09QRVJBVElPTl9GUk9NX1JFUVVJUkVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gJ2FkZCcgfHwgb3BlcmF0aW9uLm9wID09PSAncmVwbGFjZScgfHwgb3BlcmF0aW9uLm9wID09PSAndGVzdCcpICYmIG9wZXJhdGlvbi52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgdmFsdWVgIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IChhcHBsaWNhYmxlIGluIGBhZGRgLCBgcmVwbGFjZWAgYW5kIGB0ZXN0YCBvcGVyYXRpb25zKScsICdPUEVSQVRJT05fVkFMVUVfUkVRVUlSRUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgob3BlcmF0aW9uLm9wID09PSAnYWRkJyB8fCBvcGVyYXRpb24ub3AgPT09ICdyZXBsYWNlJyB8fCBvcGVyYXRpb24ub3AgPT09ICd0ZXN0JykgJiYgaGVscGVyc18xLmhhc1VuZGVmaW5lZChvcGVyYXRpb24udmFsdWUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgdmFsdWVgIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IChhcHBsaWNhYmxlIGluIGBhZGRgLCBgcmVwbGFjZWAgYW5kIGB0ZXN0YCBvcGVyYXRpb25zKScsICdPUEVSQVRJT05fVkFMVUVfQ0FOTk9UX0NPTlRBSU5fVU5ERUZJTkVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZG9jdW1lbnQpIHtcclxuICAgICAgICBpZiAob3BlcmF0aW9uLm9wID09IFwiYWRkXCIpIHtcclxuICAgICAgICAgICAgdmFyIHBhdGhMZW4gPSBvcGVyYXRpb24ucGF0aC5zcGxpdChcIi9cIikubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdQYXRoTGVuID0gZXhpc3RpbmdQYXRoRnJhZ21lbnQuc3BsaXQoXCIvXCIpLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHBhdGhMZW4gIT09IGV4aXN0aW5nUGF0aExlbiArIDEgJiYgcGF0aExlbiAhPT0gZXhpc3RpbmdQYXRoTGVuKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignQ2Fubm90IHBlcmZvcm0gYW4gYGFkZGAgb3BlcmF0aW9uIGF0IHRoZSBkZXNpcmVkIHBhdGgnLCAnT1BFUkFUSU9OX1BBVEhfQ0FOTk9UX0FERCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICdyZXBsYWNlJyB8fCBvcGVyYXRpb24ub3AgPT09ICdyZW1vdmUnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ19nZXQnKSB7XHJcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ucGF0aCAhPT0gZXhpc3RpbmdQYXRoRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdDYW5ub3QgcGVyZm9ybSB0aGUgb3BlcmF0aW9uIGF0IGEgcGF0aCB0aGF0IGRvZXMgbm90IGV4aXN0JywgJ09QRVJBVElPTl9QQVRIX1VOUkVTT0xWQUJMRScsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICdtb3ZlJyB8fCBvcGVyYXRpb24ub3AgPT09ICdjb3B5Jykge1xyXG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IHsgb3A6IFwiX2dldFwiLCBwYXRoOiBvcGVyYXRpb24uZnJvbSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xyXG4gICAgICAgICAgICB2YXIgZXJyb3IgPSB2YWxpZGF0ZShbZXhpc3RpbmdWYWx1ZV0sIGRvY3VtZW50KTtcclxuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLm5hbWUgPT09ICdPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEUnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignQ2Fubm90IHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBmcm9tIGEgcGF0aCB0aGF0IGRvZXMgbm90IGV4aXN0JywgJ09QRVJBVElPTl9GUk9NX1VOUkVTT0xWQUJMRScsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLnZhbGlkYXRvciA9IHZhbGlkYXRvcjtcclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBhIHNlcXVlbmNlIG9mIG9wZXJhdGlvbnMuIElmIGBkb2N1bWVudGAgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB0aGUgc2VxdWVuY2UgaXMgYWRkaXRpb25hbGx5IHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBvYmplY3QgZG9jdW1lbnQuXHJcbiAqIElmIGVycm9yIGlzIGVuY291bnRlcmVkLCByZXR1cm5zIGEgSnNvblBhdGNoRXJyb3Igb2JqZWN0XHJcbiAqIEBwYXJhbSBzZXF1ZW5jZVxyXG4gKiBAcGFyYW0gZG9jdW1lbnRcclxuICogQHJldHVybnMge0pzb25QYXRjaEVycm9yfHVuZGVmaW5lZH1cclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlKHNlcXVlbmNlLCBkb2N1bWVudCwgZXh0ZXJuYWxWYWxpZGF0b3IpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNlcXVlbmNlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignUGF0Y2ggc2VxdWVuY2UgbXVzdCBiZSBhbiBhcnJheScsICdTRVFVRU5DRV9OT1RfQU5fQVJSQVknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIC8vY2xvbmUgZG9jdW1lbnQgYW5kIHNlcXVlbmNlIHNvIHRoYXQgd2UgY2FuIHNhZmVseSB0cnkgYXBwbHlpbmcgb3BlcmF0aW9uc1xyXG4gICAgICAgICAgICBhcHBseVBhdGNoKGhlbHBlcnNfMS5fZGVlcENsb25lKGRvY3VtZW50KSwgaGVscGVyc18xLl9kZWVwQ2xvbmUoc2VxdWVuY2UpLCBleHRlcm5hbFZhbGlkYXRvciB8fCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGV4dGVybmFsVmFsaWRhdG9yID0gZXh0ZXJuYWxWYWxpZGF0b3IgfHwgdmFsaWRhdG9yO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcXVlbmNlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvcihzZXF1ZW5jZVtpXSwgaSwgZG9jdW1lbnQsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9mYXN0LWpzb24tcGF0Y2gvbGliL2NvcmUuanMiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkNBO0FBeUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZCQTtBQXlCQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBM0NBO0FBNkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/*!*********************!*\
  !*** ./src/tagl.js ***!
  \*********************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction noop() {}\n\nmodule.exports = function (h) {\n  function createProxy(tagName) {\n    return new Proxy(noop, {\n      apply: function apply(_, __, args) {\n        return h.apply(undefined, [tagName, []].concat(_toConsumableArray(args)));\n      },\n      get: function get(_, className) {\n        var classNames = [className];\n        var proxy = new Proxy(noop, {\n          get: function get(_, className) {\n            classNames.push(className);\n            return proxy;\n          },\n          apply: function apply(_, __, args) {\n            return h.apply(undefined, [tagName, classNames].concat(_toConsumableArray(args)));\n          }\n        });\n        return proxy;\n      }\n    });\n  }\n\n  return new Proxy(function (component) {\n    return createProxy(component);\n  }, {\n    get: function get(components, tagName) {\n      return createProxy(components[tagName] || tagName);\n    }\n  });\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdGFnbC5qcz8wYjkzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGgpIHtcbiAgZnVuY3Rpb24gY3JlYXRlUHJveHkodGFnTmFtZSkge1xuICAgIHJldHVybiBuZXcgUHJveHkobm9vcCwge1xuICAgICAgYXBwbHk6IChfLCBfXywgYXJncykgPT4gaCh0YWdOYW1lLCBbXSwgLi4uYXJncyksXG4gICAgICBnZXQ6IChfLCBjbGFzc05hbWUpID0+IHtcbiAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IFtjbGFzc05hbWVdXG4gICAgICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KG5vb3AsIHtcbiAgICAgICAgICBnZXQoXywgY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goY2xhc3NOYW1lKVxuICAgICAgICAgICAgcmV0dXJuIHByb3h5XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhcHBseShfLCBfXywgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGgodGFnTmFtZSwgY2xhc3NOYW1lcywgLi4uYXJncylcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gcHJveHlcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJveHkoY29tcG9uZW50ID0+IGNyZWF0ZVByb3h5KGNvbXBvbmVudCksIHtcbiAgICBnZXQ6IChjb21wb25lbnRzLCB0YWdOYW1lKSA9PiBjcmVhdGVQcm94eShjb21wb25lbnRzW3RhZ05hbWVdIHx8IHRhZ05hbWUpLFxuICB9KVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdGFnbC5qcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQWRBO0FBZ0JBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUdBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _get15_ = __webpack_require__(/*! ./get15_1 */ 12);\n\nvar get15_1 = _interopRequireWildcard(_get15_);\n\nvar _get15_2 = __webpack_require__(/*! ./get15_2 */ 14);\n\nvar get15_2 = _interopRequireWildcard(_get15_2);\n\nvar _set = __webpack_require__(/*! ./set */ 15);\n\nvar set = _interopRequireWildcard(_set);\n\nvar _max_non_sets = __webpack_require__(/*! ./max_non_sets */ 16);\n\nvar max_non_sets = _interopRequireWildcard(_max_non_sets);\n\nvar _todo = __webpack_require__(/*! ./todo */ 17);\n\nvar todo = _interopRequireWildcard(_todo);\n\nvar _queens = __webpack_require__(/*! ./queens */ 18);\n\nvar queens = _interopRequireWildcard(_queens);\n\nvar _blackbox = __webpack_require__(/*! ./blackbox */ 19);\n\nvar blackbox = _interopRequireWildcard(_blackbox);\n\nvar _dragdrop = __webpack_require__(/*! ./dragdrop */ 20);\n\nvar dragdrop = _interopRequireWildcard(_dragdrop);\n\nvar _computesquare = __webpack_require__(/*! ./computesquare */ 22);\n\nvar computesquare = _interopRequireWildcard(_computesquare);\n\nvar _ships = __webpack_require__(/*! ./ships */ 23);\n\nvar ships = _interopRequireWildcard(_ships);\n\nvar _waves = __webpack_require__(/*! ./waves */ 30);\n\nvar waves = _interopRequireWildcard(_waves);\n\nvar _secret = __webpack_require__(/*! ./secret */ 31);\n\nvar secret = _interopRequireWildcard(_secret);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar links = [{\n  link: \"/queens\",\n  text: \"Queens\",\n  component: queens.default\n},\n/*{\n         link: '/15',\n         text: '15',\n         component: get15_1.default\n     },*/\n{\n  link: \"/15\",\n  text: \"15\",\n  component: get15_2.default\n}, {\n  link: \"/set\",\n  text: \"Set\",\n  component: set.default\n}, {\n  link: \"/todo\",\n  text: \"Todo\",\n  component: todo.default\n}, {\n  link: \"/blackbox\",\n  text: \"Blackbox\",\n  component: blackbox.default\n}, {\n  link: \"/dragndrop\",\n  text: \"DragNDrop\",\n  component: dragdrop.default\n}, {\n  link: \"/computesquare\",\n  text: \"ComputeSquare\",\n  component: computesquare.default\n}, { link: \"/ships\", text: \"Ships\", component: ships.default }, { link: \"/waves\", text: \"Waves\", component: waves.default }, { link: \"/secret\", text: \"Secret\", component: secret.default }];\n\nvar Router = function () {\n  function Router() {\n    _classCallCheck(this, Router);\n  }\n\n  _createClass(Router, [{\n    key: \"oncreate\",\n    value: function oncreate(vnode) {\n      _mithril2.default.route(vnode.dom, \"/queens\", links.reduce(function (acc, _ref) {\n        var link = _ref.link,\n            component = _ref.component;\n\n        acc[link] = component;\n        return acc;\n      }, {}));\n    }\n  }, {\n    key: \"view\",\n    value: function view(vnode) {\n      return (0, _mithril2.default)(\"\");\n    }\n  }]);\n\n  return Router;\n}();\n\nvar Navbar = function () {\n  function Navbar() {\n    _classCallCheck(this, Navbar);\n  }\n\n  _createClass(Navbar, [{\n    key: \"view\",\n    value: function view(vnode) {\n      return (0, _mithril2.default)(\"nav.navbar.navbar-default\", (0, _mithril2.default)(\".container-fluid\", (0, _mithril2.default)(\".navbar-header\", (0, _mithril2.default)(\"ul.nav.navbar-nav\", [links.map(function (link) {\n        return (0, _mithril2.default)(\"li\", (0, _mithril2.default)(\"a[href=#!\" + link.link + \"]\", link.text));\n      })]))));\n    }\n  }]);\n\n  return Navbar;\n}();\n\n_mithril2.default.mount(document.body, {\n  view: function view(vnode) {\n    return [(0, _mithril2.default)(Navbar), (0, _mithril2.default)(Router)];\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvaW5kZXguanM/MWZkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tIFwibWl0aHJpbFwiO1xuaW1wb3J0ICogYXMgZ2V0MTVfMSBmcm9tIFwiLi9nZXQxNV8xXCI7XG5pbXBvcnQgKiBhcyBnZXQxNV8yIGZyb20gXCIuL2dldDE1XzJcIjtcbmltcG9ydCAqIGFzIHNldCBmcm9tIFwiLi9zZXRcIjtcbmltcG9ydCAqIGFzIG1heF9ub25fc2V0cyBmcm9tIFwiLi9tYXhfbm9uX3NldHNcIjtcbmltcG9ydCAqIGFzIHRvZG8gZnJvbSBcIi4vdG9kb1wiO1xuaW1wb3J0ICogYXMgcXVlZW5zIGZyb20gXCIuL3F1ZWVuc1wiO1xuaW1wb3J0ICogYXMgYmxhY2tib3ggZnJvbSBcIi4vYmxhY2tib3hcIjtcbmltcG9ydCAqIGFzIGRyYWdkcm9wIGZyb20gXCIuL2RyYWdkcm9wXCI7XG5pbXBvcnQgKiBhcyBjb21wdXRlc3F1YXJlIGZyb20gXCIuL2NvbXB1dGVzcXVhcmVcIjtcbmltcG9ydCAqIGFzIHNoaXBzIGZyb20gXCIuL3NoaXBzXCI7XG5pbXBvcnQgKiBhcyB3YXZlcyBmcm9tIFwiLi93YXZlc1wiO1xuaW1wb3J0ICogYXMgc2VjcmV0IGZyb20gXCIuL3NlY3JldFwiO1xuXG52YXIgbGlua3MgPSBbXG4gIHtcbiAgICBsaW5rOiBcIi9xdWVlbnNcIixcbiAgICB0ZXh0OiBcIlF1ZWVuc1wiLFxuICAgIGNvbXBvbmVudDogcXVlZW5zLmRlZmF1bHRcbiAgfSxcbiAgLyp7XG4gICAgICAgICAgIGxpbms6ICcvMTUnLFxuICAgICAgICAgICB0ZXh0OiAnMTUnLFxuICAgICAgICAgICBjb21wb25lbnQ6IGdldDE1XzEuZGVmYXVsdFxuICAgICAgIH0sKi9cbiAge1xuICAgIGxpbms6IFwiLzE1XCIsXG4gICAgdGV4dDogXCIxNVwiLFxuICAgIGNvbXBvbmVudDogZ2V0MTVfMi5kZWZhdWx0XG4gIH0sXG4gIHtcbiAgICBsaW5rOiBcIi9zZXRcIixcbiAgICB0ZXh0OiBcIlNldFwiLFxuICAgIGNvbXBvbmVudDogc2V0LmRlZmF1bHRcbiAgfSxcbiAge1xuICAgIGxpbms6IFwiL3RvZG9cIixcbiAgICB0ZXh0OiBcIlRvZG9cIixcbiAgICBjb21wb25lbnQ6IHRvZG8uZGVmYXVsdFxuICB9LFxuICB7XG4gICAgbGluazogXCIvYmxhY2tib3hcIixcbiAgICB0ZXh0OiBcIkJsYWNrYm94XCIsXG4gICAgY29tcG9uZW50OiBibGFja2JveC5kZWZhdWx0XG4gIH0sXG4gIHtcbiAgICBsaW5rOiBcIi9kcmFnbmRyb3BcIixcbiAgICB0ZXh0OiBcIkRyYWdORHJvcFwiLFxuICAgIGNvbXBvbmVudDogZHJhZ2Ryb3AuZGVmYXVsdFxuICB9LFxuICB7XG4gICAgbGluazogXCIvY29tcHV0ZXNxdWFyZVwiLFxuICAgIHRleHQ6IFwiQ29tcHV0ZVNxdWFyZVwiLFxuICAgIGNvbXBvbmVudDogY29tcHV0ZXNxdWFyZS5kZWZhdWx0XG4gIH0sXG4gIHsgbGluazogXCIvc2hpcHNcIiwgdGV4dDogXCJTaGlwc1wiLCBjb21wb25lbnQ6IHNoaXBzLmRlZmF1bHQgfSxcbiAgeyBsaW5rOiBcIi93YXZlc1wiLCB0ZXh0OiBcIldhdmVzXCIsIGNvbXBvbmVudDogd2F2ZXMuZGVmYXVsdCB9LFxuICB7IGxpbms6IFwiL3NlY3JldFwiLCB0ZXh0OiBcIlNlY3JldFwiLCBjb21wb25lbnQ6IHNlY3JldC5kZWZhdWx0IH1cbl07XG5cbmNsYXNzIFJvdXRlciB7XG4gIG9uY3JlYXRlKHZub2RlKSB7XG4gICAgbS5yb3V0ZShcbiAgICAgIHZub2RlLmRvbSxcbiAgICAgIFwiL3F1ZWVuc1wiLFxuICAgICAgbGlua3MucmVkdWNlKChhY2MsIHsgbGluaywgY29tcG9uZW50IH0pID0+IHtcbiAgICAgICAgYWNjW2xpbmtdID0gY29tcG9uZW50O1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pXG4gICAgKTtcbiAgfVxuICB2aWV3KHZub2RlKSB7XG4gICAgcmV0dXJuIG0oXCJcIik7XG4gIH1cbn1cblxuY2xhc3MgTmF2YmFyIHtcbiAgdmlldyh2bm9kZSkge1xuICAgIHJldHVybiBtKFxuICAgICAgXCJuYXYubmF2YmFyLm5hdmJhci1kZWZhdWx0XCIsXG4gICAgICBtKFxuICAgICAgICBcIi5jb250YWluZXItZmx1aWRcIixcbiAgICAgICAgbShcbiAgICAgICAgICBcIi5uYXZiYXItaGVhZGVyXCIsXG4gICAgICAgICAgbShcInVsLm5hdi5uYXZiYXItbmF2XCIsIFtcbiAgICAgICAgICAgIGxpbmtzLm1hcChsaW5rID0+XG4gICAgICAgICAgICAgIG0oXCJsaVwiLCBtKFwiYVtocmVmPSMhXCIgKyBsaW5rLmxpbmsgKyBcIl1cIiwgbGluay50ZXh0KSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICBdKVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxufVxuXG5tLm1vdW50KGRvY3VtZW50LmJvZHksIHtcbiAgdmlldzogdm5vZGUgPT4gW20oTmF2YmFyKSwgbShSb3V0ZXIpXVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFTQTs7Ozs7OztBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTs7Ozs7OztBQUNBO0FBQ0E7QUFPQTtBQUFBO0FBT0E7Ozs7OztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBREEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar scope = typeof global !== \"undefined\" && global || typeof self !== \"undefined\" && self || window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function () {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function () {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout = exports.clearInterval = function (timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function () {};\nTimeout.prototype.close = function () {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function (item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function (item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout) item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ 10);\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = typeof self !== \"undefined\" && self.setImmediate || typeof global !== \"undefined\" && global.setImmediate || undefined && undefined.setImmediate;\nexports.clearImmediate = typeof self !== \"undefined\" && self.clearImmediate || typeof global !== \"undefined\" && global.clearImmediate || undefined && undefined.clearImmediate;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ 3)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz82YmFhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {\n\n(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n        // Callback can either be a function or a string\n        if (typeof callback !== \"function\") {\n            callback = new Function(\"\" + callback);\n        }\n        // Copy function arguments\n        var args = new Array(arguments.length - 1);\n        for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i + 1];\n        }\n        // Store and register the task\n        var task = { callback: callback, args: args };\n        tasksByHandle[nextHandle] = task;\n        registerImmediate(nextHandle);\n        return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n            case 0:\n                callback();\n                break;\n            case 1:\n                callback(args[0]);\n                break;\n            case 2:\n                callback(args[0], args[1]);\n                break;\n            case 3:\n                callback(args[0], args[1], args[2]);\n                break;\n            default:\n                callback.apply(undefined, args);\n                break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function registerImmediate(handle) {\n            process.nextTick(function () {\n                runIfPresent(handle);\n            });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function () {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function onGlobalMessage(event) {\n            if (event.source === global && typeof event.data === \"string\" && event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function registerImmediate(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function (event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function registerImmediate(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function registerImmediate(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function registerImmediate(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n})(typeof self === \"undefined\" ? typeof global === \"undefined\" ? undefined : global : self);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ 3), __webpack_require__(/*! ./../process/browser.js */ 11)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanM/MGM4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n    return [];\n};\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz84MzkyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/*!************************!*\
  !*** ./src/get15_1.js ***!
  \************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _underscore = __webpack_require__(/*! underscore */ 1);\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar targetNumber = 15;\n\nvar inputs = [{\n    key: 0,\n    number: 1\n}, {\n    key: 1,\n    number: 1\n}, {\n    key: 2,\n    number: 1\n}];\n\nvar fac = function fac(n) {\n    var s = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return n <= 1 ? s : fac(n - 1, s * n);\n};\n\nvar fcns = [{\n    name: '+',\n    fcn: function fcn(x, y) {\n        return x + y;\n    },\n    wrap: function wrap(x, y) {\n        return '(' + x + ' + ' + y + ')';\n    },\n    inv: function inv(x, y) {\n        return x - y;\n    }\n}, {\n    name: '-',\n    fcn: function fcn(x, y) {\n        return x - y;\n    },\n    wrap: function wrap(x, y) {\n        return '(' + x + ' - ' + y + ')';\n    },\n    inv: function inv(x, y) {\n        return x + y;\n    }\n}, {\n    name: '*',\n    fcn: function fcn(x, y) {\n        return x * y;\n    },\n    wrap: function wrap(x, y) {\n        return '(' + x + ' * ' + y + ')';\n    },\n    inv: function inv(x, y) {\n        return x / y;\n    }\n}, {\n    name: '/',\n    fcn: function fcn(x, y) {\n        return x / y;\n    },\n    wrap: function wrap(x, y) {\n        return '(' + x + ' / ' + y + ')';\n    },\n    inv: function inv(x, y) {\n        return x * y;\n    }\n}, {\n    name: '**',\n    fcn: function fcn(x, y) {\n        return Math.pow(x, y);\n    },\n    wrap: function wrap(x, y) {\n        return '(' + x + ' ** ' + y + ')';\n    },\n    inv: function inv(x, y) {\n        return Math.pow(x, 1 / y);\n    }\n}, {\n    name: '**1/',\n    fcn: function fcn(x, y) {\n        return Math.pow(x, 1 / y);\n    },\n    wrap: function wrap(x, y) {\n        return '(' + x + ' **1/ ' + y + ')';\n    },\n    inv: function inv(x, y) {\n        return Math.pow(x, y);\n    }\n}, {\n    name: 'mean',\n    fcn: function fcn(x, y) {\n        return (x + y) / 2;\n    },\n    wrap: function wrap(x, y) {\n        return 'mean(' + x + ' , ' + y + ')';\n    },\n    inv: function inv(x, y) {\n        return Math.pow(x, y);\n    }\n}, {\n    name: 'over',\n    fcn: function fcn(x, y) {\n        return fac(x) / fac(y) / fac(x - y);\n    },\n    wrap: function wrap(x, y) {\n        return '(' + x + ' over ' + y + ')';\n    },\n    inv: function inv(x, y) {\n        return Math.pow(x, y);\n    }\n}];\n\nvar unaryFcns = [{\n    name: 'id',\n    fcn: function fcn(x) {\n        return x;\n    },\n    wrap: function wrap(x) {\n        return x;\n    }\n}];\n\nvar permut = function permut(a) {\n    if (a.length === 1) return a;\n    var result = [];\n    a.forEach(function (e, idx) {\n        var c = a.slice();\n        c.splice(idx, 1);\n        var r = permut(c);\n        r.forEach(function (el) {\n            return result.push(_underscore2.default.flatten([e, el]));\n        });\n    });\n    return result;\n};\n\nvar getTwo = function getTwo(a) {\n    var result = [];\n    a.forEach(function (e1) {\n        return a.map(function (e2) {\n            return result.push([e1, e2]);\n        });\n    });\n    return result;\n};\n\nvar getThree = function getThree(a) {\n    var result = [];\n    a.forEach(function (e1) {\n        return a.map(function (e2) {\n            return a.map(function (e3) {\n                return result.push([e1, e2, e3]);\n            });\n        });\n    });\n    return result;\n};\n\nvar getFive = function getFive(a) {\n    var result = [];\n    a.forEach(function (e1) {\n        return a.map(function (e2) {\n            return a.map(function (e3) {\n                return a.map(function (e4) {\n                    return a.map(function (e5) {\n                        return result.push([e1, e2, e3, e4, e5]);\n                    });\n                });\n            });\n        });\n    });\n    return result;\n};\n\nvar closest = [];\nvar simplesolution = [];\n\nvar solve_ = function solve_(numbers) {\n    var twoops = getTwo(fcns);\n    var unopNum = getThree(unaryFcns);\n    var unopFns = getTwo(unaryFcns);\n\n    simplesolution = [];\n    closest = [];\n    var c = 0;\n    permut(numbers).forEach(function (arr_) {\n        twoops.forEach(function (twoop) {\n            unopNum.forEach(function (unop) {\n                var arr = function arr(fp) {\n                    return arr_.map(function (e, idx) {\n                        return unop[idx][fp](e);\n                    });\n                };\n                var a_bc = function a_bc(f, g, fp) {\n                    return function (a0, a1, a2) {\n                        return f[fp](a0[fp], g[fp](a1[fp], a2[fp]));\n                    };\n                };\n                var ab_c = function ab_c(f, g, fp) {\n                    return function (a0, a1, a2) {\n                        return f[fp](g[fp](a0[fp], a1[fp]), a2[fp]);\n                    };\n                };\n                var comps = [a_bc, ab_c];\n                comps.forEach(function (comp) {\n                    var evaluate = function evaluate(member) {\n                        return comp.apply(undefined, _toConsumableArray(twoop).concat([member])).apply(undefined, _toConsumableArray(arr(member)));\n                    };\n                    c++;\n                    var stringResult = evaluate('wrap');\n                    var result = evaluate('fcn');\n                    if (result === targetNumber) {\n                        simplesolution.push(stringResult);\n                    } else {\n                        closest.push({\n                            diff: Math.abs(result - targetNumber),\n                            text: stringResult\n                        });\n                    }\n                });\n            });\n        });\n    });\n    closest = _underscore2.default.sortBy(closest, 'diff');\n    console.log('tested', c, 'combinations');\n};\n\nvar solve = function solve(numbers) {\n    var twoops = getTwo(fcns);\n    var unops = getFive(unaryFcns);\n    simplesolution = [];\n    closest = [];\n    var c = 0;\n\n    permut(numbers).forEach(function (arr) {\n        twoops.forEach(function (twoop) {\n            var a_bc = function a_bc(f, g, fp) {\n                return function (a0, a1, a2) {\n                    return f[fp](a0, g[fp](a1, a2));\n                };\n            };\n            var ab_c = function ab_c(f, g, fp) {\n                return function (a0, a1, a2) {\n                    return f[fp](g[fp](a0, a1), a2);\n                };\n            };\n            var comps = [a_bc, ab_c];\n            comps.forEach(function (comp) {\n                c++;\n\n                var result = comp.apply(undefined, _toConsumableArray(twoop).concat(['fcn'])).apply(undefined, _toConsumableArray(arr));\n                if (result === targetNumber) {\n                    simplesolution.push(comp.apply(undefined, _toConsumableArray(twoop).concat(['wrap'])).apply(undefined, _toConsumableArray(arr)));\n                } else {\n                    closest.push({\n                        diff: Math.abs(result - targetNumber),\n                        text: comp.apply(undefined, _toConsumableArray(twoop).concat(['wrap'])).apply(undefined, _toConsumableArray(arr))\n                    });\n                }\n            });\n        });\n    });\n    closest = _underscore2.default.sortBy(closest, 'diff');\n    console.log('tested', c, 'combinations');\n};\n\nvar DiceInput = function () {\n    function DiceInput(vnode) {\n        _classCallCheck(this, DiceInput);\n\n        this.numbers = [1, 2, 3, 4, 5, 6];\n    }\n\n    _createClass(DiceInput, [{\n        key: 'view',\n        value: function view(vnode) {\n            return (0, _mithril2.default)('table', (0, _mithril2.default)('tr', _underscore2.default.map(this.numbers, function (n) {\n                return (0, _mithril2.default)('td', (0, _mithril2.default)('button', {\n                    style: _underscore2.default.find(inputs, function (i) {\n                        return i.key === vnode.attrs.key;\n                    }).number === n ? 'background-color:red' : '',\n                    onclick: vnode.attrs.onchange(n)\n                }, n));\n            })));\n        }\n    }]);\n\n    return DiceInput;\n}();\n\nvar setInput = function setInput(inputNumber) {\n    return function (selectedNumber) {\n        return function () {\n            _underscore2.default.find(inputs, function (i) {\n                return i.key === inputNumber;\n            }).number = selectedNumber;\n            solve(_underscore2.default.pluck(inputs, 'number'));\n        };\n    };\n};\n\nfunction findSolution(target) {\n    function find(current, history) {\n        if (current == target) return history;else if (current > target) return null;else return find(current + 5, \"(\" + history + \" + 5)\") || find(current * 3, \"(\" + history + \" * 3)\");\n    }\n    return find(1, \"1\");\n}\n\nvar Router = function () {\n    function Router() {\n        _classCallCheck(this, Router);\n    }\n\n    _createClass(Router, [{\n        key: 'view',\n        value: function view(vnode) {\n            return [(0, _mithril2.default)('h1', '15-15-15-15'), _underscore2.default.map(inputs, function (i) {\n                return [(0, _mithril2.default)(DiceInput, {\n                    key: i.key,\n                    number: i.number,\n                    onchange: setInput(i.key)\n                })];\n            }), simplesolution.map(function (solution) {\n                return (0, _mithril2.default)('pre', solution);\n            }), (0, _mithril2.default)('hr'), _underscore2.default.first(closest, 30).map(function (solution) {\n                return (0, _mithril2.default)('pre', JSON.stringify(solution.diff) + ': ' + JSON.stringify(solution.text));\n            })];\n        }\n    }]);\n\n    return Router;\n}();\n\nexports.default = Router;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2dldDE1XzEuanM/NGQ2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcbmltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG52YXIgdGFyZ2V0TnVtYmVyID0gMTU7XG5cbnZhciBpbnB1dHMgPSBbe1xuICAgIGtleTogMCxcbiAgICBudW1iZXI6IDFcbn0sIHtcbiAgICBrZXk6IDEsXG4gICAgbnVtYmVyOiAxXG59LCB7XG4gICAga2V5OiAyLFxuICAgIG51bWJlcjogMVxufV07XG5cbnZhciBmYWMgPSAobiwgcyA9IDEpID0+IChuIDw9IDEpID8gcyA6IGZhYyhuIC0gMSwgcyAqIG4pO1xuXG52YXIgZmNucyA9IFtcbiAgICB7XG4gICAgICAgIG5hbWU6ICcrJyxcbiAgICAgICAgZmNuOiAoeCwgeSkgPT4geCArIHksXG4gICAgICAgIHdyYXA6ICh4LCB5KSA9PiAnKCcgKyB4ICsgJyArICcgKyB5ICsgJyknLFxuICAgICAgICBpbnY6ICh4LCB5KSA9PiB4IC0geVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogJy0nLFxuICAgICAgICBmY246ICh4LCB5KSA9PiB4IC0geSxcbiAgICAgICAgd3JhcDogKHgsIHkpID0+ICcoJyArIHggKyAnIC0gJyArIHkgKyAnKScsXG4gICAgICAgIGludjogKHgsIHkpID0+IHggKyB5XG4gICAgfSwge1xuICAgICAgICBuYW1lOiAnKicsXG4gICAgICAgIGZjbjogKHgsIHkpID0+IHggKiB5LFxuICAgICAgICB3cmFwOiAoeCwgeSkgPT4gJygnICsgeCArICcgKiAnICsgeSArICcpJyxcbiAgICAgICAgaW52OiAoeCwgeSkgPT4geCAvIHlcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6ICcvJyxcbiAgICAgICAgZmNuOiAoeCwgeSkgPT4geCAvIHksXG4gICAgICAgIHdyYXA6ICh4LCB5KSA9PiAnKCcgKyB4ICsgJyAvICcgKyB5ICsgJyknLFxuICAgICAgICBpbnY6ICh4LCB5KSA9PiB4ICogeVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogJyoqJyxcbiAgICAgICAgZmNuOiAoeCwgeSkgPT4gTWF0aC5wb3coeCwgeSksXG4gICAgICAgIHdyYXA6ICh4LCB5KSA9PiAnKCcgKyB4ICsgJyAqKiAnICsgeSArICcpJyxcbiAgICAgICAgaW52OiAoeCwgeSkgPT4gTWF0aC5wb3coeCwgMSAvIHkpXG4gICAgfSwge1xuICAgICAgICBuYW1lOiAnKioxLycsXG4gICAgICAgIGZjbjogKHgsIHkpID0+IE1hdGgucG93KHgsIDEgLyB5KSxcbiAgICAgICAgd3JhcDogKHgsIHkpID0+ICcoJyArIHggKyAnICoqMS8gJyArIHkgKyAnKScsXG4gICAgICAgIGludjogKHgsIHkpID0+IE1hdGgucG93KHgsIHkpXG4gICAgfSwge1xuICAgICAgICBuYW1lOiAnbWVhbicsXG4gICAgICAgIGZjbjogKHgsIHkpID0+ICh4ICsgeSkgLyAyLFxuICAgICAgICB3cmFwOiAoeCwgeSkgPT4gJ21lYW4oJyArIHggKyAnICwgJyArIHkgKyAnKScsXG4gICAgICAgIGludjogKHgsIHkpID0+IE1hdGgucG93KHgsIHkpXG4gICAgfSwge1xuICAgICAgICBuYW1lOiAnb3ZlcicsXG4gICAgICAgIGZjbjogKHgsIHkpID0+IGZhYyh4KSAvIGZhYyh5KSAvIGZhYyh4IC0geSksXG4gICAgICAgIHdyYXA6ICh4LCB5KSA9PiAnKCcgKyB4ICsgJyBvdmVyICcgKyB5ICsgJyknLFxuICAgICAgICBpbnY6ICh4LCB5KSA9PiBNYXRoLnBvdyh4LCB5KVxuICAgIH1cbl07XG5cbnZhciB1bmFyeUZjbnMgPSBbXG4gICAge1xuICAgICAgICBuYW1lOiAnaWQnLFxuICAgICAgICBmY246IHggPT4geCxcbiAgICAgICAgd3JhcDogeCA9PiB4XG4gICAgfVxuXTtcblxudmFyIHBlcm11dCA9IGEgPT4ge1xuICAgIGlmIChhLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGEuZm9yRWFjaCgoZSwgaWR4KSA9PiB7XG4gICAgICAgIGxldCBjID0gYS5zbGljZSgpO1xuICAgICAgICBjLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB2YXIgciA9IHBlcm11dChjKTtcbiAgICAgICAgci5mb3JFYWNoKGVsID0+IHJlc3VsdC5wdXNoKF8uZmxhdHRlbihbZSwgZWxdKSkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgZ2V0VHdvID0gYSA9PiB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGEuZm9yRWFjaChlMSA9PiBhLm1hcChlMiA9PiByZXN1bHQucHVzaChbZTEsIGUyXSkpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGdldFRocmVlID0gYSA9PiB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGEuZm9yRWFjaChlMSA9PiBhLm1hcChlMiA9PiBhLm1hcChlMyA9PiByZXN1bHQucHVzaChbZTEsIGUyLCBlM10pKSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgZ2V0Rml2ZSA9IGEgPT4ge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBhLmZvckVhY2goZTEgPT5cbiAgICAgICAgYS5tYXAoZTIgPT5cbiAgICAgICAgICAgIGEubWFwKGUzID0+XG4gICAgICAgICAgICAgICAgYS5tYXAoZTQgPT5cbiAgICAgICAgICAgICAgICAgICAgYS5tYXAoZTUgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtlMSwgZTIsIGUzLCBlNCwgZTVdKSkpKSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgY2xvc2VzdCA9IFtdO1xudmFyIHNpbXBsZXNvbHV0aW9uID0gW107XG5cbnZhciBzb2x2ZV8gPSAobnVtYmVycykgPT4ge1xuICAgIHZhciB0d29vcHMgPSBnZXRUd28oZmNucyk7XG4gICAgdmFyIHVub3BOdW0gPSBnZXRUaHJlZSh1bmFyeUZjbnMpO1xuICAgIHZhciB1bm9wRm5zID0gZ2V0VHdvKHVuYXJ5RmNucyk7XG5cbiAgICBzaW1wbGVzb2x1dGlvbiA9IFtdO1xuICAgIGNsb3Nlc3QgPSBbXTtcbiAgICB2YXIgYyA9IDA7XG4gICAgcGVybXV0KG51bWJlcnMpLmZvckVhY2goYXJyXyA9PiB7XG4gICAgICAgIHR3b29wcy5mb3JFYWNoKHR3b29wID0+IHtcbiAgICAgICAgICAgIHVub3BOdW0uZm9yRWFjaCh1bm9wID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgYXJyID0gKGZwKSA9PiBhcnJfLm1hcCgoZSwgaWR4KSA9PiB1bm9wW2lkeF1bZnBdKGUpKTtcbiAgICAgICAgICAgICAgICB2YXIgYV9iYyA9IChmLCBnLCBmcCkgPT4gKGEwLCBhMSwgYTIpID0+IGZbZnBdKGEwW2ZwXSwgZ1tmcF0oYTFbZnBdLCBhMltmcF0pKTtcbiAgICAgICAgICAgICAgICB2YXIgYWJfYyA9IChmLCBnLCBmcCkgPT4gKGEwLCBhMSwgYTIpID0+IGZbZnBdKGdbZnBdKGEwW2ZwXSwgYTFbZnBdKSwgYTJbZnBdKTtcbiAgICAgICAgICAgICAgICB2YXIgY29tcHMgPSBbYV9iYywgYWJfY107XG4gICAgICAgICAgICAgICAgY29tcHMuZm9yRWFjaChjb21wID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2YWx1YXRlID0gbWVtYmVyID0+IGNvbXAoLi4udHdvb3AsIG1lbWJlcikoLi4uYXJyKG1lbWJlcikpXG4gICAgICAgICAgICAgICAgICAgIGMrKztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0cmluZ1Jlc3VsdCA9IGV2YWx1YXRlKCd3cmFwJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBldmFsdWF0ZSgnZmNuJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHRhcmdldE51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2ltcGxlc29sdXRpb24ucHVzaChzdHJpbmdSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmOiBNYXRoLmFicyhyZXN1bHQgLSB0YXJnZXROdW1iZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHN0cmluZ1Jlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBjbG9zZXN0ID0gXy5zb3J0QnkoY2xvc2VzdCwgJ2RpZmYnKTtcbiAgICBjb25zb2xlLmxvZygndGVzdGVkJyxjLCdjb21iaW5hdGlvbnMnKVxuXG59O1xuXG5cbnZhciBzb2x2ZSA9IChudW1iZXJzKSA9PiB7XG4gICAgdmFyIHR3b29wcyA9IGdldFR3byhmY25zKTtcbiAgICB2YXIgdW5vcHMgPSBnZXRGaXZlKHVuYXJ5RmNucyk7XG4gICAgc2ltcGxlc29sdXRpb24gPSBbXTtcbiAgICBjbG9zZXN0ID0gW107XG4gICAgdmFyIGMgPSAwO1xuXG4gICAgcGVybXV0KG51bWJlcnMpLmZvckVhY2goYXJyID0+IHtcbiAgICAgICAgdHdvb3BzLmZvckVhY2godHdvb3AgPT4ge1xuICAgICAgICAgICAgdmFyIGFfYmMgPSAoZiwgZywgZnApID0+IChhMCwgYTEsIGEyKSA9PiBmW2ZwXShhMCwgZ1tmcF0oYTEsIGEyKSk7XG4gICAgICAgICAgICB2YXIgYWJfYyA9IChmLCBnLCBmcCkgPT4gKGEwLCBhMSwgYTIpID0+IGZbZnBdKGdbZnBdKGEwLCBhMSksIGEyKTtcbiAgICAgICAgICAgIHZhciBjb21wcyA9IFthX2JjLCBhYl9jXTtcbiAgICAgICAgICAgIGNvbXBzLmZvckVhY2goY29tcCA9PiB7XG4gICAgICAgICAgICAgICAgYysrO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXAoLi4udHdvb3AsICdmY24nKSguLi5hcnIpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHRhcmdldE51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBzaW1wbGVzb2x1dGlvbi5wdXNoKGNvbXAoLi4udHdvb3AsICd3cmFwJykoLi4uYXJyKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmY6IE1hdGguYWJzKHJlc3VsdCAtIHRhcmdldE51bWJlciksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjb21wKC4uLnR3b29wLCAnd3JhcCcpKC4uLmFycilcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNsb3Nlc3QgPSBfLnNvcnRCeShjbG9zZXN0LCAnZGlmZicpO1xuICAgIGNvbnNvbGUubG9nKCd0ZXN0ZWQnLGMsJ2NvbWJpbmF0aW9ucycpXG5cbn07XG5cbmNsYXNzIERpY2VJbnB1dCB7XG4gICAgY29uc3RydWN0b3Iodm5vZGUpIHtcbiAgICAgICAgdGhpcy5udW1iZXJzID0gWzEsIDIsIDMsIDQsIDUsIDZdO1xuICAgIH1cbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIHJldHVybiBtKCd0YWJsZScsIG0oJ3RyJyxcbiAgICAgICAgICAgIF8ubWFwKHRoaXMubnVtYmVycywgbiA9PiBtKCd0ZCcsIG0oJ2J1dHRvbicsIHtcbiAgICAgICAgICAgICAgICBzdHlsZTogKF8uZmluZChpbnB1dHMsIGkgPT4gaS5rZXkgPT09IHZub2RlLmF0dHJzLmtleSkubnVtYmVyID09PSBuKSA/XG4gICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yOnJlZCcgOiAnJyxcbiAgICAgICAgICAgICAgICBvbmNsaWNrOiB2bm9kZS5hdHRycy5vbmNoYW5nZShuKVxuICAgICAgICAgICAgfSwgbikpKSlcbiAgICAgICAgKTtcbiAgICB9XG59XG5cbnZhciBzZXRJbnB1dCA9IGlucHV0TnVtYmVyID0+IHNlbGVjdGVkTnVtYmVyID0+ICgpID0+IHtcbiAgICBfLmZpbmQoaW5wdXRzLCBpID0+IGkua2V5ID09PSBpbnB1dE51bWJlcikubnVtYmVyID0gc2VsZWN0ZWROdW1iZXI7XG4gICAgc29sdmUoXy5wbHVjayhpbnB1dHMsICdudW1iZXInKSk7XG59O1xuXG5mdW5jdGlvbiBmaW5kU29sdXRpb24odGFyZ2V0KSB7XG4gICAgZnVuY3Rpb24gZmluZChjdXJyZW50LCBoaXN0b3J5KSB7XG4gICAgICAgIGlmIChjdXJyZW50ID09IHRhcmdldClcbiAgICAgICAgICAgIHJldHVybiBoaXN0b3J5O1xuICAgICAgICBlbHNlIGlmIChjdXJyZW50ID4gdGFyZ2V0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmaW5kKGN1cnJlbnQgKyA1LCBcIihcIiArIGhpc3RvcnkgKyBcIiArIDUpXCIpIHx8XG4gICAgICAgICAgICAgICAgZmluZChjdXJyZW50ICogMywgXCIoXCIgKyBoaXN0b3J5ICsgXCIgKiAzKVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmQoMSwgXCIxXCIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3V0ZXIge1xuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG0oJ2gxJywgJzE1LTE1LTE1LTE1JyksXG4gICAgICAgICAgICBfLm1hcChpbnB1dHMsIGkgPT4gW1xuICAgICAgICAgICAgICAgIG0oRGljZUlucHV0LCB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogaS5rZXksXG4gICAgICAgICAgICAgICAgICAgIG51bWJlcjogaS5udW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIG9uY2hhbmdlOiBzZXRJbnB1dChpLmtleSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBzaW1wbGVzb2x1dGlvbi5tYXAoc29sdXRpb24gPT4gbSgncHJlJywgc29sdXRpb24pKSxcbiAgICAgICAgICAgIG0oJ2hyJyksXG4gICAgICAgICAgICBfLmZpcnN0KGNsb3Nlc3QsMzApLm1hcChzb2x1dGlvbiA9PiBtKCdwcmUnLCBKU09OLnN0cmluZ2lmeShzb2x1dGlvbi5kaWZmKSArICc6ICcgKyBKU09OLnN0cmluZ2lmeShzb2x1dGlvbi50ZXh0KSkpXG4gICAgICAgIF07XG4gICAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2V0MTVfMS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBSkE7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUpBO0FBTUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFKQTtBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBSkE7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUpBO0FBTUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFKQTtBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBSkE7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUpBO0FBQ0E7QUFPQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBSEE7QUFDQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQURBO0FBREE7QUFEQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUhBO0FBQUE7QUFNQTs7Ozs7O0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBT0E7QUFBQTtBQUVBO0FBQUE7QUFFQTs7Ozs7O0FBZkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function () {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function get() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function get() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanM/ZWY1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/*!************************!*\
  !*** ./src/get15_2.js ***!
  \************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _underscore = __webpack_require__(/*! underscore */ 1);\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar targetNumber = 15;\n\nvar inputs = [{\n    key: 0,\n    number: 1\n}, {\n    key: 1,\n    number: 1\n}, {\n    key: 2,\n    number: 1\n}];\n\nvar fac = function fac(n) {\n    var p = 1;\n    for (var i = 1; i <= n; i++) {\n        p *= i;\n    }return p;\n};\n\nvar binaryFunctions = [{\n    name: '+',\n    fcn: function fcn(x, y) {\n        return x + y;\n    },\n    wrap: function wrap(x, y) {\n        return '(' + x + ' + ' + y + ')';\n    },\n    inv: function inv(x, y) {\n        return x - y;\n    },\n    active: true\n}, {\n    name: '-',\n    fcn: function fcn(x, y) {\n        return x - y;\n    },\n    wrap: function wrap(x, y) {\n        return '(' + x + ' - ' + y + ')';\n    },\n    inv: function inv(x, y) {\n        return x + y;\n    },\n    active: true\n}, {\n    name: '*',\n    fcn: function fcn(x, y) {\n        return x * y;\n    },\n    wrap: function wrap(x, y) {\n        return '(' + x + ' * ' + y + ')';\n    },\n    inv: function inv(x, y) {\n        return x / y;\n    },\n    active: true\n}, {\n    name: '/',\n    fcn: function fcn(x, y) {\n        return x / y;\n    },\n    wrap: function wrap(x, y) {\n        return '(' + x + ' / ' + y + ')';\n    },\n    inv: function inv(x, y) {\n        return x * y;\n    },\n    active: true\n}, {\n    name: '**',\n    fcn: function fcn(x, y) {\n        return Math.pow(x, y);\n    },\n    wrap: function wrap(x, y) {\n        return '(' + x + ' ** ' + y + ')';\n    },\n    inv: function inv(x, y) {\n        return Math.pow(x, 1 / y);\n    },\n    active: true\n}, {\n    name: '**1/',\n    fcn: function fcn(x, y) {\n        return Math.pow(x, 1 / y);\n    },\n    wrap: function wrap(x, y) {\n        return '(' + x + ' **1/ ' + y + ')';\n    },\n    inv: function inv(x, y) {\n        return Math.pow(x, y);\n    },\n    active: false\n}, {\n    name: 'mean',\n    fcn: function fcn(x, y) {\n        return (x + y) / 2.;\n    },\n    wrap: function wrap(x, y) {\n        return 'mean(' + x + ' , ' + y + ')';\n    },\n    inv: function inv(x, y) {\n        return Math.pow(x, y);\n    },\n    active: false\n}, {\n    name: 'over',\n    fcn: function fcn(x, y) {\n        return fac(x) / fac(y) / fac(x - y);\n    },\n    wrap: function wrap(x, y) {\n        return '(' + x + ' over ' + y + ')';\n    },\n    inv: function inv(x, y) {\n        return Math.pow(x, y);\n    },\n    active: false\n}, {\n    name: 'places',\n    fcn: function fcn(x, y) {\n        return x * 10 + y;\n    },\n    wrap: function wrap(x, y) {\n        return 'str(\\'' + x + '\\', \\'' + y + '\\')';\n    },\n    inv: function inv(x, y) {\n        return null;\n    },\n    active: false\n}];\n\nvar unaryFunctions = [{\n    name: 'id',\n    fcn: function fcn(x) {\n        return x;\n    },\n    wrap: function wrap(x) {\n        return x;\n    },\n    active: true\n}, {\n    name: '-',\n    fcn: function fcn(x) {\n        return -x;\n    },\n    wrap: function wrap(x) {\n        return '-' + x;\n    },\n    active: false\n}, {\n    name: '1/',\n    fcn: function fcn(x) {\n        return 1 / x;\n    },\n    wrap: function wrap(x) {\n        return '(1 / ' + x + ')';\n    },\n    active: false\n}, {\n    name: 'fac',\n    fcn: function fcn(x) {\n        return x < 10 && x > 1 ? fac(x) : x;\n    },\n    wrap: function wrap(x) {\n        return x < 10 && x > 1 ? '!(' + x + ')' : x;\n    },\n    active: false\n}, {\n    name: 'round',\n    fcn: function fcn(x) {\n        return Math.round(x);\n    },\n    wrap: function wrap(x) {\n        return '~(' + x + ')';\n    },\n    active: false\n}, {\n    name: 'floor',\n    fcn: function fcn(x) {\n        return Math.floor(x);\n    },\n    wrap: function wrap(x) {\n        return Math.floor(x) !== x ? '~>(' + x + ')' : x;\n    },\n    active: false\n}, {\n    name: 'ceil',\n    fcn: function fcn(x) {\n        return Math.ceil(x);\n    },\n    wrap: function wrap(x) {\n        return Math.ceil(x) !== x ? '~<(' + x + ')' : x;\n    },\n    active: false\n}];\n\nvar permut = function permut(a) {\n    if (a.length === 1) return a;\n    var result = [];\n    a.forEach(function (e, idx) {\n        var c = a.slice();\n        c.splice(idx, 1);\n        var r = permut(c);\n        r.forEach(function (el) {\n            return result.push(_underscore2.default.flatten([e, el]));\n        });\n    });\n    return result;\n};\n\nvar special_permut = function special_permut(a) {\n    var result = [];\n    a.forEach(function (e, idx) {\n        var c = a.slice();\n        c.splice(idx, 1);\n        result.push(_underscore2.default.flatten([e, c]));\n    });\n    return result;\n};\n\nvar no_permut = function no_permut(a) {\n    return [a];\n};\n\nvar getTwo = function getTwo(a) {\n    var result = [];\n    a.forEach(function (e1) {\n        return a.map(function (e2) {\n            return result.push([e1, e2]);\n        });\n    });\n    return result;\n};\n\nvar getThree = function getThree(a) {\n    var result = [];\n    a.forEach(function (e1) {\n        return a.map(function (e2) {\n            return a.map(function (e3) {\n                return result.push([e1, e2, e3]);\n            });\n        });\n    });\n    return result;\n};\n\nvar getFive = function getFive(a) {\n    var result = [];\n    a.forEach(function (e1) {\n        return a.map(function (e2) {\n            return a.map(function (e3) {\n                return a.map(function (e4) {\n                    return a.map(function (e5) {\n                        return result.push([e1, e2, e3, e4, e5]);\n                    });\n                });\n            });\n        });\n    });\n    return result;\n};\n\nvar closest = [];\nvar simplesolution = [];\n\nvar bifcn = function bifcn(t) {\n    return function (a, b) {\n        return {\n            name: function name() {\n                return t.name;\n            },\n            wrap: function wrap() {\n                return t.wrap(a.wrap(), b.wrap());\n            },\n            fcn: function fcn() {\n                return t.fcn(a.fcn(), b.fcn());\n            }\n        };\n    };\n};\n\nvar unfcn = function unfcn(t) {\n    return function (a) {\n        return {\n            name: function name() {\n                return t.name;\n            },\n            wrap: function wrap() {\n                return t.wrap(a.wrap());\n            },\n            fcn: function fcn() {\n                return t.fcn(a.fcn());\n            }\n        };\n    };\n};\n\nvar nofcn = function nofcn(val) {\n    return {\n        name: function name() {\n            return 'value (' + val + ')';\n        },\n        wrap: function wrap() {\n            return val;\n        },\n        fcn: function fcn() {\n            return val;\n        }\n    };\n};\n\nvar pattern1 = function pattern1(b1, b2, u1, u2, u3, u4, u5, v1, v2, v3) {\n    return u1(b1(u2(v1), u3(b2(u4(v2), u5(v3)))));\n};\n\nvar pattern2 = function pattern2(b1, b2, u1, u2, u3, u4, u5, v1, v2, v3) {\n    return u1(b1(u3(b2(u4(v2), u5(v3))), u2(v1)));\n};\n\nvar solve = function solve(numbers) {\n    var bifcns = binaryFunctions.filter(function (f) {\n        return f.active;\n    }).map(bifcn);\n    var unfcns = unaryFunctions.filter(function (f) {\n        return f.active;\n    }).map(unfcn);\n    var noops = numbers.map(nofcn);\n    var unops = getFive(unfcns);\n    var biops = getTwo(bifcns);\n    var nums = special_permut(noops);\n    var comps = [pattern1, pattern2];\n    simplesolution = [];\n    closest = [];\n    var ncomb = nums.length * unops.length * biops.length * comps.length;\n    console.log('testing', ncomb, 'combinations');\n    nums.forEach(function (num) {\n        unops.forEach(function (unop) {\n            biops.forEach(function (biop) {\n                comps.forEach(function (comp) {\n                    var finalF = comp.apply(undefined, _toConsumableArray(biop).concat(_toConsumableArray(unop), _toConsumableArray(num)));\n                    if (finalF.fcn() === targetNumber) {\n                        simplesolution.push(finalF.wrap());\n                    } else {\n                        closest.push({ diff: Math.abs(targetNumber - finalF.fcn()), text: finalF.wrap() });\n                    }\n                });\n            });\n        });\n    });\n    closest = _underscore2.default.sortBy(closest, 'diff');\n};\n\nvar DiceInput = function () {\n    function DiceInput(vnode) {\n        _classCallCheck(this, DiceInput);\n\n        this.numbers = [1, 2, 3, 4, 5, 6];\n    }\n\n    _createClass(DiceInput, [{\n        key: 'view',\n        value: function view(vnode) {\n            return (0, _mithril2.default)('table', (0, _mithril2.default)('tr', _underscore2.default.map(this.numbers, function (n) {\n                return (0, _mithril2.default)('td', (0, _mithril2.default)('button.btn.btn-default', {\n                    style: _underscore2.default.find(inputs, function (i) {\n                        return i.key === vnode.attrs.key;\n                    }).number === n ? 'background-color:red' : '',\n                    onclick: vnode.attrs.onchange(n)\n                }, n));\n            })));\n        }\n    }]);\n\n    return DiceInput;\n}();\n\nvar setInput = function setInput(inputNumber) {\n    return function (selectedNumber) {\n        return function () {\n            _underscore2.default.find(inputs, function (i) {\n                return i.key === inputNumber;\n            }).number = selectedNumber;\n            solve(_underscore2.default.pluck(inputs, 'number'));\n        };\n    };\n};\n\nvar BiFuncView = function () {\n    function BiFuncView() {\n        _classCallCheck(this, BiFuncView);\n    }\n\n    _createClass(BiFuncView, [{\n        key: 'view',\n        value: function view(vnode) {\n            return [(0, _mithril2.default)('input[type=checkbox]', {\n                checked: vnode.attrs.fn.active,\n                onchange: function onchange(e) {\n                    return vnode.attrs.fn.active = e.target.checked;\n                }\n            }), vnode.attrs.fn.name];\n        }\n    }]);\n\n    return BiFuncView;\n}();\n\nconsole.log('underscore first', _underscore2.default.first([], 39));\n\nvar Router = function () {\n    function Router() {\n        _classCallCheck(this, Router);\n    }\n\n    _createClass(Router, [{\n        key: 'view',\n        value: function view(vnode) {\n            return (0, _mithril2.default)('.container', [(0, _mithril2.default)('h1', '15-15-15-15'), (0, _mithril2.default)('h3', 'binary'), (0, _mithril2.default)('.row', [binaryFunctions.map(function (bifn) {\n                return (0, _mithril2.default)('.col-md-2.col-xs-2', (0, _mithril2.default)(BiFuncView, { fn: bifn }));\n            })]), (0, _mithril2.default)('h3', 'unary'), (0, _mithril2.default)('.row', [unaryFunctions.map(function (bifn) {\n                return (0, _mithril2.default)('.col-md-2.col-xs-2', (0, _mithril2.default)(BiFuncView, { fn: bifn }));\n            })]), (0, _mithril2.default)('h3', 'Dice'), _underscore2.default.map(inputs, function (i) {\n                return [(0, _mithril2.default)(DiceInput, {\n                    key: i.key,\n                    number: i.number,\n                    onchange: setInput(i.key)\n                })];\n            }), (0, _mithril2.default)('br'), simplesolution.map(function (solution) {\n                return (0, _mithril2.default)('pre', solution);\n            }), (0, _mithril2.default)('hr'), _underscore2.default.first(closest, 30) ? _underscore2.default.first(closest, 30).map(function (solution) {\n                return (0, _mithril2.default)('pre', JSON.stringify(solution.diff) + ': ' + JSON.stringify(solution.text));\n            }) : null]);\n        }\n    }]);\n\n    return Router;\n}();\n\nexports.default = Router;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2dldDE1XzIuanM/NzhlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcbmltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG52YXIgdGFyZ2V0TnVtYmVyID0gMTU7XG5cbnZhciBpbnB1dHMgPSBbe1xuICAgIGtleTogMCxcbiAgICBudW1iZXI6IDFcbn0sIHtcbiAgICBrZXk6IDEsXG4gICAgbnVtYmVyOiAxXG59LCB7XG4gICAga2V5OiAyLFxuICAgIG51bWJlcjogMVxufV07XG5cbnZhciBmYWMgPSAobikgPT4ge1xuICAgIGxldCBwID0gMTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBuOyBpKyspXG4gICAgICAgIHAgKj0gaTtcbiAgICByZXR1cm4gcDtcbn07XG5cbnZhciBiaW5hcnlGdW5jdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBuYW1lOiAnKycsXG4gICAgICAgIGZjbjogKHgsIHkpID0+IHggKyB5LFxuICAgICAgICB3cmFwOiAoeCwgeSkgPT4gJygnICsgeCArICcgKyAnICsgeSArICcpJyxcbiAgICAgICAgaW52OiAoeCwgeSkgPT4geCAtIHksXG4gICAgICAgIGFjdGl2ZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogJy0nLFxuICAgICAgICBmY246ICh4LCB5KSA9PiB4IC0geSxcbiAgICAgICAgd3JhcDogKHgsIHkpID0+ICcoJyArIHggKyAnIC0gJyArIHkgKyAnKScsXG4gICAgICAgIGludjogKHgsIHkpID0+IHggKyB5LFxuICAgICAgICBhY3RpdmU6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6ICcqJyxcbiAgICAgICAgZmNuOiAoeCwgeSkgPT4geCAqIHksXG4gICAgICAgIHdyYXA6ICh4LCB5KSA9PiAnKCcgKyB4ICsgJyAqICcgKyB5ICsgJyknLFxuICAgICAgICBpbnY6ICh4LCB5KSA9PiB4IC8geSxcbiAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiAnLycsXG4gICAgICAgIGZjbjogKHgsIHkpID0+IHggLyB5LFxuICAgICAgICB3cmFwOiAoeCwgeSkgPT4gJygnICsgeCArICcgLyAnICsgeSArICcpJyxcbiAgICAgICAgaW52OiAoeCwgeSkgPT4geCAqIHksXG4gICAgICAgIGFjdGl2ZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogJyoqJyxcbiAgICAgICAgZmNuOiAoeCwgeSkgPT4gTWF0aC5wb3coeCwgeSksXG4gICAgICAgIHdyYXA6ICh4LCB5KSA9PiAnKCcgKyB4ICsgJyAqKiAnICsgeSArICcpJyxcbiAgICAgICAgaW52OiAoeCwgeSkgPT4gTWF0aC5wb3coeCwgMSAvIHkpLFxuICAgICAgICBhY3RpdmU6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6ICcqKjEvJyxcbiAgICAgICAgZmNuOiAoeCwgeSkgPT4gTWF0aC5wb3coeCwgMSAvIHkpLFxuICAgICAgICB3cmFwOiAoeCwgeSkgPT4gJygnICsgeCArICcgKioxLyAnICsgeSArICcpJyxcbiAgICAgICAgaW52OiAoeCwgeSkgPT4gTWF0aC5wb3coeCwgeSksXG4gICAgICAgIGFjdGl2ZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdtZWFuJyxcbiAgICAgICAgZmNuOiAoeCwgeSkgPT4gKHggKyB5KSAvIDIuLFxuICAgICAgICB3cmFwOiAoeCwgeSkgPT4gJ21lYW4oJyArIHggKyAnICwgJyArIHkgKyAnKScsXG4gICAgICAgIGludjogKHgsIHkpID0+IE1hdGgucG93KHgsIHkpLFxuICAgICAgICBhY3RpdmU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiAnb3ZlcicsXG4gICAgICAgIGZjbjogKHgsIHkpID0+IGZhYyh4KSAvIGZhYyh5KSAvIGZhYyh4IC0geSksXG4gICAgICAgIHdyYXA6ICh4LCB5KSA9PiAnKCcgKyB4ICsgJyBvdmVyICcgKyB5ICsgJyknLFxuICAgICAgICBpbnY6ICh4LCB5KSA9PiBNYXRoLnBvdyh4LCB5KSxcbiAgICAgICAgYWN0aXZlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ3BsYWNlcycsXG4gICAgICAgIGZjbjogKHgsIHkpID0+IHggKiAxMCArIHksXG4gICAgICAgIHdyYXA6ICh4LCB5KSA9PiAnc3RyKFxcJycgKyB4ICsgJ1xcJywgXFwnJyArIHkgKyAnXFwnKScsXG4gICAgICAgIGludjogKHgsIHkpID0+IG51bGwsXG4gICAgICAgIGFjdGl2ZTogZmFsc2VcbiAgICB9XG5dO1xuXG52YXIgdW5hcnlGdW5jdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBuYW1lOiAnaWQnLFxuICAgICAgICBmY246IHggPT4geCxcbiAgICAgICAgd3JhcDogeCA9PiB4LFxuICAgICAgICBhY3RpdmU6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6ICctJyxcbiAgICAgICAgZmNuOiB4ID0+IC14LFxuICAgICAgICB3cmFwOiB4ID0+ICctJyArIHgsXG4gICAgICAgIGFjdGl2ZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6ICcxLycsXG4gICAgICAgIGZjbjogeCA9PiAxIC8geCxcbiAgICAgICAgd3JhcDogeCA9PiAnKDEgLyAnICsgeCArICcpJyxcbiAgICAgICAgYWN0aXZlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ2ZhYycsXG4gICAgICAgIGZjbjogeCA9PiB4IDwgMTAgJiYgeCA+IDEgPyBmYWMoeCkgOiB4LFxuICAgICAgICB3cmFwOiB4ID0+IHggPCAxMCAmJiB4ID4gMSA/ICchKCcgKyB4ICsgJyknIDogeCxcbiAgICAgICAgYWN0aXZlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ3JvdW5kJyxcbiAgICAgICAgZmNuOiB4ID0+IE1hdGgucm91bmQoeCksXG4gICAgICAgIHdyYXA6IHggPT4gJ34oJyArIHggKyAnKScsXG4gICAgICAgIGFjdGl2ZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdmbG9vcicsXG4gICAgICAgIGZjbjogeCA9PiBNYXRoLmZsb29yKHgpLFxuICAgICAgICB3cmFwOiB4ID0+IE1hdGguZmxvb3IoeCkgIT09IHggPyAnfj4oJyArIHggKyAnKScgOiB4LFxuICAgICAgICBhY3RpdmU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiAnY2VpbCcsXG4gICAgICAgIGZjbjogeCA9PiBNYXRoLmNlaWwoeCksXG4gICAgICAgIHdyYXA6IHggPT4gTWF0aC5jZWlsKHgpICE9PSB4ID8gJ348KCcgKyB4ICsgJyknIDogeCxcbiAgICAgICAgYWN0aXZlOiBmYWxzZVxuICAgIH1cbl07XG5cbnZhciBwZXJtdXQgPSBhID0+IHtcbiAgICBpZiAoYS5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBhO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBhLmZvckVhY2goKGUsIGlkeCkgPT4ge1xuICAgICAgICBsZXQgYyA9IGEuc2xpY2UoKTtcbiAgICAgICAgYy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgdmFyIHIgPSBwZXJtdXQoYyk7XG4gICAgICAgIHIuZm9yRWFjaChlbCA9PiByZXN1bHQucHVzaChfLmZsYXR0ZW4oW2UsIGVsXSkpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIHNwZWNpYWxfcGVybXV0ID0gYSA9PiB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGEuZm9yRWFjaCgoZSwgaWR4KSA9PiB7XG4gICAgICAgIGxldCBjID0gYS5zbGljZSgpO1xuICAgICAgICBjLnNwbGljZShpZHgsIDEpO1xuICAgICAgICByZXN1bHQucHVzaChfLmZsYXR0ZW4oW2UsIGNdKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBub19wZXJtdXQgPSBhID0+IFthXTtcblxudmFyIGdldFR3byA9IGEgPT4ge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBhLmZvckVhY2goZTEgPT4gYS5tYXAoZTIgPT4gcmVzdWx0LnB1c2goW2UxLCBlMl0pKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBnZXRUaHJlZSA9IGEgPT4ge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBhLmZvckVhY2goZTEgPT4gYS5tYXAoZTIgPT4gYS5tYXAoZTMgPT4gcmVzdWx0LnB1c2goW2UxLCBlMiwgZTNdKSkpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGdldEZpdmUgPSBhID0+IHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgYS5mb3JFYWNoKGUxID0+XG4gICAgICAgIGEubWFwKGUyID0+XG4gICAgICAgICAgICBhLm1hcChlMyA9PlxuICAgICAgICAgICAgICAgIGEubWFwKGU0ID0+XG4gICAgICAgICAgICAgICAgICAgIGEubWFwKGU1ID0+XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbZTEsIGUyLCBlMywgZTQsIGU1XSkpKSkpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGNsb3Nlc3QgPSBbXTtcbnZhciBzaW1wbGVzb2x1dGlvbiA9IFtdO1xuXG52YXIgYmlmY24gPSB0ID0+IChhLCBiKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogKCkgPT4gdC5uYW1lLFxuICAgICAgICB3cmFwOiAoKSA9PiB0LndyYXAoYS53cmFwKCksIGIud3JhcCgpKSxcbiAgICAgICAgZmNuOiAoKSA9PiB0LmZjbihhLmZjbigpLCBiLmZjbigpKVxuICAgIH07XG59O1xuXG52YXIgdW5mY24gPSB0ID0+IChhKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogKCkgPT4gdC5uYW1lLFxuICAgICAgICB3cmFwOiAoKSA9PiB0LndyYXAoYS53cmFwKCkpLFxuICAgICAgICBmY246ICgpID0+IHQuZmNuKGEuZmNuKCkpXG4gICAgfTtcbn07XG5cbnZhciBub2ZjbiA9ICh2YWwpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAoKSA9PiAndmFsdWUgKCcgKyB2YWwgKyAnKScsXG4gICAgICAgIHdyYXA6ICgpID0+IHZhbCxcbiAgICAgICAgZmNuOiAoKSA9PiB2YWxcbiAgICB9O1xufTtcblxudmFyIHBhdHRlcm4xID0gKGIxLCBiMiwgdTEsIHUyLCB1MywgdTQsIHU1LCB2MSwgdjIsIHYzKSA9PiB7XG4gICAgcmV0dXJuIHUxKGIxKHUyKHYxKSwgdTMoYjIodTQodjIpLCB1NSh2MykpKSkpO1xufVxuXG52YXIgcGF0dGVybjIgPSAoYjEsIGIyLCB1MSwgdTIsIHUzLCB1NCwgdTUsIHYxLCB2MiwgdjMpID0+IHtcbiAgICByZXR1cm4gdTEoYjEodTMoYjIodTQodjIpLCB1NSh2MykpKSwgdTIodjEpKSk7XG59XG5cbnZhciBzb2x2ZSA9IChudW1iZXJzKSA9PiB7XG4gICAgdmFyIGJpZmNucyA9IGJpbmFyeUZ1bmN0aW9ucy5maWx0ZXIoZiA9PiBmLmFjdGl2ZSkubWFwKGJpZmNuKTtcbiAgICB2YXIgdW5mY25zID0gdW5hcnlGdW5jdGlvbnMuZmlsdGVyKGYgPT4gZi5hY3RpdmUpLm1hcCh1bmZjbik7XG4gICAgdmFyIG5vb3BzID0gbnVtYmVycy5tYXAobm9mY24pO1xuICAgIHZhciB1bm9wcyA9IGdldEZpdmUodW5mY25zKTtcbiAgICB2YXIgYmlvcHMgPSBnZXRUd28oYmlmY25zKTtcbiAgICB2YXIgbnVtcyA9IHNwZWNpYWxfcGVybXV0KG5vb3BzKTtcbiAgICB2YXIgY29tcHMgPSBbcGF0dGVybjEsIHBhdHRlcm4yXTtcbiAgICBzaW1wbGVzb2x1dGlvbiA9IFtdO1xuICAgIGNsb3Nlc3QgPSBbXTtcbiAgICBsZXQgbmNvbWIgPSBudW1zLmxlbmd0aCAqIHVub3BzLmxlbmd0aCAqIGJpb3BzLmxlbmd0aCAqIGNvbXBzLmxlbmd0aDtcbiAgICBjb25zb2xlLmxvZygndGVzdGluZycsIG5jb21iLCAnY29tYmluYXRpb25zJylcbiAgICBudW1zLmZvckVhY2gobnVtID0+IHtcbiAgICAgICAgdW5vcHMuZm9yRWFjaCh1bm9wID0+IHtcbiAgICAgICAgICAgIGJpb3BzLmZvckVhY2goYmlvcCA9PiB7XG4gICAgICAgICAgICAgICAgY29tcHMuZm9yRWFjaChjb21wID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpbmFsRiA9IGNvbXAoLi4uYmlvcCwgLi4udW5vcCwgLi4ubnVtKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsRi5mY24oKSA9PT0gdGFyZ2V0TnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaW1wbGVzb2x1dGlvbi5wdXNoKGZpbmFsRi53cmFwKCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdC5wdXNoKHsgZGlmZjogTWF0aC5hYnModGFyZ2V0TnVtYmVyIC0gZmluYWxGLmZjbigpKSwgdGV4dDogZmluYWxGLndyYXAoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNsb3Nlc3QgPSBfLnNvcnRCeShjbG9zZXN0LCAnZGlmZicpO1xufTtcblxuY2xhc3MgRGljZUlucHV0IHtcbiAgICBjb25zdHJ1Y3Rvcih2bm9kZSkge1xuICAgICAgICB0aGlzLm51bWJlcnMgPSBbMSwgMiwgMywgNCwgNSwgNl07XG4gICAgfVxuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG0oJ3RhYmxlJywgbSgndHInLFxuICAgICAgICAgICAgXy5tYXAodGhpcy5udW1iZXJzLCBuID0+IG0oJ3RkJywgbSgnYnV0dG9uLmJ0bi5idG4tZGVmYXVsdCcsIHtcbiAgICAgICAgICAgICAgICBzdHlsZTogKF8uZmluZChpbnB1dHMsIGkgPT4gaS5rZXkgPT09IHZub2RlLmF0dHJzLmtleSkubnVtYmVyID09PSBuKSA/XG4gICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yOnJlZCcgOiAnJyxcbiAgICAgICAgICAgICAgICBvbmNsaWNrOiB2bm9kZS5hdHRycy5vbmNoYW5nZShuKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBuKSkpKVxuICAgICAgICApO1xuICAgIH1cbn1cblxudmFyIHNldElucHV0ID0gaW5wdXROdW1iZXIgPT4gc2VsZWN0ZWROdW1iZXIgPT4gKCkgPT4ge1xuICAgIF8uZmluZChpbnB1dHMsIGkgPT4gaS5rZXkgPT09IGlucHV0TnVtYmVyKS5udW1iZXIgPSBzZWxlY3RlZE51bWJlcjtcbiAgICBzb2x2ZShfLnBsdWNrKGlucHV0cywgJ251bWJlcicpKTtcbn07XG5cbmNsYXNzIEJpRnVuY1ZpZXcge1xuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFttKCdpbnB1dFt0eXBlPWNoZWNrYm94XScsIHtcbiAgICAgICAgICAgIGNoZWNrZWQ6IHZub2RlLmF0dHJzLmZuLmFjdGl2ZSxcbiAgICAgICAgICAgIG9uY2hhbmdlOiBlID0+IHZub2RlLmF0dHJzLmZuLmFjdGl2ZSA9IGUudGFyZ2V0LmNoZWNrZWRcbiAgICAgICAgfVxuICAgICAgICApLCB2bm9kZS5hdHRycy5mbi5uYW1lXTtcbiAgICB9XG59XG5cbmNvbnNvbGUubG9nKCd1bmRlcnNjb3JlIGZpcnN0JywgXy5maXJzdChbXSwzOSkpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3V0ZXIge1xuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG0oJy5jb250YWluZXInLCBbXG4gICAgICAgICAgICBtKCdoMScsICcxNS0xNS0xNS0xNScpLFxuICAgICAgICAgICAgbSgnaDMnLCAnYmluYXJ5JyksXG4gICAgICAgICAgICBtKCcucm93JywgW1xuICAgICAgICAgICAgICAgIGJpbmFyeUZ1bmN0aW9ucy5tYXAoYmlmbiA9PiBtKCcuY29sLW1kLTIuY29sLXhzLTInLCBtKEJpRnVuY1ZpZXcsIHsgZm46IGJpZm4gfSkpKSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgbSgnaDMnLCAndW5hcnknKSxcbiAgICAgICAgICAgIG0oJy5yb3cnLCBbXG4gICAgICAgICAgICAgICAgdW5hcnlGdW5jdGlvbnMubWFwKGJpZm4gPT4gbSgnLmNvbC1tZC0yLmNvbC14cy0yJywgbShCaUZ1bmNWaWV3LCB7IGZuOiBiaWZuIH0pKSlcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgbSgnaDMnLCAnRGljZScpLFxuICAgICAgICAgICAgXy5tYXAoaW5wdXRzLCBpID0+IFtcbiAgICAgICAgICAgICAgICBtKERpY2VJbnB1dCwge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGkua2V5LFxuICAgICAgICAgICAgICAgICAgICBudW1iZXI6IGkubnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBvbmNoYW5nZTogc2V0SW5wdXQoaS5rZXkpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgbSgnYnInKSxcbiAgICAgICAgICAgIHNpbXBsZXNvbHV0aW9uLm1hcChzb2x1dGlvbiA9PiBtKCdwcmUnLCBzb2x1dGlvbikpLFxuICAgICAgICAgICAgbSgnaHInKSxcdCAgICBcbiAgICAgICAgICAgIF8uZmlyc3QoY2xvc2VzdCwgMzApP18uZmlyc3QoY2xvc2VzdCwgMzApLm1hcChzb2x1dGlvbiA9PiBtKCdwcmUnLCBKU09OLnN0cmluZ2lmeShzb2x1dGlvbi5kaWZmKSArICc6ICcgKyBKU09OLnN0cmluZ2lmeShzb2x1dGlvbi50ZXh0KSkpOm51bGxcbiAgICAgICAgXSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZXQxNV8yLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFMQTtBQUNBO0FBUUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSkE7QUFDQTtBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFEQTtBQURBO0FBREE7QUFEQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUhBO0FBS0E7QUFOQTtBQUNBO0FBT0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBSEE7QUFLQTtBQU5BO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUhBO0FBQUE7QUFPQTs7Ozs7O0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFDQTtBQUlBOzs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFLQTs7Ozs7O0FBR0E7QUFDQTtBQUNBOzs7Ozs7O0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFJQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBUUE7QUFBQTtBQUVBO0FBQUE7QUFFQTs7Ozs7O0FBekJBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/*!********************!*\
  !*** ./src/set.js ***!
  \********************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _underscore = __webpack_require__(/*! underscore */ 1);\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar targetNumber = 15;\n\nvar inputs = [{\n    key: 0,\n    number: 1\n}, {\n    key: 1,\n    number: 1\n}, {\n    key: 2,\n    number: 1\n}];\n\nvar farben = ['ForestGreen', 'DarkViolet', 'OrangeRed'];\nvar formen = [1, 2, 3];\nvar musters = [1, 2, 3];\nvar anzahlen = [1, 2, 3];\n\nvar count = 0;\n\nvar karte = function karte(farbe, form, muster, anzahl) {\n    return {\n        farbe: farbe,\n        form: form,\n        muster: muster,\n        anzahl: anzahl\n    };\n};\n\nvar getThree = function getThree(a) {\n    var result = [];\n    if (a.length > 2) {\n        for (var i = 0; i < a.length - 2; i++) {\n            for (var j = i + 1; j < a.length - 1; j++) {\n                for (var k = j + 1; k < a.length; k++) {\n                    result.push([a[i], a[j], a[k]]);\n                }\n            }\n        }\n    }\n    return result;\n};\n\nvar setCondition = function setCondition(f1, f2, f3) {\n    return f1 === f2 && f1 === f3 || f1 !== f2 && f1 !== f3 && f2 !== f3;\n};\n\nvar isSet = function isSet(k1, k2, k3) {\n    if (!(k1 && k2 && k3)) return false;\n    for (var p in k1) {\n        if (!setCondition.apply(undefined, _toConsumableArray(_underscore2.default.pluck([k1, k2, k3], p)))) return false;\n    }\n    return true;\n};\n\nvar karten = [];\n\nfarben.forEach(function (farbe) {\n    formen.forEach(function (form) {\n        musters.forEach(function (muster) {\n            anzahlen.forEach(function (anzahl) {\n                karten.push(karte(farbe, form, muster, anzahl));\n            });\n        });\n    });\n});\n\nvar aufDemTisch = [];\nvar sets = [];\n\nvar checkForSet = function checkForSet() {\n    sets = [];\n    var combis = getThree(aufDemTisch);\n    console.log('combis', combis);\n    combis.forEach(function (combi) {\n        if (isSet.apply(undefined, _toConsumableArray(combi))) {\n            sets.push(combi);\n        }\n    });\n};\n\nvar drawKart = function drawKart() {\n    if (karten.length > 0) {\n        var idx = Math.random() * karten.length;\n        aufDemTisch.push(karten.splice(idx, 1)[0]);\n    }\n    checkForSet();\n};\n\nconsole.log('count', karten);\n\nvar selectedKarten = [];\n\nvar equal = function equal(k1, k2) {\n    return k1.form === k2.form && k1.farbe === k2.farbe && k1.anzahl === k2.anzahl && k1.muster === k2.muster;\n};\n\nvar select = function select(karte) {\n    return function () {\n        if (_underscore2.default.contains(selectedKarten, karte)) {\n            selectedKarten = _underscore2.default.filter(selectedKarten, function (karteInSet) {\n                return !equal(karteInSet, karte);\n            });\n        } else {\n            selectedKarten.push(karte);\n        }\n        while (selectedKarten.length > 3) {\n            selectedKarten.splice(0, 1);\n        }\n    };\n};\n\nvar Karte = function () {\n    function Karte() {\n        _classCallCheck(this, Karte);\n    }\n\n    _createClass(Karte, [{\n        key: 'view',\n        value: function view(vnode) {\n            //  console.log(vnode.attrs.karte)\n            return (0, _mithril2.default)('.col-md-1.col-xs-1' + (_underscore2.default.contains(selectedKarten, vnode.attrs.karte) ? '.debug' : ''), {\n                style: 'height:120px;width:50px',\n                onclick: select(vnode.attrs.karte)\n            }, (0, _mithril2.default)('.muster' + vnode.attrs.karte.muster + '.form' + vnode.attrs.karte.form, {\n                style: 'height:' + vnode.attrs.karte.anzahl * 30 + 'px;background-color:' + vnode.attrs.karte.farbe\n            }));\n        }\n    }]);\n\n    return Karte;\n}();\n\nvar removeSet = function removeSet(set) {\n    return function () {\n        aufDemTisch = _underscore2.default.filter(aufDemTisch, function (e) {\n            return !_underscore2.default.contains(set, e);\n        });\n        checkForSet();\n    };\n};\n\nvar collapsed1 = true;\nvar collapsed2 = true;\nvar collapsed3 = true;\n\nvar setsOfPlayer1 = [];\nvar setsOfPlayer2 = [];\n\nvar set1 = function set1() {\n    console.log('set1');\n    if (isSet.apply(undefined, _toConsumableArray(selectedKarten))) {\n        removeSet(selectedKarten)();\n        setsOfPlayer1.push(selectedKarten);\n    }\n    selectedKarten = [];\n};\n\nvar set2 = function set2() {\n    console.log('set1');\n    if (isSet.apply(undefined, _toConsumableArray(selectedKarten))) {\n        removeSet(selectedKarten)();\n        setsOfPlayer2.push(selectedKarten);\n    }\n    selectedKarten = [];\n};\n\nvar Router = function () {\n    function Router() {\n        _classCallCheck(this, Router);\n    }\n\n    _createClass(Router, [{\n        key: 'view',\n        value: function view(vnode) {\n            return (0, _mithril2.default)('.container', [(0, _mithril2.default)('h1', 'Tisch ' + aufDemTisch.length), (0, _mithril2.default)('button.btn.btn-primary', { onclick: function onclick(e) {\n                    return drawKart();\n                } }, 'Zieh'), (0, _mithril2.default)('button.btn.btn-success', { onclick: set1 }, 'Set Spieler 1'), (0, _mithril2.default)('button.btn.btn-success', { onclick: set2 }, 'Set Spieler 2'), (0, _mithril2.default)('.row', [aufDemTisch.map(function (k) {\n                return (0, _mithril2.default)(Karte, { karte: k });\n            })]), (0, _mithril2.default)('hr'), (0, _mithril2.default)('h1', 'Sets auf dem Tisch: ' + sets.length + ' ', (0, _mithril2.default)('button.btn.btn-primary', { onclick: function onclick() {\n                    return collapsed1 = !collapsed1;\n                } }, 'Zeigen')), collapsed1 ? null : sets.map(function (set) {\n                return (0, _mithril2.default)('.row', [set.map(function (k) {\n                    return (0, _mithril2.default)(Karte, { karte: k });\n                }), (0, _mithril2.default)('button.btn.btn-danger', { onclick: removeSet(set) }, '«'), (0, _mithril2.default)('hr')]);\n            }), (0, _mithril2.default)('hr'), (0, _mithril2.default)('h1', 'Sets Player 1: ' + setsOfPlayer1.length + ' ', (0, _mithril2.default)('button.btn.btn-primary', { onclick: function onclick() {\n                    return collapsed2 = !collapsed2;\n                } }, 'Zeigen')), collapsed2 ? null : setsOfPlayer1.map(function (set) {\n                return (0, _mithril2.default)('.row', [set.map(function (k) {\n                    return (0, _mithril2.default)(Karte, { karte: k });\n                }), (0, _mithril2.default)('hr')]);\n            }), (0, _mithril2.default)('hr'), (0, _mithril2.default)('h1', 'Sets Player 2: ' + setsOfPlayer2.length + ' ', (0, _mithril2.default)('button.btn.btn-primary', { onclick: function onclick() {\n                    return collapsed3 = !collapsed3;\n                } }, 'Zeigen')), collapsed3 ? null : setsOfPlayer2.map(function (set) {\n                return (0, _mithril2.default)('.row', [set.map(function (k) {\n                    return (0, _mithril2.default)(Karte, { karte: k });\n                }), (0, _mithril2.default)('hr')]);\n            })]);\n        }\n    }]);\n\n    return Router;\n}();\n\nexports.default = Router;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3NldC5qcz9lYjE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XG5cbnZhciB0YXJnZXROdW1iZXIgPSAxNTtcblxudmFyIGlucHV0cyA9IFt7XG4gICAga2V5OiAwLFxuICAgIG51bWJlcjogMVxufSwge1xuICAgIGtleTogMSxcbiAgICBudW1iZXI6IDFcbn0sIHtcbiAgICBrZXk6IDIsXG4gICAgbnVtYmVyOiAxXG59XTtcblxudmFyIGZhcmJlbiA9IFsnRm9yZXN0R3JlZW4nLCAnRGFya1Zpb2xldCcsICdPcmFuZ2VSZWQnXTtcbnZhciBmb3JtZW4gPSBbMSwgMiwgM107XG52YXIgbXVzdGVycyA9IFsxLCAyLCAzXTtcbnZhciBhbnphaGxlbiA9IFsxLCAyLCAzXTtcblxudmFyIGNvdW50ID0gMDtcblxudmFyIGthcnRlID0gKGZhcmJlLCBmb3JtLCBtdXN0ZXIsIGFuemFobCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZhcmJlOiBmYXJiZSxcbiAgICAgICAgZm9ybTogZm9ybSxcbiAgICAgICAgbXVzdGVyOiBtdXN0ZXIsXG4gICAgICAgIGFuemFobDogYW56YWhsXG4gICAgfVxufTtcblxudmFyIGdldFRocmVlID0gYSA9PiB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGlmIChhLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aCAtIDI7IGkrKylcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGEubGVuZ3RoIC0gMTsgaisrKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSBqICsgMTsgayA8IGEubGVuZ3RoOyBrKyspXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFthW2ldLCBhW2pdLCBhW2tdXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgc2V0Q29uZGl0aW9uID0gKGYxLCBmMiwgZjMpID0+IHtcbiAgICByZXR1cm4gKChmMSA9PT0gZjIpICYmIChmMSA9PT0gZjMpKVxuICAgICAgICB8fCAoKGYxICE9PSBmMikgJiYgKGYxICE9PSBmMykgJiYgKGYyICE9PSBmMykpO1xufTtcblxudmFyIGlzU2V0ID0gKGsxLCBrMiwgazMpID0+IHtcbiAgICBpZiAoIShrMSAmJiBrMiAmJiBrMykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBwIGluIGsxKSB7XG4gICAgICAgIGlmICghc2V0Q29uZGl0aW9uKC4uLl8ucGx1Y2soW2sxLCBrMiwgazNdLCBwKSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxudmFyIGthcnRlbiA9IFtdO1xuXG5mYXJiZW4uZm9yRWFjaChmYXJiZSA9PiB7XG4gICAgZm9ybWVuLmZvckVhY2goZm9ybSA9PiB7XG4gICAgICAgIG11c3RlcnMuZm9yRWFjaChtdXN0ZXIgPT4ge1xuICAgICAgICAgICAgYW56YWhsZW4uZm9yRWFjaChhbnphaGwgPT4ge1xuICAgICAgICAgICAgICAgIGthcnRlbi5wdXNoKGthcnRlKGZhcmJlLCBmb3JtLCBtdXN0ZXIsIGFuemFobCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufSk7XG5cbnZhciBhdWZEZW1UaXNjaCA9IFtdO1xudmFyIHNldHMgPSBbXTtcblxudmFyIGNoZWNrRm9yU2V0ID0gKCkgPT4ge1xuICAgIHNldHMgPSBbXTtcbiAgICB2YXIgY29tYmlzID0gZ2V0VGhyZWUoYXVmRGVtVGlzY2gpO1xuICAgIGNvbnNvbGUubG9nKCdjb21iaXMnLCBjb21iaXMpO1xuICAgIGNvbWJpcy5mb3JFYWNoKGNvbWJpID0+IHtcbiAgICAgICAgaWYgKGlzU2V0KC4uLmNvbWJpKSkge1xuICAgICAgICAgICAgc2V0cy5wdXNoKGNvbWJpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5cbnZhciBkcmF3S2FydCA9ICgpID0+IHtcbiAgICBpZiAoa2FydGVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGlkeCA9IE1hdGgucmFuZG9tKCkgKiBrYXJ0ZW4ubGVuZ3RoO1xuICAgICAgICBhdWZEZW1UaXNjaC5wdXNoKGthcnRlbi5zcGxpY2UoaWR4LCAxKVswXSk7XG4gICAgfVxuICAgIGNoZWNrRm9yU2V0KCk7XG59XG5cbmNvbnNvbGUubG9nKCdjb3VudCcsIGthcnRlbik7XG5cbnZhciBzZWxlY3RlZEthcnRlbiA9IFtdO1xuXG52YXIgZXF1YWwgPSAoazEsIGsyKSA9PiB7XG4gICAgcmV0dXJuIGsxLmZvcm0gPT09IGsyLmZvcm0gJiZcbiAgICAgICAgazEuZmFyYmUgPT09IGsyLmZhcmJlICYmXG4gICAgICAgIGsxLmFuemFobCA9PT0gazIuYW56YWhsICYmXG4gICAgICAgIGsxLm11c3RlciA9PT0gazIubXVzdGVyO1xuXG59XG5cbnZhciBzZWxlY3QgPSAoa2FydGUpID0+ICgpID0+IHtcbiAgICBpZiAoXy5jb250YWlucyhzZWxlY3RlZEthcnRlbiwga2FydGUpKSB7XG4gICAgICAgIHNlbGVjdGVkS2FydGVuID0gXy5maWx0ZXIoc2VsZWN0ZWRLYXJ0ZW4sIChrYXJ0ZUluU2V0KSA9PiAhZXF1YWwoa2FydGVJblNldCwga2FydGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZEthcnRlbi5wdXNoKGthcnRlKTtcbiAgICB9XG4gICAgd2hpbGUgKHNlbGVjdGVkS2FydGVuLmxlbmd0aCA+IDMpXG4gICAgICAgIHNlbGVjdGVkS2FydGVuLnNwbGljZSgwLCAxKTtcbn1cblxuY2xhc3MgS2FydGUge1xuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgLy8gIGNvbnNvbGUubG9nKHZub2RlLmF0dHJzLmthcnRlKVxuICAgICAgICByZXR1cm4gbSgnLmNvbC1tZC0xLmNvbC14cy0xJyArIChfLmNvbnRhaW5zKHNlbGVjdGVkS2FydGVuLCB2bm9kZS5hdHRycy5rYXJ0ZSkgPyAnLmRlYnVnJyA6ICcnKSwge1xuICAgICAgICAgICAgc3R5bGU6ICdoZWlnaHQ6MTIwcHg7d2lkdGg6NTBweCcsXG4gICAgICAgICAgICBvbmNsaWNrOiBzZWxlY3Qodm5vZGUuYXR0cnMua2FydGUpXG4gICAgICAgIH0sXG4gICAgICAgICAgICBtKCcubXVzdGVyJyArIHZub2RlLmF0dHJzLmthcnRlLm11c3RlciArICcuZm9ybScgKyB2bm9kZS5hdHRycy5rYXJ0ZS5mb3JtLCB7XG4gICAgICAgICAgICAgICAgc3R5bGU6ICdoZWlnaHQ6JyArICh2bm9kZS5hdHRycy5rYXJ0ZS5hbnphaGwgKiAzMCkgKyAncHg7YmFja2dyb3VuZC1jb2xvcjonICsgdm5vZGUuYXR0cnMua2FydGUuZmFyYmVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxufVxuXG52YXIgcmVtb3ZlU2V0ID0gKHNldCkgPT4gKCkgPT4ge1xuICAgIGF1ZkRlbVRpc2NoID0gXy5maWx0ZXIoYXVmRGVtVGlzY2gsIGUgPT4gIV8uY29udGFpbnMoc2V0LCBlKSk7XG4gICAgY2hlY2tGb3JTZXQoKTtcbn1cblxudmFyIGNvbGxhcHNlZDEgPSB0cnVlO1xudmFyIGNvbGxhcHNlZDIgPSB0cnVlO1xudmFyIGNvbGxhcHNlZDMgPSB0cnVlO1xuXG52YXIgc2V0c09mUGxheWVyMSA9IFtdO1xudmFyIHNldHNPZlBsYXllcjIgPSBbXTtcblxudmFyIHNldDEgPSAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ3NldDEnKTtcbiAgICBpZiAoaXNTZXQoLi4uc2VsZWN0ZWRLYXJ0ZW4pKSB7XG4gICAgICAgIHJlbW92ZVNldChzZWxlY3RlZEthcnRlbikoKTtcbiAgICAgICAgc2V0c09mUGxheWVyMS5wdXNoKHNlbGVjdGVkS2FydGVuKTtcbiAgICB9XG4gICAgc2VsZWN0ZWRLYXJ0ZW49W107XG59XG5cbnZhciBzZXQyID0gKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdzZXQxJyk7XG4gICAgaWYgKGlzU2V0KC4uLnNlbGVjdGVkS2FydGVuKSkge1xuICAgICAgICByZW1vdmVTZXQoc2VsZWN0ZWRLYXJ0ZW4pKCk7XG4gICAgICAgIHNldHNPZlBsYXllcjIucHVzaChzZWxlY3RlZEthcnRlbik7XG4gICAgfVxuICAgIHNlbGVjdGVkS2FydGVuPVtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3V0ZXIge1xuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG0oJy5jb250YWluZXInLCBbXG4gICAgICAgICAgICBtKCdoMScsICdUaXNjaCAnICsgYXVmRGVtVGlzY2gubGVuZ3RoKSxcbiAgICAgICAgICAgIG0oJ2J1dHRvbi5idG4uYnRuLXByaW1hcnknLCB7IG9uY2xpY2s6IGUgPT4gZHJhd0thcnQoKSB9LCAnWmllaCcpLFxuICAgICAgICAgICAgbSgnYnV0dG9uLmJ0bi5idG4tc3VjY2VzcycsIHsgb25jbGljazogc2V0MSB9LCAnU2V0IFNwaWVsZXIgMScpLFxuICAgICAgICAgICAgbSgnYnV0dG9uLmJ0bi5idG4tc3VjY2VzcycsIHsgb25jbGljazogc2V0MiB9LCAnU2V0IFNwaWVsZXIgMicpLFxuICAgICAgICAgICAgbSgnLnJvdycsIFtcbiAgICAgICAgICAgICAgICBhdWZEZW1UaXNjaC5tYXAoayA9PiBtKEthcnRlLCB7IGthcnRlOiBrIH0pKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBtKCdocicpLFxuICAgICAgICAgICAgbSgnaDEnLCAnU2V0cyBhdWYgZGVtIFRpc2NoOiAnICsgc2V0cy5sZW5ndGgrJyAnLCBtKCdidXR0b24uYnRuLmJ0bi1wcmltYXJ5JywgeyBvbmNsaWNrOiAoKSA9PiBjb2xsYXBzZWQxID0gIWNvbGxhcHNlZDEgfSwgJ1plaWdlbicpKSxcbiAgICAgICAgICAgIGNvbGxhcHNlZDEgPyBudWxsIDogc2V0cy5tYXAoc2V0ID0+IG0oJy5yb3cnLCBbc2V0Lm1hcChrID0+IG0oS2FydGUsIHsga2FydGU6IGsgfSkpLCBtKCdidXR0b24uYnRuLmJ0bi1kYW5nZXInLCB7IG9uY2xpY2s6IHJlbW92ZVNldChzZXQpIH0sICfCqycpLCBtKCdocicpXSkpLFxuICAgICAgICAgICAgbSgnaHInKSxcbiAgICAgICAgICAgIG0oJ2gxJywgJ1NldHMgUGxheWVyIDE6ICcgKyBzZXRzT2ZQbGF5ZXIxLmxlbmd0aCsnICcsIG0oJ2J1dHRvbi5idG4uYnRuLXByaW1hcnknLCB7IG9uY2xpY2s6ICgpID0+IGNvbGxhcHNlZDIgPSAhY29sbGFwc2VkMiB9LCAnWmVpZ2VuJykpLFxuICAgICAgICAgICAgY29sbGFwc2VkMiA/IG51bGwgOiBzZXRzT2ZQbGF5ZXIxLm1hcChzZXQgPT4gbSgnLnJvdycsIFtzZXQubWFwKGsgPT4gbShLYXJ0ZSwgeyBrYXJ0ZTogayB9KSksIG0oJ2hyJyldKSksXG4gICAgICAgICAgICBtKCdocicpLFxuICAgICAgICAgICAgbSgnaDEnLCAnU2V0cyBQbGF5ZXIgMjogJyArIHNldHNPZlBsYXllcjIubGVuZ3RoKycgJywgbSgnYnV0dG9uLmJ0bi5idG4tcHJpbWFyeScsIHsgb25jbGljazogKCkgPT4gY29sbGFwc2VkMyA9ICFjb2xsYXBzZWQzIH0sICdaZWlnZW4nKSksXG4gICAgICAgICAgICBjb2xsYXBzZWQzID8gbnVsbCA6IHNldHNPZlBsYXllcjIubWFwKHNldCA9PiBtKCcucm93JywgW3NldC5tYXAoayA9PiBtKEthcnRlLCB7IGthcnRlOiBrIH0pKSwgbSgnaHInKV0pKVxuICAgICAgICBdKTtcbiAgICB9XG59XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvc2V0LmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFSQTtBQUNBO0FBU0E7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQURBO0FBSUE7Ozs7OztBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUlBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTs7Ozs7O0FBcEJBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/*!*****************************!*\
  !*** ./src/max_non_sets.js ***!
  \*****************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _underscore = __webpack_require__(/*! underscore */ 1);\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar targetNumber = 15;\n\nvar inputs = [{\n    key: 0,\n    number: 1\n}, {\n    key: 1,\n    number: 1\n}, {\n    key: 2,\n    number: 1\n}];\n\nvar farben = [1, 2, 3];\nvar formen = [1, 2, 3];\nvar musters = [1, 2, 3];\nvar anzahlen = [1, 2, 3];\n\nvar count = 0;\n\nvar karte = function karte(farbe, form, muster, anzahl) {\n    return {\n        farbe: farbe,\n        form: form,\n        muster: muster,\n        anzahl: anzahl\n    };\n};\n\nvar getThree = function getThree(a) {\n    var result = [];\n    if (a.length > 2) {\n        for (var i = 0; i < a.length - 2; i++) {\n            for (var j = i + 1; j < a.length - 1; j++) {\n                for (var k = j + 1; k < a.length; k++) {\n                    result.push([a[i], a[j], a[k]]);\n                }\n            }\n        }\n    }\n    return result;\n};\n\nvar setCondition = function setCondition(f1, f2, f3) {\n    return f1 === f2 && f1 === f3 || f1 !== f2 && f1 !== f3 && f2 !== f3;\n};\n\nvar isSet = function isSet(k1, k2, k3) {\n    for (var p in k1) {\n        if (!setCondition.apply(undefined, _toConsumableArray(_underscore2.default.pluck([k1, k2, k3], p)))) return false;\n    }\n    return true;\n};\n\nvar createCards = function createCards() {\n    var karten = [];\n\n    farben.forEach(function (farbe) {\n        formen.forEach(function (form) {\n            musters.forEach(function (muster) {\n                anzahlen.forEach(function (anzahl) {\n                    karten.push(karte(farbe, form, muster, anzahl));\n                });\n            });\n        });\n    });\n    /*\n    karten = [];\n    \n    // Grün\n    // Eckig\n    karten.push(karte(2,2,2,1));\n    karten.push(karte(2,2,2,2));\n    karten.push(karte(2,2,1,1));\n    karten.push(karte(2,2,1,2));\n    \n    // Rund\n    karten.push(karte(2,1,2,3));\n    karten.push(karte(2,1,3,3));\n    \n    // Schwänzchen\n    karten.push(karte(2,3,3,3));\n    karten.push(karte(2,3,1,2));\n    karten.push(karte(2,3,1,1));\n    \n    // Rot\n    // Rund\n    karten.push(karte(1,1,1,1));\n    karten.push(karte(1,1,1,2));\n    karten.push(karte(1,1,3,3));\n    \n    // Eckig\n    karten.push(karte(1,2,2,1));\n    karten.push(karte(1,2,2,2));\n    karten.push(karte(1,2,1,1));\n    karten.push(karte(1,2,1,2));\n    \n    // Schwänzchen\n    karten.push(karte(1,3,3,3));\n    karten.push(karte(1,3,2,3));\n    \n    // Lila\n    karten.push(karte(3,3,2,3));\n    karten.push(karte(3,1,2,3));\n    \n    */\n    return karten;\n};\n\nvar getSets = function getSets(kartenMenge) {\n    var sets = [];\n    var combis = getThree(kartenMenge);\n    combis.forEach(function (combi) {\n        if (isSet.apply(undefined, _toConsumableArray(combi))) {\n            sets.push(combi);\n        }\n    });\n    return sets;\n};\n\nvar equal = function equal(k1, k2) {\n    return k1.form === k2.form && k1.farbe === k2.farbe && k1.anzahl === k2.anzahl && k1.muster === k2.muster;\n};\n\nvar drawKart = function drawKart() {\n    if (karten.length > 0) {\n        var idx = Math.random() * karten.length;\n        aufDemTisch.push(karten.splice(idx, 1)[0]);\n    }\n};\n\nvar cardToString = function cardToString(card) {\n    return '' + card.farbe + card.form + card.muster + card.anzahl;\n};\n\nvar countCardsInSets = function countCardsInSets(sets) {\n    var map = {};\n    sets.forEach(function (set) {\n        set.forEach(function (card) {\n            var key = cardToString(card);\n            if (!_underscore2.default.has(map, key)) {\n                map[key] = {\n                    count: 0,\n                    card: card\n                };\n            }\n            map[key].count++;\n        });\n    });\n    var cardCountInSet = [];\n\n    for (var prop in map) {\n        cardCountInSet.push(map[prop]);\n    }\n    return cardCountInSet;\n};\n\nvar f = function f() {\n    for (var k = 0; k < 50; k++) {\n\n        var karten = createCards();\n\n        var sorted = [];\n        var aufDemTisch = [];\n        for (var i = 0; i < 81; i++) {\n            drawKart();\n        }\n\n        while (true) {\n            var sets = getSets(aufDemTisch);\n            if (sets.length === 0) break;\n            var cardCountInSet = countCardsInSets(sets);\n            sorted = _underscore2.default.sortBy(cardCountInSet, 'count');\n            var idx = Math.floor(Math.random() * sorted.length);\n            aufDemTisch = _underscore2.default.filter(aufDemTisch, function (card) {\n                return !equal(card, sorted[idx].card);\n            });\n        }\n\n        console.log('aufDemTisch', aufDemTisch.length);\n    }\n};\n\nvar SetFragment = function () {\n    function SetFragment() {\n        _classCallCheck(this, SetFragment);\n    }\n\n    _createClass(SetFragment, [{\n        key: 'view',\n        value: function view(vnode) {\n            return (0, _mithril2.default)('h1', 'SetFragment');\n        }\n    }]);\n\n    return SetFragment;\n}();\n\nexports.default = SetFragment;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL21heF9ub25fc2V0cy5qcz8xYjg4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XG5cbnZhciB0YXJnZXROdW1iZXIgPSAxNTtcblxudmFyIGlucHV0cyA9IFt7XG4gICAga2V5OiAwLFxuICAgIG51bWJlcjogMVxufSwge1xuICAgIGtleTogMSxcbiAgICBudW1iZXI6IDFcbn0sIHtcbiAgICBrZXk6IDIsXG4gICAgbnVtYmVyOiAxXG59XTtcblxudmFyIGZhcmJlbiA9IFsxLCAyLCAzXTtcbnZhciBmb3JtZW4gPSBbMSwgMiwgM107XG52YXIgbXVzdGVycyA9IFsxLCAyLCAzXTtcbnZhciBhbnphaGxlbiA9IFsxLCAyLCAzXTtcblxudmFyIGNvdW50ID0gMDtcblxudmFyIGthcnRlID0gKGZhcmJlLCBmb3JtLCBtdXN0ZXIsIGFuemFobCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZhcmJlOiBmYXJiZSxcbiAgICAgICAgZm9ybTogZm9ybSxcbiAgICAgICAgbXVzdGVyOiBtdXN0ZXIsXG4gICAgICAgIGFuemFobDogYW56YWhsXG4gICAgfVxufTtcblxudmFyIGdldFRocmVlID0gYSA9PiB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGlmIChhLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aCAtIDI7IGkrKylcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGEubGVuZ3RoIC0gMTsgaisrKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSBqICsgMTsgayA8IGEubGVuZ3RoOyBrKyspXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFthW2ldLCBhW2pdLCBhW2tdXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgc2V0Q29uZGl0aW9uID0gKGYxLCBmMiwgZjMpID0+IHtcbiAgICByZXR1cm4gKChmMSA9PT0gZjIpICYmIChmMSA9PT0gZjMpKVxuICAgICAgICB8fCAoKGYxICE9PSBmMikgJiYgKGYxICE9PSBmMykgJiYgKGYyICE9PSBmMykpO1xufTtcblxudmFyIGlzU2V0ID0gKGsxLCBrMiwgazMpID0+IHtcbiAgICBmb3IgKGxldCBwIGluIGsxKSB7XG4gICAgICAgIGlmICghc2V0Q29uZGl0aW9uKC4uLl8ucGx1Y2soW2sxLCBrMiwgazNdLCBwKSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxudmFyIGNyZWF0ZUNhcmRzID0gKCkgPT4ge1xuICAgIHZhciBrYXJ0ZW4gPSBbXTtcblxuICAgIGZhcmJlbi5mb3JFYWNoKGZhcmJlID0+IHtcbiAgICAgICAgZm9ybWVuLmZvckVhY2goZm9ybSA9PiB7XG4gICAgICAgICAgICBtdXN0ZXJzLmZvckVhY2gobXVzdGVyID0+IHtcbiAgICAgICAgICAgICAgICBhbnphaGxlbi5mb3JFYWNoKGFuemFobCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGthcnRlbi5wdXNoKGthcnRlKGZhcmJlLCBmb3JtLCBtdXN0ZXIsIGFuemFobCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8qXG4gICAga2FydGVuID0gW107XG4gICAgXG4gICAgLy8gR3LDvG5cbiAgICAvLyBFY2tpZ1xuICAgIGthcnRlbi5wdXNoKGthcnRlKDIsMiwyLDEpKTtcbiAgICBrYXJ0ZW4ucHVzaChrYXJ0ZSgyLDIsMiwyKSk7XG4gICAga2FydGVuLnB1c2goa2FydGUoMiwyLDEsMSkpO1xuICAgIGthcnRlbi5wdXNoKGthcnRlKDIsMiwxLDIpKTtcbiAgICBcbiAgICAvLyBSdW5kXG4gICAga2FydGVuLnB1c2goa2FydGUoMiwxLDIsMykpO1xuICAgIGthcnRlbi5wdXNoKGthcnRlKDIsMSwzLDMpKTtcbiAgICBcbiAgICAvLyBTY2h3w6RuemNoZW5cbiAgICBrYXJ0ZW4ucHVzaChrYXJ0ZSgyLDMsMywzKSk7XG4gICAga2FydGVuLnB1c2goa2FydGUoMiwzLDEsMikpO1xuICAgIGthcnRlbi5wdXNoKGthcnRlKDIsMywxLDEpKTtcbiAgICBcbiAgICAvLyBSb3RcbiAgICAvLyBSdW5kXG4gICAga2FydGVuLnB1c2goa2FydGUoMSwxLDEsMSkpO1xuICAgIGthcnRlbi5wdXNoKGthcnRlKDEsMSwxLDIpKTtcbiAgICBrYXJ0ZW4ucHVzaChrYXJ0ZSgxLDEsMywzKSk7XG4gICAgXG4gICAgLy8gRWNraWdcbiAgICBrYXJ0ZW4ucHVzaChrYXJ0ZSgxLDIsMiwxKSk7XG4gICAga2FydGVuLnB1c2goa2FydGUoMSwyLDIsMikpO1xuICAgIGthcnRlbi5wdXNoKGthcnRlKDEsMiwxLDEpKTtcbiAgICBrYXJ0ZW4ucHVzaChrYXJ0ZSgxLDIsMSwyKSk7XG4gICAgXG4gICAgLy8gU2Nod8OkbnpjaGVuXG4gICAga2FydGVuLnB1c2goa2FydGUoMSwzLDMsMykpO1xuICAgIGthcnRlbi5wdXNoKGthcnRlKDEsMywyLDMpKTtcbiAgICBcbiAgICAvLyBMaWxhXG4gICAga2FydGVuLnB1c2goa2FydGUoMywzLDIsMykpO1xuICAgIGthcnRlbi5wdXNoKGthcnRlKDMsMSwyLDMpKTtcbiAgICBcbiAgICAqL1xuICAgIHJldHVybiBrYXJ0ZW47XG59O1xuXG52YXIgZ2V0U2V0cyA9IChrYXJ0ZW5NZW5nZSkgPT4ge1xuICAgIGxldCBzZXRzID0gW107XG4gICAgdmFyIGNvbWJpcyA9IGdldFRocmVlKGthcnRlbk1lbmdlKTtcbiAgICBjb21iaXMuZm9yRWFjaChjb21iaSA9PiB7XG4gICAgICAgIGlmIChpc1NldCguLi5jb21iaSkpIHtcbiAgICAgICAgICAgIHNldHMucHVzaChjb21iaSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2V0cztcbn1cblxudmFyIGVxdWFsID0gKGsxLCBrMikgPT4ge1xuICAgIHJldHVybiBrMS5mb3JtID09PSBrMi5mb3JtICYmXG4gICAgICAgIGsxLmZhcmJlID09PSBrMi5mYXJiZSAmJlxuICAgICAgICBrMS5hbnphaGwgPT09IGsyLmFuemFobCAmJlxuICAgICAgICBrMS5tdXN0ZXIgPT09IGsyLm11c3Rlcjtcbn1cblxuXG5cbnZhciBkcmF3S2FydCA9ICgpID0+IHtcbiAgICBpZiAoa2FydGVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGlkeCA9IE1hdGgucmFuZG9tKCkgKiBrYXJ0ZW4ubGVuZ3RoO1xuICAgICAgICBhdWZEZW1UaXNjaC5wdXNoKGthcnRlbi5zcGxpY2UoaWR4LCAxKVswXSk7XG4gICAgfVxufVxuXG52YXIgY2FyZFRvU3RyaW5nID0gKGNhcmQpID0+IHtcbiAgICByZXR1cm4gJycgKyBjYXJkLmZhcmJlICsgY2FyZC5mb3JtICsgY2FyZC5tdXN0ZXIgKyBjYXJkLmFuemFobDtcbn1cblxudmFyIGNvdW50Q2FyZHNJblNldHMgPSAoc2V0cykgPT4ge1xuICAgIGxldCBtYXAgPSB7fTtcbiAgICBzZXRzLmZvckVhY2goc2V0ID0+IHtcbiAgICAgICAgc2V0LmZvckVhY2goY2FyZCA9PiB7XG4gICAgICAgICAgICBsZXQga2V5ID0gY2FyZFRvU3RyaW5nKGNhcmQpO1xuICAgICAgICAgICAgaWYgKCFfLmhhcyhtYXAsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBtYXBba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGNhcmQ6IGNhcmRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFwW2tleV0uY291bnQrKztcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgbGV0IGNhcmRDb3VudEluU2V0ID0gW107XG5cbiAgICBmb3IgKGxldCBwcm9wIGluIG1hcCkge1xuICAgICAgICBjYXJkQ291bnRJblNldC5wdXNoKG1hcFtwcm9wXSk7XG4gICAgfVxuICAgIHJldHVybiBjYXJkQ291bnRJblNldDtcbn07XG5cbnZhciBmID0gKCkgPT4geyBcbmZvciAobGV0IGsgPSAwOyBrIDwgNTA7IGsrKykge1xuXG4gICAgdmFyIGthcnRlbiA9IGNyZWF0ZUNhcmRzKCk7XG5cbiAgICB2YXIgc29ydGVkID0gW107XG4gICAgdmFyIGF1ZkRlbVRpc2NoID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MTsgaSsrKSB7XG4gICAgICAgIGRyYXdLYXJ0KCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IHNldHMgPSBnZXRTZXRzKGF1ZkRlbVRpc2NoKTtcbiAgICAgICAgaWYgKHNldHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHZhciBjYXJkQ291bnRJblNldCA9IGNvdW50Q2FyZHNJblNldHMoc2V0cyk7XG4gICAgICAgIHNvcnRlZCA9IF8uc29ydEJ5KGNhcmRDb3VudEluU2V0LCAnY291bnQnKTtcbiAgICAgICAgdmFyIGlkeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHNvcnRlZC5sZW5ndGgpO1xuICAgICAgICBhdWZEZW1UaXNjaCA9IF8uZmlsdGVyKGF1ZkRlbVRpc2NoLCBjYXJkID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhZXF1YWwoY2FyZCwgc29ydGVkW2lkeF0uY2FyZCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdhdWZEZW1UaXNjaCcsIGF1ZkRlbVRpc2NoLmxlbmd0aCk7XG59XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNldEZyYWdtZW50IHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIHJldHVybiBtKCdoMScsICdTZXRGcmFnbWVudCcpXG4gICAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF4X25vbl9zZXRzLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBSEEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/*!*********************!*\
  !*** ./src/todo.js ***!
  \*********************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Todo = function () {\n    function Todo(_ref) {\n        var _ref$description = _ref.description,\n            description = _ref$description === undefined ? \"Learn mithril\" : _ref$description,\n            _ref$completed = _ref.completed,\n            completed = _ref$completed === undefined ? false : _ref$completed,\n            _ref$edits = _ref.edits,\n            edits = _ref$edits === undefined ? null : _ref$edits,\n            _ref$id = _ref.id,\n            id = _ref$id === undefined ? 0 : _ref$id;\n\n        _classCallCheck(this, Todo);\n\n        this.description = description;\n        this.completed = completed;\n        this.edits = edits;\n        this.id = id;\n    }\n\n    _createClass(Todo, [{\n        key: 'setCompleted',\n        value: function setCompleted(val) {\n            this.completed = val;\n            console.log('complete', this.completed, val);\n            store(todoList);\n        }\n    }, {\n        key: 'getCompleted',\n        value: function getCompleted() {\n            return this.completed;\n        }\n    }]);\n\n    return Todo;\n}();\n\nvar TodoList = function () {\n    function TodoList() {\n        var todos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n        _classCallCheck(this, TodoList);\n\n        this.todos = todos.map(function (t) {\n            return new Todo(t);\n        });\n    }\n\n    _createClass(TodoList, [{\n        key: 'addTodo',\n        value: function addTodo(todo) {\n            this.todos.push(todo);\n            store(this);\n        }\n    }, {\n        key: 'getTodos',\n        value: function getTodos() {\n            return this.todos;\n        }\n    }, {\n        key: 'removeTodo',\n        value: function removeTodo(todo) {\n            this.todos = this.todos.filter(function (t) {\n                return t.description !== todo.description;\n            });\n            store(this);\n        }\n    }]);\n\n    return TodoList;\n}();\n\nvar loadOrCreate = function loadOrCreate() {\n    try {\n        var result = localStorage.getItem('todos');\n        return new TodoList(JSON.parse(result) || []);\n    } catch (error) {\n        return new TodoList([]);\n    }\n};\n\nvar store = function store(todoList) {\n    localStorage.setItem('todos', JSON.stringify(todoList.getTodos()));\n};\n\nvar todoList = loadOrCreate();\n\nconsole.log('todos', todoList);\n\nvar TodoItemView = function () {\n    function TodoItemView() {\n        _classCallCheck(this, TodoItemView);\n    }\n\n    _createClass(TodoItemView, [{\n        key: 'view',\n        value: function view(vnode) {\n            return [(0, _mithril2.default)(\".input-group\", [(0, _mithril2.default)(\"span.input-group-addon\", (0, _mithril2.default)(\"input[aria-label='...'][type='checkbox']\", {\n                checked: vnode.attrs.todo.getCompleted(),\n                onchange: function onchange(ev) {\n                    console.log(ev);vnode.attrs.todo.setCompleted(ev.target.checked);\n                }\n            })), (0, _mithril2.default)(\"input.form-control[aria-label='...'][type='text']\", { value: vnode.attrs.todo.description }), (0, _mithril2.default)(\".input-group-btn\", [(0, _mithril2.default)(\"button.btn.btn-default[aria-label='Help'][type='button']\", {\n                onclick: function onclick(ev) {\n                    return todoList.removeTodo(vnode.attrs.todo);\n                }\n            }, (0, _mithril2.default)(\"span.glyphicon.glyphicon-remove\"))])])];\n        }\n    }]);\n\n    return TodoItemView;\n}();\n\nvar TodoListView = function () {\n    function TodoListView() {\n        _classCallCheck(this, TodoListView);\n    }\n\n    _createClass(TodoListView, [{\n        key: 'addTodo',\n        value: function addTodo() {}\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            return [(0, _mithril2.default)(\".input-group\", [(0, _mithril2.default)(\"input.form-control[placeholder='Search for...'][type='text']\", {\n                onchange: function onchange(ev) {\n                    _this.description = ev.target.value;\n                }\n            }), (0, _mithril2.default)(\"span.input-group-btn\", (0, _mithril2.default)(\"button.btn.btn-default[type='button']\", {\n                onclick: function onclick(ev) {\n                    vnode.attrs.todoList.addTodo(new Todo({ description: _this.description }));\n                }\n            }, \"+\"))]), (0, _mithril2.default)('.list-group', vnode.attrs.todoList.getTodos().map(function (todo) {\n                return (0, _mithril2.default)(TodoItemView, { todo: todo });\n            }))];\n        }\n    }]);\n\n    return TodoListView;\n}();\n\nvar TodoApp = function () {\n    function TodoApp() {\n        _classCallCheck(this, TodoApp);\n    }\n\n    _createClass(TodoApp, [{\n        key: 'view',\n        value: function view(vnode) {\n            return (0, _mithril2.default)('.container', [(0, _mithril2.default)('h1', 'todos'), (0, _mithril2.default)(TodoListView, { todoList: todoList })]);\n        }\n    }]);\n\n    return TodoApp;\n}();\n\nexports.default = TodoApp;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3RvZG8uanM/OGIzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuY2xhc3MgVG9kbyB7XG4gICAgY29uc3RydWN0b3IoeyBkZXNjcmlwdGlvbiA9IFwiTGVhcm4gbWl0aHJpbFwiLCBjb21wbGV0ZWQgPSBmYWxzZSwgZWRpdHMgPSBudWxsLCBpZCA9IDAgfSkge1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuY29tcGxldGVkID0gY29tcGxldGVkO1xuICAgICAgICB0aGlzLmVkaXRzID0gZWRpdHM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG4gICAgc2V0Q29tcGxldGVkKHZhbCkge1xuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IHZhbDtcbiAgICAgICAgY29uc29sZS5sb2coJ2NvbXBsZXRlJywgdGhpcy5jb21wbGV0ZWQsIHZhbClcbiAgICAgICAgc3RvcmUodG9kb0xpc3QpO1xuICAgIH1cbiAgICBnZXRDb21wbGV0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlZDtcbiAgICB9XG59XG5cbmNsYXNzIFRvZG9MaXN0IHtcbiAgICBjb25zdHJ1Y3Rvcih0b2RvcyA9IFtdKSB7XG4gICAgICAgIHRoaXMudG9kb3MgPSB0b2Rvcy5tYXAodCA9PiBuZXcgVG9kbyh0KSk7XG4gICAgfVxuICAgIGFkZFRvZG8odG9kbykge1xuICAgICAgICB0aGlzLnRvZG9zLnB1c2godG9kbyk7XG4gICAgICAgIHN0b3JlKHRoaXMpO1xuICAgIH1cbiAgICBnZXRUb2RvcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9kb3M7XG4gICAgfVxuICAgIHJlbW92ZVRvZG8odG9kbykge1xuICAgICAgICB0aGlzLnRvZG9zID0gdGhpcy50b2Rvcy5maWx0ZXIodCA9PiB0LmRlc2NyaXB0aW9uICE9PSB0b2RvLmRlc2NyaXB0aW9uKTtcbiAgICAgICAgc3RvcmUodGhpcyk7XG4gICAgfVxufVxuXG52YXIgbG9hZE9yQ3JlYXRlID0gKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9kb3MnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUb2RvTGlzdChKU09OLnBhcnNlKHJlc3VsdCkgfHwgW10pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9kb0xpc3QoW10pO1xuICAgIH1cbn07XG5cbnZhciBzdG9yZSA9ICh0b2RvTGlzdCkgPT4ge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd0b2RvcycsIEpTT04uc3RyaW5naWZ5KHRvZG9MaXN0LmdldFRvZG9zKCkpKTtcbn1cblxudmFyIHRvZG9MaXN0ID0gbG9hZE9yQ3JlYXRlKCk7XG5cbmNvbnNvbGUubG9nKCd0b2RvcycsIHRvZG9MaXN0KTtcblxuY2xhc3MgVG9kb0l0ZW1WaWV3IHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtKFwiLmlucHV0LWdyb3VwXCIsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBtKFwic3Bhbi5pbnB1dC1ncm91cC1hZGRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcImlucHV0W2FyaWEtbGFiZWw9Jy4uLiddW3R5cGU9J2NoZWNrYm94J11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IHZub2RlLmF0dHJzLnRvZG8uZ2V0Q29tcGxldGVkKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25jaGFuZ2U6IGV2ID0+IHsgY29uc29sZS5sb2coZXYpOyB2bm9kZS5hdHRycy50b2RvLnNldENvbXBsZXRlZChldi50YXJnZXQuY2hlY2tlZCkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgbShcImlucHV0LmZvcm0tY29udHJvbFthcmlhLWxhYmVsPScuLi4nXVt0eXBlPSd0ZXh0J11cIiwgeyB2YWx1ZTogdm5vZGUuYXR0cnMudG9kby5kZXNjcmlwdGlvbiB9KSxcbiAgICAgICAgICAgICAgICAgICAgbShcIi5pbnB1dC1ncm91cC1idG5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiYnV0dG9uLmJ0bi5idG4tZGVmYXVsdFthcmlhLWxhYmVsPSdIZWxwJ11bdHlwZT0nYnV0dG9uJ11cIix7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGV2PT50b2RvTGlzdC5yZW1vdmVUb2RvKHZub2RlLmF0dHJzLnRvZG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcInNwYW4uZ2x5cGhpY29uLmdseXBoaWNvbi1yZW1vdmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKVxuICAgICAgICBdO1xuICAgIH1cbn1cblxuY2xhc3MgVG9kb0xpc3RWaWV3IHtcbiAgICBhZGRUb2RvKCkge1xuICAgIH1cbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtKFwiLmlucHV0LWdyb3VwXCIsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBtKFwiaW5wdXQuZm9ybS1jb250cm9sW3BsYWNlaG9sZGVyPSdTZWFyY2ggZm9yLi4uJ11bdHlwZT0ndGV4dCddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2hhbmdlOiAoZXYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZXYudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgbShcInNwYW4uaW5wdXQtZ3JvdXAtYnRuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtKFwiYnV0dG9uLmJ0bi5idG4tZGVmYXVsdFt0eXBlPSdidXR0b24nXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljazogKGV2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLmF0dHJzLnRvZG9MaXN0LmFkZFRvZG8obmV3IFRvZG8oeyBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbiB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIitcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG0oJy5saXN0LWdyb3VwJyxcbiAgICAgICAgICAgICAgICB2bm9kZS5hdHRycy50b2RvTGlzdC5nZXRUb2RvcygpLm1hcCh0b2RvID0+XG4gICAgICAgICAgICAgICAgICAgIG0oVG9kb0l0ZW1WaWV3LCB7IHRvZG86IHRvZG8gfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgIF07XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb2RvQXBwIHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIHJldHVybiBtKCcuY29udGFpbmVyJywgW1xuICAgICAgICAgICAgbSgnaDEnLCAndG9kb3MnKSxcbiAgICAgICAgICAgIG0oVG9kb0xpc3RWaWV3LCB7IHRvZG9MaXN0IH0pXG4gICAgICAgIF0pO1xuICAgIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RvZG8uanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTs7Ozs7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFTQTtBQUFBO0FBQUE7QUFEQTtBQVVBOzs7Ozs7QUFHQTs7Ozs7OztBQUNBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUhBO0FBT0E7QUFDQTtBQUNBO0FBSEE7QUFXQTtBQUFBO0FBS0E7Ozs7OztBQUdBOzs7Ozs7O0FBQ0E7QUFDQTtBQUlBOzs7Ozs7QUFOQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/*!***********************!*\
  !*** ./src/queens.js ***!
  \***********************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar optional = function optional(value) {\n    var isPresent = function isPresent() {\n        return !!value;\n    };\n    var map = function map(fn) {\n        return isPresent() ? optional(fn(value)) : optional(null);\n    };\n    var ifPresent = function ifPresent(fn) {\n        return isPresent() ? fn(value) : null;\n    };\n    return {\n        isPresent: isPresent,\n        map: map,\n        ifPresent: ifPresent\n    };\n};\n\nvar plus = function plus(a, b) {\n    return a + b;\n};\n\nvar range = function range(startInclusive, endExclusive) {\n    var result = [];\n    for (var i = startInclusive; i < endExclusive; i++) {\n        result.push(i);\n    }\n    return result;\n};\n\nvar nFrom = function nFrom(start, number) {\n    return range(start, start + number);\n};\n\nvar interval = function interval(startInclusive, endInclusive) {\n    return range(startInclusive, endInclusive + 1);\n};\n\nvar zipWith = function zipWith(fn) {\n    for (var _len = arguments.length, arrs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        arrs[_key - 1] = arguments[_key];\n    }\n\n    return range(0, Math.min.apply(Math, _toConsumableArray(arrs.map(function (arr) {\n        return arr.length;\n    })))).map(function (i) {\n        return fn.apply(undefined, _toConsumableArray(arrs.map(function (arr) {\n            return arr[i];\n        })));\n    });\n};\n\nvar tail = function tail(arr) {\n    return arr[arr.length - 1];\n};\n\nvar head = function head(arr) {\n    return arr[0];\n};\n\nvar withoutLast = function withoutLast() {\n    var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    return arr.length > 1 ? arr.slice(0, arr.length - 1) : [];\n};\n\nvar flatten = function flatten(arr) {\n    var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n\n    var merged = [];\n    for (var step = 0; step < depth; step++) {\n        if (merged.length === 0) {\n            merged = arr.slice(0);\n        }\n        var l1 = merged.length;\n        merged = [].concat.apply([], merged);\n        var l2 = merged.length;\n        if (l1 === l2) break;\n    }\n    return merged;\n};\n\nvar testOk = function testOk() {\n    console.log('true?', okToAdd(1, id, []));\n    console.log('false?', okToAdd(0, id, [0]));\n    console.log('true?', okToAdd(1, id, [0]));\n    console.log('true?', okToAdd(1, id, [0, 4, 2]));\n    console.log('false?', okToAdd(2, succ, [0, 4, 3]));\n    console.log('true?', okToAdd(3, succ, [0, 3, 2]));\n    console.log('false?', okToAdd(3, pred, [0, 4, 2]));\n    console.log('false?', okToAdd(1, succ, [0, 4, 2]));\n\n    console.log('', zipWith(function (a, b) {\n        return a + b;\n    }, ['a', 'b', 'c', 'd'], [1, 2, 3]));\n    console.log('true?', nFrom(0, 8).length === 8);\n    console.log('true?', interval(0, 3).length === range(0, 4).length);\n\n    console.log(optional(null).map(function (e) {\n        return plus(1, e);\n    }));\n    optional('nullo').map(function (e) {\n        return plus(1, e);\n    }).ifPresent(console.log);\n\n    console.log('[0,0]?', flatten([0, 0]));\n    console.log('[0,0]?', flatten([0, [0]]));\n    console.log('[0,0]?', flatten([[0], 0]));\n    console.log('[0,0,0,0]?', flatten([0, [0, [0], [0]]]));\n    console.log('[0,0,[0],[0]]?', flatten([0, [0, [0], [0]]], 1));\n    console.log('[0,0,{help: \"help\"}]?', flatten([[0, 0], {\n        help: \"help\"\n    }]));\n};\n\nvar transpose = function transpose(solution) {\n    var transposed = [];\n    solution.forEach(function (v, i) {\n        transposed[v] = i;\n    });\n    return transposed;\n};\n\nvar flip = function flip(solution) {\n    var flipped = [];\n    solution.forEach(function (v, i) {\n        return flipped[i] = size_ - 1 - v;\n    });\n    return flipped;\n};\n\nvar flipY = function flipY(solution) {\n    var flipped = [];\n    solution.forEach(function (v, i) {\n        return flipped[size_ - 1 - i] = v;\n    });\n    return flipped;\n};\n\nvar comp = function comp(a, b) {\n    return a.every(function (v, i) {\n        return b[i] === v;\n    });\n};\n\nvar foldLeft = function foldLeft(arr, start, fn) {\n    return arr.reduce(fn, start);\n};\nvar foldRight = function foldRight(arr, start, fn) {\n    return arr.reverse().reduce(fn, start);\n};\n\nvar and = function and(acc, curr) {\n    return acc && curr;\n};\n\nvar id = function id(n) {\n    return n;\n};\nvar succ = function succ(n) {\n    return n + 1;\n};\nvar pred = function pred(n) {\n    return n - 1;\n};\n\nvar directions = [id, succ, pred];\n\n// \nvar okToAdd = function okToAdd(pos, walk, partialSolution) {\n    return partialSolution.length === 0 ? true : tail(partialSolution) === walk(pos) ? false : okToAdd(walk(pos), walk, withoutLast(partialSolution));\n};\n\nvar fieldOk = function fieldOk(pos) {\n    var partialSolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    return directions.map(function (d) {\n        return okToAdd(pos, d, partialSolution);\n    }).reduce(and, true);\n};\n\n// Given one partial solution returns a list of all\n// extended solutions of the partial one.\nvar extendSolution = function extendSolution() {\n    var partialSolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n\n    return range(0, size).filter(function (newField) {\n        return fieldOk(newField, partialSolution);\n    }).map(function (newField) {\n        return partialSolution.concat(newField);\n    });\n};\n\n// \nvar allSolutions = function allSolutions() {\n    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n    var solutions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [[]];\n\n    return solutions.length > 0 && solutions[0].length === size ? solutions : allSolutions(size, flatten(solutions.map(function (solution) {\n        return extendSolution(solution, size);\n    }), 1));\n};\n\nvar size_ = 8;\n\nvar setSize = function setSize(size) {\n    size_ = size;\n    solutions = allSolutions(size_);\n    console.log('size', size);\n};\n\nvar solutions = allSolutions(size_);\n\nvar solutions_ = [];\n\nvar pipe = function pipe(fns, obj) {\n    var r = obj;\n    fns.map(function (f) {\n        r = f(r);\n    });\n    return r;\n};\n\nvar sym = [[id], [transpose], [flip], [transpose, flip], [flipY], [transpose, flipY], [flip, flipY], [transpose, flip, flipY]];\nvar symmetrics = function symmetrics(solution) {\n    return sym.map(function (s) {\n        return pipe(s, solution);\n    });\n};\n\nsolutions.forEach(function (solution) {\n\n    var differentFromAllExisting = solutions_.map(function (exsol) {\n        return symmetrics(exsol).every(function (symsol) {\n            return !comp(symsol, solution);\n        });\n    }).every(function (b) {\n        return b === true;\n    });\n\n    if (differentFromAllExisting) solutions_.push(solution);\n\n    console.log(differentFromAllExisting, 'different');\n    //\t\n});\n\nconsole.log('length', solutions_.length);\n\nvar SolutionView = function () {\n    function SolutionView() {\n        _classCallCheck(this, SolutionView);\n    }\n\n    _createClass(SolutionView, [{\n        key: 'view',\n        value: function view(vnode) {\n            console.log('vnode.dom', this.dom);\n            return (0, _mithril2.default)('table', range(0, size_).map(function (row) {\n                return (0, _mithril2.default)('tr', range(0, size_).map(function (column) {\n                    return (0, _mithril2.default)('td', {\n                        style: 'border-style:solid; border-width:1px;border-color:lightgray;height:' + vnode.attrs.size + 'px;width:' + vnode.attrs.size + 'px;' + ['background-color:red;\\n                    -webkit-border-radius: ' + vnode.attrs.size / 2 + 'px;\\n                    -moz-border-radius: ' + vnode.attrs.size / 2 + 'px;\\n                    border-radius: ' + vnode.attrs.size / 2 + 'px;', 'background-color:white', 'background-color:black'][vnode.attrs.solution[row] === column ? 0 : (row + column) % 2 ? 1 : 2]\n                    }, ' ');\n                }));\n            }));\n        }\n    }]);\n\n    return SolutionView;\n}();\n\nvar Comp = function () {\n    function Comp() {\n        _classCallCheck(this, Comp);\n    }\n\n    _createClass(Comp, [{\n        key: 'view',\n        value: function view(vnode) {\n            return (0, _mithril2.default)('.container', (0, _mithril2.default)('h1', 'Queens ' + size_ + 'x' + size_ + ' has ' + solutions.length + ' solutions'), (0, _mithril2.default)('.form-group', (0, _mithril2.default)('input', {\n                type: 'range',\n                min: 4,\n                max: 8,\n                onchange: function onchange(ev) {\n                    return setSize(ev.target.valueAsNumber);\n                }\n            })), (0, _mithril2.default)('.row', [solutions.map(function (solution) {\n                return (0, _mithril2.default)('.col-md-4.col-xs-12', {\n                    style: 'margin-bottom:40px'\n                }, (0, _mithril2.default)(SolutionView, {\n                    solution: solution,\n                    size: 30\n                }));\n            })]));\n        }\n    }]);\n\n    return Comp;\n}();\n\nexports.default = Comp;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3F1ZWVucy5qcz9iOTE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG52YXIgb3B0aW9uYWwgPSAodmFsdWUpID0+IHtcbiAgICB2YXIgaXNQcmVzZW50ID0gKCkgPT4gISF2YWx1ZTtcbiAgICB2YXIgbWFwID0gZm4gPT4gaXNQcmVzZW50KCkgPyBvcHRpb25hbChmbih2YWx1ZSkpIDogb3B0aW9uYWwobnVsbCk7XG4gICAgdmFyIGlmUHJlc2VudCA9IGZuID0+IGlzUHJlc2VudCgpID8gZm4odmFsdWUpIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc1ByZXNlbnQsXG4gICAgICAgIG1hcCxcbiAgICAgICAgaWZQcmVzZW50XG4gICAgfTtcbn07XG5cbnZhciBwbHVzID0gKGEsIGIpID0+IGEgKyBiO1xuXG52YXIgcmFuZ2UgPSAoc3RhcnRJbmNsdXNpdmUsIGVuZEV4Y2x1c2l2ZSkgPT4ge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmNsdXNpdmU7IGkgPCBlbmRFeGNsdXNpdmU7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBuRnJvbSA9IChzdGFydCwgbnVtYmVyKSA9PiB7XG4gICAgcmV0dXJuIHJhbmdlKHN0YXJ0LCBzdGFydCArIG51bWJlcik7XG59O1xuXG52YXIgaW50ZXJ2YWwgPSAoc3RhcnRJbmNsdXNpdmUsIGVuZEluY2x1c2l2ZSkgPT4ge1xuICAgIHJldHVybiByYW5nZShzdGFydEluY2x1c2l2ZSwgZW5kSW5jbHVzaXZlICsgMSk7XG59O1xuXG52YXIgemlwV2l0aCA9IChmbiwgLi4uYXJycykgPT4ge1xuICAgIHJldHVybiByYW5nZSgwLCBNYXRoLm1pbiguLi5hcnJzLm1hcChhcnIgPT4gYXJyLmxlbmd0aCkpKS5cbiAgICBtYXAoaSA9PiBmbiguLi4oYXJycy5tYXAoYXJyID0+IGFycltpXSkpKSk7XG59O1xuXG52YXIgdGFpbCA9IGFyciA9PiB7XG4gICAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG59XG5cbnZhciBoZWFkID0gYXJyID0+IHtcbiAgICByZXR1cm4gYXJyWzBdO1xufVxuXG52YXIgd2l0aG91dExhc3QgPSAoYXJyID0gW10pID0+IHtcbiAgICByZXR1cm4gYXJyLmxlbmd0aCA+IDEgPyBhcnIuc2xpY2UoMCwgYXJyLmxlbmd0aCAtIDEpIDogW107XG59XG5cbnZhciBmbGF0dGVuID0gKGFyciwgZGVwdGggPSAxMDApID0+IHtcbiAgICB2YXIgbWVyZ2VkID0gW107XG4gICAgZm9yIChsZXQgc3RlcCA9IDA7IHN0ZXAgPCBkZXB0aDsgc3RlcCsrKSB7XG4gICAgICAgIGlmIChtZXJnZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtZXJnZWQgPSBhcnIuc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGwxID0gbWVyZ2VkLmxlbmd0aDtcbiAgICAgICAgbWVyZ2VkID0gW10uY29uY2F0LmFwcGx5KFtdLCBtZXJnZWQpO1xuICAgICAgICBsZXQgbDIgPSBtZXJnZWQubGVuZ3RoO1xuICAgICAgICBpZiAobDEgPT09IGwyKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWQ7XG59O1xuXG52YXIgdGVzdE9rID0gKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCd0cnVlPycsIG9rVG9BZGQoMSwgaWQsIFtdKSk7XG4gICAgY29uc29sZS5sb2coJ2ZhbHNlPycsIG9rVG9BZGQoMCwgaWQsIFswXSkpO1xuICAgIGNvbnNvbGUubG9nKCd0cnVlPycsIG9rVG9BZGQoMSwgaWQsIFswXSkpO1xuICAgIGNvbnNvbGUubG9nKCd0cnVlPycsIG9rVG9BZGQoMSwgaWQsIFswLCA0LCAyXSkpO1xuICAgIGNvbnNvbGUubG9nKCdmYWxzZT8nLCBva1RvQWRkKDIsIHN1Y2MsIFswLCA0LCAzXSkpO1xuICAgIGNvbnNvbGUubG9nKCd0cnVlPycsIG9rVG9BZGQoMywgc3VjYywgWzAsIDMsIDJdKSk7XG4gICAgY29uc29sZS5sb2coJ2ZhbHNlPycsIG9rVG9BZGQoMywgcHJlZCwgWzAsIDQsIDJdKSk7XG4gICAgY29uc29sZS5sb2coJ2ZhbHNlPycsIG9rVG9BZGQoMSwgc3VjYywgWzAsIDQsIDJdKSk7XG5cbiAgICBjb25zb2xlLmxvZygnJywgemlwV2l0aCgoYSwgYikgPT4gYSArIGIsIFsnYScsICdiJywgJ2MnLCAnZCddLCBbMSwgMiwgM10pKTtcbiAgICBjb25zb2xlLmxvZygndHJ1ZT8nLCBuRnJvbSgwLCA4KS5sZW5ndGggPT09IDgpO1xuICAgIGNvbnNvbGUubG9nKCd0cnVlPycsIGludGVydmFsKDAsIDMpLmxlbmd0aCA9PT0gcmFuZ2UoMCwgNCkubGVuZ3RoKTtcblxuICAgIGNvbnNvbGUubG9nKG9wdGlvbmFsKG51bGwpLm1hcChlID0+IHBsdXMoMSwgZSkpKVxuICAgIG9wdGlvbmFsKCdudWxsbycpLm1hcChlID0+IHBsdXMoMSwgZSkpLmlmUHJlc2VudChjb25zb2xlLmxvZylcblxuICAgIGNvbnNvbGUubG9nKCdbMCwwXT8nLCBmbGF0dGVuKFswLCAwXSkpXG4gICAgY29uc29sZS5sb2coJ1swLDBdPycsIGZsYXR0ZW4oWzAsIFswXV0pKVxuICAgIGNvbnNvbGUubG9nKCdbMCwwXT8nLCBmbGF0dGVuKFtcbiAgICAgICAgWzBdLCAwXG4gICAgXSkpXG4gICAgY29uc29sZS5sb2coJ1swLDAsMCwwXT8nLCBmbGF0dGVuKFswLCBbMCwgWzBdLFxuICAgICAgICBbMF1cbiAgICBdXSkpXG4gICAgY29uc29sZS5sb2coJ1swLDAsWzBdLFswXV0/JywgZmxhdHRlbihbMCwgWzAsIFswXSxcbiAgICAgICAgWzBdXG4gICAgXV0sIDEpKVxuICAgIGNvbnNvbGUubG9nKCdbMCwwLHtoZWxwOiBcImhlbHBcIn1dPycsIGZsYXR0ZW4oW1xuICAgICAgICBbMCwgMF0sIHtcbiAgICAgICAgICAgIGhlbHA6IFwiaGVscFwiXG4gICAgICAgIH1cbiAgICBdKSlcbn1cblxudmFyIHRyYW5zcG9zZSA9IHNvbHV0aW9uID0+IHtcbiAgICBsZXQgdHJhbnNwb3NlZCA9IFtdO1xuICAgIHNvbHV0aW9uLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgICAgdHJhbnNwb3NlZFt2XSA9IGk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRyYW5zcG9zZWQ7XG59O1xuXG52YXIgZmxpcCA9IHNvbHV0aW9uID0+IHtcbiAgICBsZXQgZmxpcHBlZCA9IFtdO1xuICAgIHNvbHV0aW9uLmZvckVhY2goKHYsIGkpID0+IGZsaXBwZWRbaV0gPSBzaXplXyAtIDEgLSB2KTtcbiAgICByZXR1cm4gZmxpcHBlZDtcbn07XG5cbnZhciBmbGlwWSA9IHNvbHV0aW9uID0+IHtcbiAgICBsZXQgZmxpcHBlZCA9IFtdO1xuICAgIHNvbHV0aW9uLmZvckVhY2goKHYsIGkpID0+IGZsaXBwZWRbc2l6ZV8gLSAxIC0gaV0gPSB2KTtcbiAgICByZXR1cm4gZmxpcHBlZDtcbn07XG5cbnZhciBjb21wID0gKGEsIGIpID0+IHtcbiAgICByZXR1cm4gYS5ldmVyeSgodiwgaSkgPT4gYltpXSA9PT0gdik7XG59O1xuXG5cblxuXG52YXIgZm9sZExlZnQgPSAoYXJyLCBzdGFydCwgZm4pID0+IHtcbiAgICByZXR1cm4gYXJyLnJlZHVjZShmbiwgc3RhcnQpO1xufVxudmFyIGZvbGRSaWdodCA9IChhcnIsIHN0YXJ0LCBmbikgPT4ge1xuICAgIHJldHVybiBhcnIucmV2ZXJzZSgpLnJlZHVjZShmbiwgc3RhcnQpO1xufVxuXG52YXIgYW5kID0gKGFjYywgY3VycikgPT4gYWNjICYmIGN1cnI7XG5cbnZhciBpZCA9IG4gPT4gbjtcbnZhciBzdWNjID0gbiA9PiBuICsgMTtcbnZhciBwcmVkID0gbiA9PiBuIC0gMTtcblxudmFyIGRpcmVjdGlvbnMgPSBbaWQsIHN1Y2MsIHByZWRdO1xuXG4vLyBcbnZhciBva1RvQWRkID0gKHBvcywgd2FsaywgcGFydGlhbFNvbHV0aW9uKSA9PiB7XG4gICAgcmV0dXJuIHBhcnRpYWxTb2x1dGlvbi5sZW5ndGggPT09IDAgP1xuICAgICAgICB0cnVlIDpcbiAgICAgICAgKHRhaWwocGFydGlhbFNvbHV0aW9uKSA9PT0gd2Fsayhwb3MpKSA/XG4gICAgICAgIGZhbHNlIDpcbiAgICAgICAgb2tUb0FkZCh3YWxrKHBvcyksIHdhbGssIHdpdGhvdXRMYXN0KHBhcnRpYWxTb2x1dGlvbikpO1xufTtcblxudmFyIGZpZWxkT2sgPSAocG9zLCBwYXJ0aWFsU29sdXRpb24gPSBbXSkgPT4ge1xuICAgIHJldHVybiBkaXJlY3Rpb25zXG4gICAgICAgIC5tYXAoZCA9PiBva1RvQWRkKHBvcywgZCwgcGFydGlhbFNvbHV0aW9uKSlcbiAgICAgICAgLnJlZHVjZShhbmQsIHRydWUpO1xufTtcblxuLy8gR2l2ZW4gb25lIHBhcnRpYWwgc29sdXRpb24gcmV0dXJucyBhIGxpc3Qgb2YgYWxsXG4vLyBleHRlbmRlZCBzb2x1dGlvbnMgb2YgdGhlIHBhcnRpYWwgb25lLlxudmFyIGV4dGVuZFNvbHV0aW9uID0gKHBhcnRpYWxTb2x1dGlvbiA9IFtdLCBzaXplID0gOCkgPT4ge1xuICAgIHJldHVybiByYW5nZSgwLCBzaXplKS5cbiAgICBmaWx0ZXIobmV3RmllbGQgPT4gZmllbGRPayhuZXdGaWVsZCwgcGFydGlhbFNvbHV0aW9uKSkuXG4gICAgbWFwKG5ld0ZpZWxkID0+IHBhcnRpYWxTb2x1dGlvbi5jb25jYXQobmV3RmllbGQpKTtcbn07XG5cbi8vIFxudmFyIGFsbFNvbHV0aW9ucyA9IChzaXplID0gOCwgc29sdXRpb25zID0gW1xuICAgIFtdXG5dKSA9PiB7XG4gICAgcmV0dXJuIChzb2x1dGlvbnMubGVuZ3RoID4gMCAmJiBzb2x1dGlvbnNbMF0ubGVuZ3RoID09PSBzaXplKSA/XG4gICAgICAgIHNvbHV0aW9ucyA6XG4gICAgICAgIGFsbFNvbHV0aW9ucyhzaXplLCBmbGF0dGVuKHNvbHV0aW9ucy5tYXAoc29sdXRpb24gPT4gZXh0ZW5kU29sdXRpb24oc29sdXRpb24sIHNpemUpKSwgMSkpO1xufTtcblxudmFyIHNpemVfID0gODtcblxudmFyIHNldFNpemUgPSAoc2l6ZSkgPT4ge1xuICAgIHNpemVfID0gc2l6ZTtcbiAgICBzb2x1dGlvbnMgPSBhbGxTb2x1dGlvbnMoc2l6ZV8pO1xuICAgIGNvbnNvbGUubG9nKCdzaXplJywgc2l6ZSlcbn1cblxudmFyIHNvbHV0aW9ucyA9IGFsbFNvbHV0aW9ucyhzaXplXyk7XG5cblxubGV0IHNvbHV0aW9uc18gPSBbXTtcblxubGV0IHBpcGUgPSAoZm5zLCBvYmopID0+IHtcbiAgICBsZXQgciA9IG9iajtcbiAgICBmbnMubWFwKGYgPT4ge1xuICAgICAgICByID0gZihyKTtcbiAgICB9KVxuICAgIHJldHVybiByO1xufTtcblxuXG5jb25zdCBzeW0gPSBbXG4gICAgW2lkXSxcbiAgICBbdHJhbnNwb3NlXSxcbiAgICBbZmxpcF0sXG4gICAgW3RyYW5zcG9zZSwgZmxpcF0sXG4gICAgW2ZsaXBZXSxcbiAgICBbdHJhbnNwb3NlLCBmbGlwWV0sXG4gICAgW2ZsaXAsIGZsaXBZXSxcbiAgICBbdHJhbnNwb3NlLCBmbGlwLCBmbGlwWV1cbl07XG5sZXQgc3ltbWV0cmljcyA9IChzb2x1dGlvbikgPT4gc3ltXG4gICAgLm1hcChzID0+IHBpcGUocywgc29sdXRpb24pKTtcblxuc29sdXRpb25zLmZvckVhY2goc29sdXRpb24gPT4ge1xuXG4gICAgICAgIGxldCBkaWZmZXJlbnRGcm9tQWxsRXhpc3RpbmcgPSBzb2x1dGlvbnNfLm1hcChleHNvbCA9PiBzeW1tZXRyaWNzKGV4c29sKVxuICAgICAgICAgICAgLmV2ZXJ5KHN5bXNvbCA9PiAhY29tcChzeW1zb2wsIHNvbHV0aW9uKSkpLmV2ZXJ5KGIgPT4gYiA9PT0gdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGRpZmZlcmVudEZyb21BbGxFeGlzdGluZylcbiAgICAgICAgICAgIHNvbHV0aW9uc18ucHVzaChzb2x1dGlvbik7XG5cbiAgICAgICAgY29uc29sZS5sb2coZGlmZmVyZW50RnJvbUFsbEV4aXN0aW5nLCAnZGlmZmVyZW50Jyk7XG4gICAgICAgIC8vXHRcbiAgICB9XG5cbik7XG5cblxuY29uc29sZS5sb2coJ2xlbmd0aCcsIHNvbHV0aW9uc18ubGVuZ3RoKTtcblxuY2xhc3MgU29sdXRpb25WaWV3IHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCd2bm9kZS5kb20nLCB0aGlzLmRvbSlcbiAgICAgICAgcmV0dXJuIG0oJ3RhYmxlJywgcmFuZ2UoMCwgc2l6ZV8pLm1hcChyb3cgPT4gbSgndHInLCByYW5nZSgwLCBzaXplXykubWFwKGNvbHVtbiA9PiBtKCd0ZCcsIHtcbiAgICAgICAgICAgIHN0eWxlOiAnYm9yZGVyLXN0eWxlOnNvbGlkOyBib3JkZXItd2lkdGg6MXB4O2JvcmRlci1jb2xvcjpsaWdodGdyYXk7aGVpZ2h0OicgKyB2bm9kZS5hdHRycy5zaXplICsgJ3B4O3dpZHRoOicgKyB2bm9kZS5hdHRycy5zaXplICsgJ3B4OycgKyBbXG4gICAgICAgICAgICAgICAgYGJhY2tncm91bmQtY29sb3I6cmVkO1xuICAgICAgICAgICAgICAgICAgICAtd2Via2l0LWJvcmRlci1yYWRpdXM6ICR7dm5vZGUuYXR0cnMuc2l6ZSAvIDJ9cHg7XG4gICAgICAgICAgICAgICAgICAgIC1tb3otYm9yZGVyLXJhZGl1czogJHt2bm9kZS5hdHRycy5zaXplIC8gMn1weDtcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogJHt2bm9kZS5hdHRycy5zaXplIC8gMn1weDtgLFxuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yOndoaXRlJyxcbiAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcjpibGFjaydcbiAgICAgICAgICAgIF1bXG4gICAgICAgICAgICAgICAgdm5vZGUuYXR0cnMuc29sdXRpb25bcm93XSA9PT0gY29sdW1uID8gMCA6ICgocm93ICsgY29sdW1uKSAlIDIpID8gMSA6IDJcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSwgJyAnKSkpKSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wIHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIHJldHVybiBtKCcuY29udGFpbmVyJywgbSgnaDEnLCAnUXVlZW5zICcgKyBzaXplXyArICd4JyArIHNpemVfICsgJyBoYXMgJyArIHNvbHV0aW9ucy5sZW5ndGggKyAnIHNvbHV0aW9ucycpLFxuICAgICAgICAgICAgbSgnLmZvcm0tZ3JvdXAnLCBtKCdpbnB1dCcsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncmFuZ2UnLFxuICAgICAgICAgICAgICAgIG1pbjogNCxcbiAgICAgICAgICAgICAgICBtYXg6IDgsXG4gICAgICAgICAgICAgICAgb25jaGFuZ2U6IChldikgPT4gc2V0U2l6ZShldi50YXJnZXQudmFsdWVBc051bWJlcilcbiAgICAgICAgICAgIH0pKSwgbSgnLnJvdycsIFtcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMubWFwKHNvbHV0aW9uID0+IG0oJy5jb2wtbWQtNC5jb2wteHMtMTInLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnbWFyZ2luLWJvdHRvbTo0MHB4J1xuICAgICAgICAgICAgICAgIH0sIG0oU29sdXRpb25WaWV3LCB7XG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiAzMFxuICAgICAgICAgICAgICAgIH0pKSlcbiAgICAgICAgICAgIF0pKVxuICAgIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3F1ZWVucy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBOzs7Ozs7Ozs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUdBO0FBRUE7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBVUE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFZQTs7Ozs7O0FBR0E7Ozs7Ozs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBSkE7QUFNQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBRkE7QUFGQTtBQU9BOzs7Ozs7QUFoQkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/*!*************************!*\
  !*** ./src/blackbox.js ***!
  \*************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _fn = __webpack_require__(/*! ./fn */ 2);\n\nvar _fn2 = _interopRequireDefault(_fn);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Ball = function Ball(r, c) {\n    return {\n        pos: r + ', ' + c,\n        getRow: function getRow() {\n            return r;\n        },\n        getColumn: function getColumn() {\n            return c;\n        },\n        equal: function equal(other) {\n            return other.getRow() === r && other.getColumn() === c;\n        }\n    };\n};\n\nvar Point = Ball;\n\nvar Directions = {\n    topToBottom: 'topToBottom',\n    bottomToTop: 'bottomToTop',\n    leftToRight: 'leftToRight',\n    rightToLeft: 'rightToLeft'\n};\n\nvar Direction = function Direction(value) {\n    var possibleDirections = [{\n        name: Directions.topToBottom,\n        dRow: 1,\n        dColumn: 0,\n        idx: 0\n    }, {\n        name: Directions.rightToLeft,\n        dRow: 0,\n        dColumn: -1,\n        idx: 1\n    }, {\n        name: Directions.bottomToTop,\n        dRow: -1,\n        dColumn: 0,\n        idx: 2\n    }, {\n        name: Directions.leftToRight,\n        dRow: 0,\n        dColumn: 1,\n        idx: 3\n    }];\n    var idx_ = possibleDirections.filter(function (d_) {\n        return d_.name === value;\n    })[0].idx;\n    var createFromIdx = function createFromIdx(idx) {\n        var d = function d() {\n            return possibleDirections[idx];\n        };\n        return {\n            name: function name() {\n                return d().name;\n            },\n            turnLeft: function turnLeft() {\n                return createFromIdx(idx - 1 + (idx === 0 ? 4 : 0));\n            },\n            turnRight: function turnRight() {\n                return createFromIdx((idx + 1) % 4);\n            },\n            walk: function walk(_ref) {\n                var getRow = _ref.getRow,\n                    getColumn = _ref.getColumn;\n                return Point(getRow() + d().dRow, getColumn() + d().dColumn);\n            }\n        };\n    };\n    return createFromIdx(idx_);\n};\n\nvar Field = function Field() {\n    var size = 8;\n    var min = 4;\n    var max = 8;\n    var balls = [];\n    var placeBallRec = function placeBallRec(balls_, count) {\n        var ball = Ball(Math.floor(Math.random() * size), Math.floor(Math.random() * size));\n        return count === 0 ? balls_ : balls_.filter(function (ballInside) {\n            return ballInside.equal(ball);\n        }).length > 0 ? placeBallRec(balls_, count) : placeBallRec(_fn2.default.flatten([balls_, ball]), count - 1);\n    };\n    var hasBall = function hasBall(ball) {\n        return !_fn2.default.isEmpty(balls.filter(ball.equal));\n    };\n    var contains = function contains(_ref2) {\n        var getRow = _ref2.getRow,\n            getColumn = _ref2.getColumn;\n        return getRow() >= 0 && getColumn() >= 0 && getRow() < size && getColumn() < size;\n    };\n    var assume = function assume(direction, position) {\n        var steps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n        var front = direction.walk(position);\n        var frontLeft = direction.turnLeft().walk(front);\n        var frontRight = direction.turnRight().walk(front);\n        if (!contains(front)) return steps;\n        if (hasBall(front)) return 'H';\n        if (hasBall(frontLeft) && hasBall(frontRight)) return 'R';\n        if (hasBall(frontLeft)) {\n            if (steps === 0) return 'R';\n            return assume(direction.turnRight(), position, steps);\n        }\n        if (hasBall(frontRight)) {\n            if (steps === 0) return 'R';\n            return assume(direction.turnLeft(), position, steps);\n        }\n        return assume(direction, direction.walk(position), steps + 1);\n    };\n    return {\n        getSize: function getSize() {\n            return size;\n        },\n        getBalls: function getBalls() {\n            return balls;\n        },\n        hasBall: hasBall,\n        placeBall: function placeBall(ball) {\n            if (balls.filter(ball.equal).length > 0) balls = balls.filter(function (b) {\n                return !ball.equal(b);\n            });else balls.push(ball);\n        },\n        contains: contains,\n        placeBalls: function placeBalls() {\n            var ballCount = Math.floor(Math.random() * (max - min) + min);\n            balls = placeBallRec(balls, ballCount);\n        },\n        assume: assume\n    };\n};\n\nvar field = Field();\nfield.placeBalls();\n\nvar guessField = Field();\n\nvar HintView = function () {\n    function HintView() {\n        _classCallCheck(this, HintView);\n\n        this.text = '';\n    }\n\n    _createClass(HintView, [{\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            return (0, _mithril2.default)('td.bb-hint', {\n                onclick: function onclick(e) {\n                    _this.text = field.assume(Direction(vnode.attrs.direction), Point(vnode.attrs.start.row, vnode.attrs.start.column));\n                }\n            }, this.text);\n        }\n    }]);\n\n    return HintView;\n}();\n\nvar SlotView = function () {\n    function SlotView() {\n        _classCallCheck(this, SlotView);\n    }\n\n    _createClass(SlotView, [{\n        key: 'view',\n        value: function view(vnode) {\n            var p = Point(vnode.attrs.row, vnode.attrs.column);\n            return (0, _mithril2.default)('td.bb' + (guessField.hasBall(p) ? '.bb-guess' : ''), {\n                onclick: function onclick(e) {\n                    return guessField.placeBall(p);\n                }\n            }, guessField.hasBall(p) ? 'g' : '');\n        }\n    }]);\n\n    return SlotView;\n}();\n\nvar ColumnView = function () {\n    function ColumnView() {\n        _classCallCheck(this, ColumnView);\n    }\n\n    _createClass(ColumnView, [{\n        key: 'view',\n        value: function view(vnode) {\n            return (0, _mithril2.default)('td.bb-empty', vnode.attrs, vnode.children);\n        }\n    }]);\n\n    return ColumnView;\n}();\n\nvar RowView = function () {\n    function RowView() {\n        _classCallCheck(this, RowView);\n    }\n\n    _createClass(RowView, [{\n        key: 'view',\n        value: function view(vnode) {\n            return (0, _mithril2.default)('tr', vnode.attrs, vnode.children);\n        }\n    }]);\n\n    return RowView;\n}();\n\nvar FieldView = function () {\n    function FieldView() {\n        _classCallCheck(this, FieldView);\n    }\n\n    _createClass(FieldView, [{\n        key: 'view',\n        value: function view(vnode) {\n            var size = field.getSize();\n            return (0, _mithril2.default)('table', (0, _mithril2.default)(RowView, [(0, _mithril2.default)(ColumnView), _fn2.default.range(0, size).map(function (i) {\n                return (0, _mithril2.default)(ColumnView, (0, _mithril2.default)(HintView, {\n                    start: { row: -1, column: i },\n                    direction: Directions.topToBottom\n                }));\n            })]), _fn2.default.range(0, size).map(function (rowNumber) {\n                return (0, _mithril2.default)(RowView, (0, _mithril2.default)(ColumnView, (0, _mithril2.default)(HintView, {\n                    start: { row: rowNumber, column: -1 },\n                    direction: Directions.leftToRight\n                })), _fn2.default.range(0, size).map(function (column) {\n                    return (0, _mithril2.default)(ColumnView, (0, _mithril2.default)(SlotView, { row: rowNumber, column: column }));\n                }), (0, _mithril2.default)(ColumnView, (0, _mithril2.default)(HintView, {\n                    start: { row: rowNumber, column: size },\n                    direction: Directions.rightToLeft\n                })));\n            }), (0, _mithril2.default)(RowView, [(0, _mithril2.default)(ColumnView), _fn2.default.range(0, size).map(function (i) {\n                return (0, _mithril2.default)(ColumnView, (0, _mithril2.default)(HintView, {\n                    start: { row: size, column: i },\n                    direction: Directions.bottomToTop\n                }));\n            })]));\n        }\n    }]);\n\n    return FieldView;\n}();\n\nvar Comp = function () {\n    function Comp() {\n        _classCallCheck(this, Comp);\n    }\n\n    _createClass(Comp, [{\n        key: 'view',\n        value: function view(vnode) {\n            return (0, _mithril2.default)('.container', (0, _mithril2.default)('h1', 'Blackbox ' + field.getSize() + 'x' + field.getSize()), (0, _mithril2.default)('.form-group', (0, _mithril2.default)('input', { type: 'range', min: 4, max: 8, onchange: function onchange(ev) {\n                    return setSize(ev.target.valueAsNumber);\n                } })), (0, _mithril2.default)(FieldView, { field: field, size: 30 }));\n        }\n    }]);\n\n    return Comp;\n}();\n\nexports.default = Comp;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2JsYWNrYm94LmpzPzg3OTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmltcG9ydCBmbiBmcm9tICcuL2ZuJ1xuXG5jb25zdCBCYWxsID0gKHIsIGMpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3M6IHIgKyAnLCAnICsgYyxcbiAgICAgICAgZ2V0Um93OiAoKSA9PiByLFxuICAgICAgICBnZXRDb2x1bW46ICgpID0+IGMsXG4gICAgICAgIGVxdWFsOiAob3RoZXIpID0+IG90aGVyLmdldFJvdygpID09PSByICYmIG90aGVyLmdldENvbHVtbigpID09PSBjXG4gICAgfTtcbn07XG5cbmNvbnN0IFBvaW50ID0gQmFsbDtcblxuY29uc3QgRGlyZWN0aW9ucyA9IHtcbiAgICB0b3BUb0JvdHRvbTogJ3RvcFRvQm90dG9tJyxcbiAgICBib3R0b21Ub1RvcDogJ2JvdHRvbVRvVG9wJyxcbiAgICBsZWZ0VG9SaWdodDogJ2xlZnRUb1JpZ2h0JyxcbiAgICByaWdodFRvTGVmdDogJ3JpZ2h0VG9MZWZ0J1xufTtcblxuY29uc3QgRGlyZWN0aW9uID0gKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgcG9zc2libGVEaXJlY3Rpb25zID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBEaXJlY3Rpb25zLnRvcFRvQm90dG9tLFxuICAgICAgICAgICAgZFJvdzogMSxcbiAgICAgICAgICAgIGRDb2x1bW46IDAsXG4gICAgICAgICAgICBpZHg6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogRGlyZWN0aW9ucy5yaWdodFRvTGVmdCxcbiAgICAgICAgICAgIGRSb3c6IDAsXG4gICAgICAgICAgICBkQ29sdW1uOiAtMSxcbiAgICAgICAgICAgIGlkeDogMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBEaXJlY3Rpb25zLmJvdHRvbVRvVG9wLFxuICAgICAgICAgICAgZFJvdzogLTEsXG4gICAgICAgICAgICBkQ29sdW1uOiAwLFxuICAgICAgICAgICAgaWR4OiAyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IERpcmVjdGlvbnMubGVmdFRvUmlnaHQsXG4gICAgICAgICAgICBkUm93OiAwLFxuICAgICAgICAgICAgZENvbHVtbjogMSxcbiAgICAgICAgICAgIGlkeDogM1xuICAgICAgICB9XG4gICAgXTtcbiAgICBsZXQgaWR4XyA9IHBvc3NpYmxlRGlyZWN0aW9ucy5maWx0ZXIoZF8gPT4gZF8ubmFtZSA9PT0gdmFsdWUpWzBdLmlkeDtcbiAgICBjb25zdCBjcmVhdGVGcm9tSWR4ID0gKGlkeCkgPT4ge1xuICAgICAgICBsZXQgZCA9ICgpID0+IHBvc3NpYmxlRGlyZWN0aW9uc1tpZHhdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogKCkgPT4gZCgpLm5hbWUsXG4gICAgICAgICAgICB0dXJuTGVmdDogKCkgPT4gY3JlYXRlRnJvbUlkeCgoaWR4IC0gMSkgKyAoaWR4ID09PSAwID8gNCA6IDApKSxcbiAgICAgICAgICAgIHR1cm5SaWdodDogKCkgPT4gY3JlYXRlRnJvbUlkeCgoaWR4ICsgMSkgJSA0KSxcbiAgICAgICAgICAgIHdhbGs6ICh7IGdldFJvdywgZ2V0Q29sdW1uIH0pID0+IFBvaW50KGdldFJvdygpICsgZCgpLmRSb3csIGdldENvbHVtbigpICsgZCgpLmRDb2x1bW4pXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVGcm9tSWR4KGlkeF8pO1xufVxuXG5jb25zdCBGaWVsZCA9ICgpID0+IHtcbiAgICBsZXQgc2l6ZSA9IDg7XG4gICAgbGV0IG1pbiA9IDQ7XG4gICAgbGV0IG1heCA9IDg7XG4gICAgbGV0IGJhbGxzID0gW107XG4gICAgbGV0IHBsYWNlQmFsbFJlYyA9IChiYWxsc18sIGNvdW50KSA9PiB7XG4gICAgICAgIGxldCBiYWxsID0gQmFsbChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBzaXplKSwgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogc2l6ZSkpO1xuICAgICAgICByZXR1cm4gKGNvdW50ID09PSAwKSA/IGJhbGxzXyA6IGJhbGxzXy5cbiAgICAgICAgICAgIGZpbHRlcihiYWxsSW5zaWRlID0+IGJhbGxJbnNpZGUuZXF1YWwoYmFsbCkpLlxuICAgICAgICAgICAgbGVuZ3RoID4gMCA/IHBsYWNlQmFsbFJlYyhiYWxsc18sIGNvdW50KSA6IHBsYWNlQmFsbFJlYyhmbi5mbGF0dGVuKFtiYWxsc18sIGJhbGxdKSwgY291bnQgLSAxKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhc0JhbGwgPSAoYmFsbCkgPT4gIWZuLmlzRW1wdHkoYmFsbHMuZmlsdGVyKGJhbGwuZXF1YWwpKTtcbiAgICBjb25zdCBjb250YWlucyA9ICh7IGdldFJvdywgZ2V0Q29sdW1uIH0pID0+IGdldFJvdygpID49IDAgJiYgZ2V0Q29sdW1uKCkgPj0gMCAmJiBnZXRSb3coKSA8IHNpemUgJiYgZ2V0Q29sdW1uKCkgPCBzaXplO1xuICAgIGNvbnN0IGFzc3VtZSA9IChkaXJlY3Rpb24sIHBvc2l0aW9uLCBzdGVwcyA9IDApID0+IHtcbiAgICAgICAgdmFyIGZyb250ID0gZGlyZWN0aW9uLndhbGsocG9zaXRpb24pO1xuICAgICAgICB2YXIgZnJvbnRMZWZ0ID0gZGlyZWN0aW9uLnR1cm5MZWZ0KCkud2Fsayhmcm9udCk7XG4gICAgICAgIHZhciBmcm9udFJpZ2h0ID0gZGlyZWN0aW9uLnR1cm5SaWdodCgpLndhbGsoZnJvbnQpO1xuICAgICAgICBpZiAoIWNvbnRhaW5zKGZyb250KSlcbiAgICAgICAgICAgIHJldHVybiBzdGVwcztcbiAgICAgICAgaWYgKGhhc0JhbGwoZnJvbnQpKVxuICAgICAgICAgICAgcmV0dXJuICdIJztcbiAgICAgICAgaWYgKGhhc0JhbGwoZnJvbnRMZWZ0KSAmJiBoYXNCYWxsKGZyb250UmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuICdSJztcbiAgICAgICAgaWYgKGhhc0JhbGwoZnJvbnRMZWZ0KSkge1xuICAgICAgICAgICAgaWYgKHN0ZXBzID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiAnUic7XG4gICAgICAgICAgICByZXR1cm4gYXNzdW1lKGRpcmVjdGlvbi50dXJuUmlnaHQoKSwgcG9zaXRpb24sIHN0ZXBzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzQmFsbChmcm9udFJpZ2h0KSkge1xuICAgICAgICAgICAgaWYgKHN0ZXBzID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiAnUic7XG4gICAgICAgICAgICByZXR1cm4gYXNzdW1lKGRpcmVjdGlvbi50dXJuTGVmdCgpLCBwb3NpdGlvbiwgc3RlcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3N1bWUoZGlyZWN0aW9uLCBkaXJlY3Rpb24ud2Fsayhwb3NpdGlvbiksIHN0ZXBzICsgMSk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRTaXplOiAoKSA9PiBzaXplLFxuICAgICAgICBnZXRCYWxsczogKCkgPT4gYmFsbHMsXG4gICAgICAgIGhhc0JhbGw6IGhhc0JhbGwsXG4gICAgICAgIHBsYWNlQmFsbDogKGJhbGwpID0+IHtcbiAgICAgICAgICAgIGlmIChiYWxscy5maWx0ZXIoYmFsbC5lcXVhbCkubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICBiYWxscyA9IGJhbGxzLmZpbHRlcihiID0+ICFiYWxsLmVxdWFsKGIpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBiYWxscy5wdXNoKGJhbGwpO1xuICAgICAgICB9LFxuICAgICAgICBjb250YWluczogY29udGFpbnMsXG4gICAgICAgIHBsYWNlQmFsbHM6ICgpID0+IHtcbiAgICAgICAgICAgIGxldCBiYWxsQ291bnQgPSBNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikpICsgbWluKTtcbiAgICAgICAgICAgIGJhbGxzID0gcGxhY2VCYWxsUmVjKGJhbGxzLCBiYWxsQ291bnQpO1xuICAgICAgICB9LFxuICAgICAgICBhc3N1bWU6IGFzc3VtZVxuICAgIH07XG59O1xuXG5sZXQgZmllbGQgPSBGaWVsZCgpO1xuZmllbGQucGxhY2VCYWxscygpO1xuXG5sZXQgZ3Vlc3NGaWVsZCA9IEZpZWxkKCk7XG5cbmNsYXNzIEhpbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gJyc7XG4gICAgfVxuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG0oJ3RkLmJiLWhpbnQnLCB7XG4gICAgICAgICAgICBvbmNsaWNrOiBlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSBmaWVsZC5hc3N1bWUoRGlyZWN0aW9uKHZub2RlLmF0dHJzLmRpcmVjdGlvbiksXG4gICAgICAgICAgICAgICAgICAgIFBvaW50KHZub2RlLmF0dHJzLnN0YXJ0LnJvdyxcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUuYXR0cnMuc3RhcnQuY29sdW1uKSxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy50ZXh0KVxuICAgIH1cbn1cblxuY2xhc3MgU2xvdFZpZXcge1xuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgbGV0IHAgPSBQb2ludCh2bm9kZS5hdHRycy5yb3csdm5vZGUuYXR0cnMuY29sdW1uKTtcbiAgICAgICAgcmV0dXJuIG0oJ3RkLmJiJyArIChndWVzc0ZpZWxkLmhhc0JhbGwocCkgPyAnLmJiLWd1ZXNzJyA6ICcnKSwge1xuICAgICAgICAgICAgb25jbGljazogZSA9PiBndWVzc0ZpZWxkLnBsYWNlQmFsbChwKVxuICAgICAgICB9LCBndWVzc0ZpZWxkLmhhc0JhbGwocCkgPyAnZycgOiAnJylcbiAgICB9XG59XG5cbmNsYXNzIENvbHVtblZpZXcge1xuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG0oJ3RkLmJiLWVtcHR5Jywgdm5vZGUuYXR0cnMsIHZub2RlLmNoaWxkcmVuKTtcbiAgICB9XG59XG5cbmNsYXNzIFJvd1ZpZXcge1xuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG0oJ3RyJywgdm5vZGUuYXR0cnMsIHZub2RlLmNoaWxkcmVuKTtcbiAgICB9XG59XG5cbmNsYXNzIEZpZWxkVmlldyB7XG4gICAgdmlldyh2bm9kZSkge1xuICAgICAgICBsZXQgc2l6ZSA9IGZpZWxkLmdldFNpemUoKTtcbiAgICAgICAgcmV0dXJuIG0oJ3RhYmxlJyxcbiAgICAgICAgICAgIG0oUm93VmlldywgW1xuICAgICAgICAgICAgICAgIG0oQ29sdW1uVmlldyksXG4gICAgICAgICAgICAgICAgZm4ucmFuZ2UoMCwgc2l6ZSkubWFwKGkgPT5cbiAgICAgICAgICAgICAgICAgICAgbShDb2x1bW5WaWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgbShIaW50Vmlldywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7IHJvdzogLTEsIGNvbHVtbjogaSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogRGlyZWN0aW9ucy50b3BUb0JvdHRvbVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgZm4ucmFuZ2UoMCwgc2l6ZSkubWFwKChyb3dOdW1iZXIpID0+XG4gICAgICAgICAgICAgICAgbShSb3dWaWV3LCBtKENvbHVtblZpZXcsIG0oSGludFZpZXcsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHsgcm93OiByb3dOdW1iZXIsIGNvbHVtbjogLTEgfSxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBEaXJlY3Rpb25zLmxlZnRUb1JpZ2h0XG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgIGZuLnJhbmdlKDAsIHNpemUpLm1hcChjb2x1bW4gPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIG0oQ29sdW1uVmlldywgbShTbG90VmlldywgeyByb3c6cm93TnVtYmVyLGNvbHVtbiB9KSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgbShDb2x1bW5WaWV3LCBtKEhpbnRWaWV3LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogeyByb3c6IHJvd051bWJlciwgY29sdW1uOiBzaXplICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBEaXJlY3Rpb25zLnJpZ2h0VG9MZWZ0XG4gICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBtKFJvd1ZpZXcsIFtcbiAgICAgICAgICAgICAgICBtKENvbHVtblZpZXcpLFxuICAgICAgICAgICAgICAgIGZuLnJhbmdlKDAsIHNpemUpLm1hcChpID0+XG4gICAgICAgICAgICAgICAgICAgIG0oQ29sdW1uVmlldyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oSGludFZpZXcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogeyByb3c6IHNpemUgLCBjb2x1bW46IGkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IERpcmVjdGlvbnMuYm90dG9tVG9Ub3BcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXAge1xuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG0oJy5jb250YWluZXInLCBtKCdoMScsICdCbGFja2JveCAnICsgZmllbGQuZ2V0U2l6ZSgpICsgJ3gnICsgZmllbGQuZ2V0U2l6ZSgpXG4gICAgICAgICksXG4gICAgICAgICAgICBtKCcuZm9ybS1ncm91cCcsIG0oJ2lucHV0JywgeyB0eXBlOiAncmFuZ2UnLCBtaW46IDQsIG1heDogOCwgb25jaGFuZ2U6IChldikgPT4gc2V0U2l6ZShldi50YXJnZXQudmFsdWVBc051bWJlcikgfSkpXG4gICAgICAgICAgICAsIG0oRmllbGRWaWV3LCB7IGZpZWxkLCBzaXplOiAzMCB9KSlcbiAgICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ibGFja2JveC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQU5BO0FBUUE7Ozs7OztBQUdBOzs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFHQTs7Ozs7O0FBR0E7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUdBOzs7Ozs7O0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUZBO0FBRkE7QUFTQTtBQUVBO0FBQ0E7QUFGQTtBQUlBO0FBQUE7QUFJQTtBQUNBO0FBRkE7QUFSQTtBQWdCQTtBQUdBO0FBQ0E7QUFGQTtBQUZBO0FBVUE7Ozs7OztBQUdBOzs7Ozs7O0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFFQTs7Ozs7O0FBTkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/*!*************************!*\
  !*** ./src/dragdrop.js ***!
  \*************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _fn = __webpack_require__(/*! ./fn */ 2);\n\nvar _fn2 = _interopRequireDefault(_fn);\n\n__webpack_require__(/*! ./assign */ 21);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar compis = [];\n\nvar draggableMixin = function draggableMixin(data) {\n\tvar options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\treturn Object.assign({\n\t\tdraggable: true,\n\t\tondragstart: function ondragstart(e) {\n\t\t\tconsole.log(e);\n\t\t\te.dataTransfer.setData('text', data);\n\t\t\te.target.style.opacity = \"0.6\";\n\t\t},\n\t\tondragend: function ondragend(e) {\n\t\t\tconsole.log(e);\n\t\t\te.target.style.opacity = \"1.0\";\n\t\t}\n\t}, options);\n};\n\nvar dropzoneMixin = function dropzoneMixin(options) {\n\tvar res = Object.assign({\n\t\tondragover: function ondragover(e) {\n\t\t\te.preventDefault();console.log('dragover', e);\n\t\t},\n\t\tondragenter: function ondragenter(e) {\n\t\t\te.preventDefault();console.log('dragenter', e);\n\t\t},\n\t\tondrop: function ondrop(e) {\n\t\t\te.preventDefault();\n\t\t\tconsole.log('drop', e);\n\t\t\tres.dropped(e.dataTransfer.getData('text'));\n\t\t}\n\t}, options);\n\treturn res;\n};\n\nvar Editor = function () {\n\tfunction Editor() {\n\t\t_classCallCheck(this, Editor);\n\t}\n\n\t_createClass(Editor, [{\n\t\tkey: 'view',\n\t\tvalue: function view(vnode) {\n\t\t\treturn (0, _mithril2.default)('.container', (0, _mithril2.default)('h1', 'Drag\\'n\\'Drop '),\n\t\t\t//            m('.form-group', m('input', { type: 'range', min: 4, max: 8, onchange: (ev) => setSize(ev.target.valueAsNumber) })),\n\t\t\t(0, _mithril2.default)('.leftbox', _fn2.default.interval(1, 10).map(function (val) {\n\t\t\t\treturn (0, _mithril2.default)('.badge', draggableMixin(val + ''), val);\n\t\t\t})), (0, _mithril2.default)('.rightbox', dropzoneMixin({\n\t\t\t\tstyle: 'width:250px;height:250px; border:1px solid red',\n\t\t\t\tdropped: function dropped(d) {\n\t\t\t\t\treturn compis.push(d);\n\t\t\t\t}\n\t\t\t}), compis.map(function (c) {\n\t\t\t\treturn (0, _mithril2.default)('.badge', c);\n\t\t\t})));\n\t\t}\n\t}]);\n\n\treturn Editor;\n}();\n\nexports.default = Editor;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2RyYWdkcm9wLmpzPzlkYmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmltcG9ydCBmbiBmcm9tICcuL2ZuJ1xuXG5pbXBvcnQgJy4vYXNzaWduJ1xuXG5sZXQgY29tcGlzID0gW107XG5cbmxldCBkcmFnZ2FibGVNaXhpbiA9IChkYXRhLCBvcHRpb25zPXt9KSA9PiB7XG5cdHJldHVybiBPYmplY3QuYXNzaWduKHtcblx0XHRkcmFnZ2FibGU6dHJ1ZSxcdFx0XHRcdFxuXHRcdFx0b25kcmFnc3RhcnQ6ZT0+e1xuXHRcdFx0XHRjb25zb2xlLmxvZyhlKTsgXG5cdFx0XHRcdGUuZGF0YVRyYW5zZmVyLnNldERhdGEoJ3RleHQnLCBkYXRhKVxuXHRcdFx0XHRlLnRhcmdldC5zdHlsZS5vcGFjaXR5ID0gXCIwLjZcIlxuXHRcdFx0fSxcblx0XHRcdG9uZHJhZ2VuZDplPT57XG5cdFx0XHRcdGNvbnNvbGUubG9nKGUpOyBcblx0XHRcdFx0ZS50YXJnZXQuc3R5bGUub3BhY2l0eSA9IFwiMS4wXCJcblx0XHRcdH1cblx0fSwgb3B0aW9ucyk7XG59O1xuXG5sZXQgZHJvcHpvbmVNaXhpbiA9IChvcHRpb25zKSA9PiB7XG5cdGxldCByZXMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRvbmRyYWdvdmVyOmU9PntlLnByZXZlbnREZWZhdWx0KCk7Y29uc29sZS5sb2coJ2RyYWdvdmVyJyxlKTt9LFxuXHRcdG9uZHJhZ2VudGVyOmU9PnsgZS5wcmV2ZW50RGVmYXVsdCgpOyBjb25zb2xlLmxvZygnZHJhZ2VudGVyJyxlKX0sXG5cdFx0b25kcm9wOmU9Pntcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTsgXG5cdFx0XHRjb25zb2xlLmxvZygnZHJvcCcsZSk7XHRcdFx0XG5cdFx0XHRyZXMuZHJvcHBlZChlLmRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0JykpO1xuXHRcdH1cdFx0XG5cdH0sIG9wdGlvbnMpO1xuXHRyZXR1cm4gcmVzO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWRpdG9yIHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIHJldHVybiBtKCcuY29udGFpbmVyJywgXG5cdFx0XHRtKCdoMScsICdEcmFnXFwnblxcJ0Ryb3AgJyksXG4vLyAgICAgICAgICAgIG0oJy5mb3JtLWdyb3VwJywgbSgnaW5wdXQnLCB7IHR5cGU6ICdyYW5nZScsIG1pbjogNCwgbWF4OiA4LCBvbmNoYW5nZTogKGV2KSA9PiBzZXRTaXplKGV2LnRhcmdldC52YWx1ZUFzTnVtYmVyKSB9KSksXG4gICAgICAgICAgICBtKCcubGVmdGJveCcsXG5cdFx0XHRcdGZuLmludGVydmFsKDEsMTApLm1hcCh2YWw9Pm0oJy5iYWRnZScsZHJhZ2dhYmxlTWl4aW4odmFsKycnKSx2YWwpKVxuXHRcdFx0KSxcblx0XHRcdG0oJy5yaWdodGJveCcsZHJvcHpvbmVNaXhpbih7XG5cdFx0XHRcdHN0eWxlOid3aWR0aDoyNTBweDtoZWlnaHQ6MjUwcHg7IGJvcmRlcjoxcHggc29saWQgcmVkJyxcblx0XHRcdFx0ZHJvcHBlZDpkPT5jb21waXMucHVzaChkKVxuXHRcdFx0fSksIGNvbXBpcy5tYXAoYz0+bSgnLmJhZGdlJyxjKSlcblx0XHRcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RyYWdkcm9wLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBR0E7QUFBQTtBQUlBOzs7Ozs7QUFmQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///20\n");

/***/ }),
/* 21 */
/*!***********************!*\
  !*** ./src/assign.js ***!
  \***********************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nif (typeof Object.assign != 'function') {\n  // Must be writable: true, enumerable: false, configurable: true\n  Object.defineProperty(Object, \"assign\", {\n    value: function assign(target, varArgs) {\n      // .length of function is 2\n      'use strict';\n\n      if (target == null) {\n        // TypeError if undefined or null\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) {\n          // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    },\n    writable: true,\n    configurable: true\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2Fzc2lnbi5qcz9mMmRlIl0sInNvdXJjZXNDb250ZW50IjpbIlxuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9ICdmdW5jdGlvbicpIHtcbiAgLy8gTXVzdCBiZSB3cml0YWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LCBcImFzc2lnblwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHZhckFyZ3MpIHsgLy8gLmxlbmd0aCBvZiBmdW5jdGlvbiBpcyAyXG4gICAgICAndXNlIHN0cmljdCc7XG4gICAgICBpZiAodGFyZ2V0ID09IG51bGwpIHsgLy8gVHlwZUVycm9yIGlmIHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcblxuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuXG4gICAgICAgIGlmIChuZXh0U291cmNlICE9IG51bGwpIHsgLy8gU2tpcCBvdmVyIGlmIHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBuZXh0U291cmNlKSB7XG4gICAgICAgICAgICAvLyBBdm9pZCBidWdzIHdoZW4gaGFzT3duUHJvcGVydHkgaXMgc2hhZG93ZWRcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobmV4dFNvdXJjZSwgbmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRvO1xuICAgIH0sXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9hc3NpZ24uanMiXSwibWFwcGluZ3MiOiI7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF4QkE7QUEwQkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///21\n");

/***/ }),
/* 22 */
/*!******************************!*\
  !*** ./src/computesquare.js ***!
  \******************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _underscore = __webpack_require__(/*! underscore */ 1);\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar n = {\n    numbers: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n};\nvar results = [66, 13, 60, 3, 72, 30];\nvar results__ = [6, 15, 24, 12, 15, 18];\n\nvar times_ = function times_(a, b) {\n    return a * b;\n};\nvar minus_ = function minus_(a, b) {\n    return a - b;\n};\nvar add___ = function add___(a, b) {\n    return a + b;\n};\nvar div___ = function div___(a, b) {\n    return a / b;\n};\n\nvar id = function id(a) {\n    return a;\n};\nvar union = function union() {\n    for (var _len = arguments.length, a = Array(_len), _key = 0; _key < _len; _key++) {\n        a[_key] = arguments[_key];\n    }\n\n    return [].concat(a);\n};\n\nvar peek = function peek(a) {\n    // console.log(a);\n    return a;\n};\n\nvar range = function range(startInclusive, endExclusive) {\n    var result = [];\n    for (var i = startInclusive; i < endExclusive; i++) {\n        result.push(i);\n    }\n    return result;\n};\n\nvar fs = [[times_, minus_], [times_, minus_], [times_, times_], [minus_, times_], [times_, times_], [times_, times_]];\nvar fs___ = [[add___, add___], [add___, add___], [add___, add___], [add___, add___], [add___, add___], [add___, add___]];\nvar empty = '';\nvar equals = '=';\nvar times = 'x';\nvar minus = '-';\n\nvar createEquation = function createEquation(f, r) {\n    return function (n) {\n        //  console.log('create', f, r, n)\n        return f[1](f[0](n[0], n[1]), n[2]) - r;\n    };\n};\n\nvar split = function split(arr, n) {\n    var result = [];\n    do {\n        result.push(_underscore2.default.first(arr, n));\n    } while ((arr = _underscore2.default.rest(arr, n)).length >= n);\n    return result;\n};\n\nvar zipWith = function zipWith(fn) {\n    for (var _len2 = arguments.length, arrs = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        arrs[_key2 - 1] = arguments[_key2];\n    }\n\n    return range(0, Math.min.apply(Math, _toConsumableArray(arrs.map(function (arr) {\n        return arr.length;\n    })))).map(function (i) {\n        return fn.apply(undefined, _toConsumableArray(arrs.map(function (arr) {\n            return arr[i];\n        })));\n    });\n};\n\nvar transpose = function transpose() {\n    for (var _len3 = arguments.length, arrOArrs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        arrOArrs[_key3] = arguments[_key3];\n    }\n\n    return zipWith.apply(undefined, [union].concat(arrOArrs));\n};\n\nconsole.log(transpose([0, 1], [2, 3]));\n\n//console.log('tr', transpose(...split(numbers, 3)));\n//console.log('id', split(numbers, 3));\n\n// let equations_ = numbers => [union, transpose].map(tr => tr(numbers));\n\nvar on = function on(fns, arr) {\n    return fns.map(function (f, idx) {\n        //    console.log('on', f, arr[idx]);\n        return f(arr[idx]);\n    });\n};\n\nvar equations = function equations() {\n    return fs.map(function (f, idx) {\n        return createEquation(f, results[idx]);\n    });\n};\n\nvar splitter = function splitter(numbers) {\n    return [].concat(_toConsumableArray(split(numbers, 3)), _toConsumableArray(transpose.apply(undefined, _toConsumableArray(split(numbers, 3)))));\n};\n\nvar test_ = function test_(numbers) {\n    return on(equations(), splitter(numbers).map(peek)).map(peek).every(function (e) {\n        return e === 0;\n    });\n};\n\n//console.log(test_(equations)([1, 2, 3, 4, 5, 6, 7, 8, 9]));\n\nvar test = function test(numbers) {\n    return equations().every(function (equation) {\n        return equation(numbers) === 0;\n    });\n};\n\nvar permute = function permute(permutation) {\n    var length = permutation.length,\n        result = [permutation.slice()],\n        c = new Array(length).fill(0),\n        i = 1,\n        k,\n        p;\n\n    while (i < length) {\n        if (c[i] < i) {\n            k = i % 2 && c[i];\n            p = permutation[i];\n            permutation[i] = permutation[k];\n            permutation[k] = p;\n            ++c[i];\n            i = 1;\n            result.push(permutation.slice());\n        } else {\n            c[i] = 0;\n            ++i;\n        }\n    }\n    return result;\n};\n\n//console.log(permute(numbers))\n\n//console.log(numbers = permute(numbers).filter(test_)[0]);\n\nvar functions = [{\n    text: '+',\n    f: add___\n}, {\n    text: '-',\n    f: minus_\n}, {\n    text: 'x',\n    f: times_\n}, {\n    text: '/',\n    f: div___\n}];\n\nvar findSolution = function findSolution() {\n    return permute([1, 2, 3, 4, 5, 6, 7, 8, 9]).filter(test_)[0];\n};\n\nvar fn2str = function fn2str(f) {\n    return functions.filter(function (fn) {\n        return fn.f === f;\n    })[0].text;\n};\n\nconsole.log(fields);\n\nvar getNumber = function getNumber(idx) {\n    return n.numbers[idx];\n};\n\nvar setNumbers = function setNumbers(num) {\n    return n.numbers = num;\n};\n\nvar NumberView = function () {\n    function NumberView() {\n        _classCallCheck(this, NumberView);\n    }\n\n    _createClass(NumberView, [{\n        key: 'view',\n        value: function view(vnode) {\n            console.log(vnode.attrs);\n            return (0, _mithril2.default)('span', getNumber(vnode.attrs.idx));\n        }\n    }]);\n\n    return NumberView;\n}();\n\nvar ResultInput = function () {\n    function ResultInput() {\n        _classCallCheck(this, ResultInput);\n    }\n\n    _createClass(ResultInput, [{\n        key: 'view',\n        value: function view(vnode) {\n            return (0, _mithril2.default)('input[type=number,max=720]', {\n                oninput: function oninput(e) {\n                    return console.log(results[vnode.attrs.idx] = Number(e.target.value));\n                },\n                value: results[vnode.attrs.idx],\n                style: 'width:30px'\n            });\n        }\n    }]);\n\n    return ResultInput;\n}();\n\nvar FunctionChooser = function () {\n    function FunctionChooser() {\n        _classCallCheck(this, FunctionChooser);\n    }\n\n    _createClass(FunctionChooser, [{\n        key: 'view',\n        value: function view(vnode) {\n            return (0, _mithril2.default)('select', {\n                onchange: function onchange(e) {\n                    return fs[vnode.attrs.eq][vnode.attrs.idx] = functions.filter(function (f) {\n                        return e.target.value === f.text;\n                    })[0].f;\n                },\n                value: functions.filter(function (f) {\n                    return f.f === fs[vnode.attrs.eq][vnode.attrs.idx];\n                })[0].text\n            }, functions.map(function (f) {\n                return (0, _mithril2.default)('option', f.text);\n            }));\n        }\n    }]);\n\n    return FunctionChooser;\n}();\n\nvar fields = [[(0, _mithril2.default)(NumberView, {\n    idx: 0,\n    n: n.numbers\n}), (0, _mithril2.default)(FunctionChooser, {\n    eq: 0,\n    idx: 0\n}), (0, _mithril2.default)(NumberView, {\n    idx: 1\n}), (0, _mithril2.default)(FunctionChooser, {\n    eq: 0,\n    idx: 1\n}), (0, _mithril2.default)(NumberView, {\n    idx: 2\n}), '=', (0, _mithril2.default)(ResultInput, {\n    idx: 0\n})], [(0, _mithril2.default)(FunctionChooser, {\n    eq: 3,\n    idx: 0\n}), empty, (0, _mithril2.default)(FunctionChooser, {\n    eq: 4,\n    idx: 0\n}), empty, (0, _mithril2.default)(FunctionChooser, {\n    eq: 5,\n    idx: 0\n}), empty, empty], [(0, _mithril2.default)(NumberView, {\n    idx: 3\n}), (0, _mithril2.default)(FunctionChooser, {\n    eq: 1,\n    idx: 0\n}), (0, _mithril2.default)(NumberView, {\n    idx: 4\n}), (0, _mithril2.default)(FunctionChooser, {\n    eq: 1,\n    idx: 1\n}), (0, _mithril2.default)(NumberView, {\n    idx: 5\n}), equals, (0, _mithril2.default)(ResultInput, {\n    idx: 1\n})], [(0, _mithril2.default)(FunctionChooser, {\n    eq: 3,\n    idx: 1\n}), empty, (0, _mithril2.default)(FunctionChooser, {\n    eq: 4,\n    idx: 1\n}), empty, (0, _mithril2.default)(FunctionChooser, {\n    eq: 5,\n    idx: 1\n}), empty, empty], [(0, _mithril2.default)(NumberView, {\n    idx: 6\n}), (0, _mithril2.default)(FunctionChooser, {\n    eq: 2,\n    idx: 0\n}), (0, _mithril2.default)(NumberView, {\n    idx: 7\n}), (0, _mithril2.default)(FunctionChooser, {\n    eq: 2,\n    idx: 1\n}), (0, _mithril2.default)(NumberView, {\n    idx: 8\n}), equals, (0, _mithril2.default)(ResultInput, {\n    idx: 2\n})], [equals, empty, equals, empty, equals, empty, empty], [(0, _mithril2.default)(ResultInput, {\n    idx: 3\n}), empty, (0, _mithril2.default)(ResultInput, {\n    idx: 4\n}), empty, (0, _mithril2.default)(ResultInput, {\n    idx: 5\n}), empty, (0, _mithril2.default)('button', {\n    onclick: function onclick() {\n        console.log(setNumbers(_underscore2.default.flatten(permute([1, 2, 3, 4, 5, 6, 7, 8, 9]).find(test_))\n        //     [1,2,3,4,5,6,7,8,9]\n        ));\n        _mithril2.default.redraw();\n    }\n}, 'go')]];\n\nvar ComputeSquare = function () {\n    function ComputeSquare() {\n        _classCallCheck(this, ComputeSquare);\n    }\n\n    _createClass(ComputeSquare, [{\n        key: 'view',\n        value: function view(vnode) {\n            return (0, _mithril2.default)('.container', (0, _mithril2.default)('table', fields.map(function (row) {\n                return (0, _mithril2.default)('tr', {\n                    style: \"height:20px\"\n                }, row.map(function (col) {\n                    return (0, _mithril2.default)('td', {\n                        style: \"padding:3px;border-width:1px;border-color:black;border-style:solid;width:20px;\"\n                    }, col);\n                }));\n            })), (0, _mithril2.default)('pre', JSON.stringify(results)), (0, _mithril2.default)('pre', JSON.stringify(n.numbers)), (0, _mithril2.default)('pre', JSON.stringify(_underscore2.default.flatten(fs).map(fn2str)))\n\n            //     m('pre', JSON.stringify(numbers))\n            );\n        }\n    }]);\n\n    return ComputeSquare;\n}();\n\nexports.default = ComputeSquare;\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2NvbXB1dGVzcXVhcmUuanM/OTkyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcbmltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG5sZXQgbiA9IHtcbiAgICBudW1iZXJzOiBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV1cbn07XG5sZXQgcmVzdWx0cyA9IFs2NiwgMTMsIDYwLCAzLCA3MiwgMzBdO1xubGV0IHJlc3VsdHNfXyA9IFs2LCAxNSwgMjQsIDEyLCAxNSwgMThdO1xuXG5sZXQgdGltZXNfID0gKGEsIGIpID0+IGEgKiBiO1xubGV0IG1pbnVzXyA9IChhLCBiKSA9PiBhIC0gYjtcbmxldCBhZGRfX18gPSAoYSwgYikgPT4gYSArIGI7XG5sZXQgZGl2X19fID0gKGEsIGIpID0+IGEgLyBiO1xuXG5sZXQgaWQgPSBhID0+IGE7XG5sZXQgdW5pb24gPSAoLi4uYSkgPT4gWy4uLmFdO1xuXG5sZXQgcGVlayA9IGEgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKGEpO1xuICAgIHJldHVybiBhO1xufVxuXG52YXIgcmFuZ2UgPSAoc3RhcnRJbmNsdXNpdmUsIGVuZEV4Y2x1c2l2ZSkgPT4ge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmNsdXNpdmU7IGkgPCBlbmRFeGNsdXNpdmU7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmxldCBmcyA9IFtcbiAgICBbdGltZXNfLCBtaW51c19dLFxuICAgIFt0aW1lc18sIG1pbnVzX10sXG4gICAgW3RpbWVzXywgdGltZXNfXSxcbiAgICBbbWludXNfLCB0aW1lc19dLFxuICAgIFt0aW1lc18sIHRpbWVzX10sXG4gICAgW3RpbWVzXywgdGltZXNfXVxuXTtcbmxldCBmc19fXyA9IFtcbiAgICBbYWRkX19fLCBhZGRfX19dLFxuICAgIFthZGRfX18sIGFkZF9fX10sXG4gICAgW2FkZF9fXywgYWRkX19fXSxcbiAgICBbYWRkX19fLCBhZGRfX19dLFxuICAgIFthZGRfX18sIGFkZF9fX10sXG4gICAgW2FkZF9fXywgYWRkX19fXVxuXTtcbmxldCBlbXB0eSA9ICcnO1xubGV0IGVxdWFscyA9ICc9JztcbmxldCB0aW1lcyA9ICd4JztcbmxldCBtaW51cyA9ICctJztcblxubGV0IGNyZWF0ZUVxdWF0aW9uID0gKGYsIHIpID0+IG4gPT4ge1xuICAgIC8vICBjb25zb2xlLmxvZygnY3JlYXRlJywgZiwgciwgbilcbiAgICByZXR1cm4gZlsxXShmWzBdKG5bMF0sIG5bMV0pLCBuWzJdKSAtIHJcbn07XG5cbmNvbnN0IHNwbGl0ID0gKGFyciwgbikgPT4ge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBkbyB7XG4gICAgICAgIHJlc3VsdC5wdXNoKF8uZmlyc3QoYXJyLCBuKSk7XG4gICAgfSB3aGlsZSAoKGFyciA9IF8ucmVzdChhcnIsIG4pKS5sZW5ndGggPj0gbik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciB6aXBXaXRoID0gKGZuLCAuLi5hcnJzKSA9PiB7XG4gICAgcmV0dXJuIHJhbmdlKDAsIE1hdGgubWluKC4uLmFycnMubWFwKGFyciA9PiBhcnIubGVuZ3RoKSkpLlxuICAgIG1hcChpID0+IGZuKC4uLihhcnJzLm1hcChhcnIgPT4gYXJyW2ldKSkpKTtcbn07XG5cbmNvbnN0IHRyYW5zcG9zZSA9ICguLi5hcnJPQXJycykgPT4gemlwV2l0aCh1bmlvbiwgLi4uYXJyT0FycnMpO1xuXG5jb25zb2xlLmxvZyh0cmFuc3Bvc2UoWzAsIDFdLCBbMiwgM10pKVxuXG4vL2NvbnNvbGUubG9nKCd0cicsIHRyYW5zcG9zZSguLi5zcGxpdChudW1iZXJzLCAzKSkpO1xuLy9jb25zb2xlLmxvZygnaWQnLCBzcGxpdChudW1iZXJzLCAzKSk7XG5cbi8vIGxldCBlcXVhdGlvbnNfID0gbnVtYmVycyA9PiBbdW5pb24sIHRyYW5zcG9zZV0ubWFwKHRyID0+IHRyKG51bWJlcnMpKTtcblxubGV0IG9uID0gKGZucywgYXJyKSA9PiBmbnMubWFwKChmLCBpZHgpID0+IHtcbiAgICAvLyAgICBjb25zb2xlLmxvZygnb24nLCBmLCBhcnJbaWR4XSk7XG4gICAgcmV0dXJuIGYoYXJyW2lkeF0pO1xufSk7XG5cbmxldCBlcXVhdGlvbnMgPSAoKT0+IGZzXG4gICAgLm1hcCgoZiwgaWR4KSA9PiBjcmVhdGVFcXVhdGlvbihmLCByZXN1bHRzW2lkeF0pKVxuXG5cbmxldCBzcGxpdHRlciA9IG51bWJlcnMgPT4gWy4uLnNwbGl0KG51bWJlcnMsIDMpLCAuLi50cmFuc3Bvc2UoLi4uc3BsaXQobnVtYmVycywgMykpXVxuXG5jb25zdCB0ZXN0XyA9IG51bWJlcnMgPT4gb24oZXF1YXRpb25zKCksIHNwbGl0dGVyKG51bWJlcnMpLm1hcChwZWVrKSkubWFwKHBlZWspLmV2ZXJ5KGUgPT4gZSA9PT0gMCk7XG5cbi8vY29uc29sZS5sb2codGVzdF8oZXF1YXRpb25zKShbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV0pKTtcblxuY29uc3QgdGVzdCA9IG51bWJlcnMgPT5cbiAgICBlcXVhdGlvbnMoKS5ldmVyeShlcXVhdGlvbiA9PiBlcXVhdGlvbihudW1iZXJzKSA9PT0gMCk7XG5cbmNvbnN0IHBlcm11dGUgPSBwZXJtdXRhdGlvbiA9PiB7XG4gICAgdmFyIGxlbmd0aCA9IHBlcm11dGF0aW9uLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gW3Blcm11dGF0aW9uLnNsaWNlKCldLFxuICAgICAgICBjID0gbmV3IEFycmF5KGxlbmd0aCkuZmlsbCgwKSxcbiAgICAgICAgaSA9IDEsXG4gICAgICAgIGssIHA7XG5cbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoY1tpXSA8IGkpIHtcbiAgICAgICAgICAgIGsgPSBpICUgMiAmJiBjW2ldO1xuICAgICAgICAgICAgcCA9IHBlcm11dGF0aW9uW2ldO1xuICAgICAgICAgICAgcGVybXV0YXRpb25baV0gPSBwZXJtdXRhdGlvbltrXTtcbiAgICAgICAgICAgIHBlcm11dGF0aW9uW2tdID0gcDtcbiAgICAgICAgICAgICsrY1tpXTtcbiAgICAgICAgICAgIGkgPSAxO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGVybXV0YXRpb24uc2xpY2UoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjW2ldID0gMDtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vL2NvbnNvbGUubG9nKHBlcm11dGUobnVtYmVycykpXG5cbi8vY29uc29sZS5sb2cobnVtYmVycyA9IHBlcm11dGUobnVtYmVycykuZmlsdGVyKHRlc3RfKVswXSk7XG5cbmNvbnN0IGZ1bmN0aW9ucyA9IFt7XG4gICAgICAgIHRleHQ6ICcrJyxcbiAgICAgICAgZjogYWRkX19fXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRleHQ6ICctJyxcbiAgICAgICAgZjogbWludXNfXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRleHQ6ICd4JyxcbiAgICAgICAgZjogdGltZXNfXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRleHQ6ICcvJyxcbiAgICAgICAgZjogZGl2X19fXG4gICAgfVxuXTtcblxuY29uc3QgZmluZFNvbHV0aW9uID0gKCkgPT4gcGVybXV0ZShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICAgIC5maWx0ZXIodGVzdF8pXG4gICAgWzBdO1xuXG5cbmNvbnN0IGZuMnN0ciA9IChmKSA9PiBmdW5jdGlvbnMuZmlsdGVyKGZuID0+IGZuLmYgPT09IGYpWzBdLnRleHQ7XG5cbmNvbnNvbGUubG9nKGZpZWxkcylcblxubGV0IGdldE51bWJlciA9IGlkeCA9PiBuLm51bWJlcnNbaWR4XTtcblxubGV0IHNldE51bWJlcnMgPSBudW0gPT4gbi5udW1iZXJzID0gbnVtO1xuXG5jbGFzcyBOdW1iZXJWaWV3IHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHZub2RlLmF0dHJzKVxuICAgICAgICByZXR1cm4gbSgnc3BhbicsIGdldE51bWJlcih2bm9kZS5hdHRycy5pZHgpKTtcbiAgICB9XG59XG5cbmNsYXNzIFJlc3VsdElucHV0IHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIHJldHVybiBtKCdpbnB1dFt0eXBlPW51bWJlcixtYXg9NzIwXScsIHtcbiAgICAgICAgICAgIG9uaW5wdXQ6IGUgPT4gY29uc29sZS5sb2cocmVzdWx0c1t2bm9kZS5hdHRycy5pZHhdID0gIE51bWJlciggZS50YXJnZXQudmFsdWUpKSxcbiAgICAgICAgICAgIHZhbHVlOiByZXN1bHRzW3Zub2RlLmF0dHJzLmlkeF0sXG4gICAgICAgICAgICBzdHlsZTogJ3dpZHRoOjMwcHgnXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgRnVuY3Rpb25DaG9vc2VyIHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIHJldHVybiBtKCdzZWxlY3QnLCB7XG4gICAgICAgICAgICBvbmNoYW5nZTogKGUpID0+IGZzW3Zub2RlLmF0dHJzLmVxXVt2bm9kZS5hdHRycy5pZHhdID0gZnVuY3Rpb25zLmZpbHRlcihmID0+IGUudGFyZ2V0LnZhbHVlID09PSBmLnRleHQpWzBdLmYsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb25zLmZpbHRlcihmID0+IGYuZiA9PT0gZnNbdm5vZGUuYXR0cnMuZXFdW3Zub2RlLmF0dHJzLmlkeF0pWzBdLnRleHRcbiAgICAgICAgfSwgZnVuY3Rpb25zLm1hcChmID0+IG0oJ29wdGlvbicsIGYudGV4dCkpKVxuICAgIH1cbn1cblxubGV0IGZpZWxkcyA9IFtcbiAgICBbXG4gICAgICAgIG0oTnVtYmVyVmlldywge1xuICAgICAgICAgICAgaWR4OiAwLFxuICAgICAgICAgICAgbjogbi5udW1iZXJzXG4gICAgICAgIH0pLFxuICAgICAgICBtKEZ1bmN0aW9uQ2hvb3Nlciwge1xuICAgICAgICAgICAgZXE6IDAsXG4gICAgICAgICAgICBpZHg6IDBcbiAgICAgICAgfSksIG0oTnVtYmVyVmlldywge1xuICAgICAgICAgICAgaWR4OiAxXG4gICAgICAgIH0pLFxuICAgICAgICBtKEZ1bmN0aW9uQ2hvb3Nlciwge1xuICAgICAgICAgICAgZXE6IDAsXG4gICAgICAgICAgICBpZHg6IDFcbiAgICAgICAgfSksIG0oTnVtYmVyVmlldywge1xuICAgICAgICAgICAgaWR4OiAyXG4gICAgICAgIH0pLCAnPScsIG0oUmVzdWx0SW5wdXQsIHtcbiAgICAgICAgICAgIGlkeDogMFxuICAgICAgICB9KVxuICAgIF0sXG4gICAgW1xuICAgICAgICBtKEZ1bmN0aW9uQ2hvb3Nlciwge1xuICAgICAgICAgICAgZXE6IDMsXG4gICAgICAgICAgICBpZHg6IDBcbiAgICAgICAgfSksIGVtcHR5LCBtKEZ1bmN0aW9uQ2hvb3Nlciwge1xuICAgICAgICAgICAgZXE6IDQsXG4gICAgICAgICAgICBpZHg6IDBcbiAgICAgICAgfSksIGVtcHR5LCBtKEZ1bmN0aW9uQ2hvb3Nlciwge1xuICAgICAgICAgICAgZXE6IDUsXG4gICAgICAgICAgICBpZHg6IDBcbiAgICAgICAgfSksIGVtcHR5LCBlbXB0eVxuICAgIF0sXG4gICAgW20oTnVtYmVyVmlldywge1xuICAgICAgICAgICAgaWR4OiAzXG4gICAgICAgIH0pLFxuICAgICAgICBtKEZ1bmN0aW9uQ2hvb3Nlciwge1xuICAgICAgICAgICAgZXE6IDEsXG4gICAgICAgICAgICBpZHg6IDBcbiAgICAgICAgfSksIG0oTnVtYmVyVmlldywge1xuICAgICAgICAgICAgaWR4OiA0XG4gICAgICAgIH0pLFxuICAgICAgICBtKEZ1bmN0aW9uQ2hvb3Nlciwge1xuICAgICAgICAgICAgZXE6IDEsXG4gICAgICAgICAgICBpZHg6IDFcbiAgICAgICAgfSksIG0oTnVtYmVyVmlldywge1xuICAgICAgICAgICAgaWR4OiA1XG4gICAgICAgIH0pLCBlcXVhbHMsIG0oUmVzdWx0SW5wdXQsIHtcbiAgICAgICAgICAgIGlkeDogMVxuICAgICAgICB9KVxuICAgIF0sXG4gICAgW1xuICAgICAgICBtKEZ1bmN0aW9uQ2hvb3Nlciwge1xuICAgICAgICAgICAgZXE6IDMsXG4gICAgICAgICAgICBpZHg6IDFcbiAgICAgICAgfSksIGVtcHR5LFxuICAgICAgICBtKEZ1bmN0aW9uQ2hvb3Nlciwge1xuICAgICAgICAgICAgZXE6IDQsXG4gICAgICAgICAgICBpZHg6IDFcbiAgICAgICAgfSksIGVtcHR5LFxuICAgICAgICBtKEZ1bmN0aW9uQ2hvb3Nlciwge1xuICAgICAgICAgICAgZXE6IDUsXG4gICAgICAgICAgICBpZHg6IDFcbiAgICAgICAgfSksIGVtcHR5LCBlbXB0eVxuICAgIF0sXG4gICAgW20oTnVtYmVyVmlldywge1xuICAgICAgICBpZHg6IDZcbiAgICB9KSwgbShGdW5jdGlvbkNob29zZXIsIHtcbiAgICAgICAgZXE6IDIsXG4gICAgICAgIGlkeDogMFxuICAgIH0pLCBtKE51bWJlclZpZXcsIHtcbiAgICAgICAgaWR4OiA3XG4gICAgfSksIG0oRnVuY3Rpb25DaG9vc2VyLCB7XG4gICAgICAgIGVxOiAyLFxuICAgICAgICBpZHg6IDFcbiAgICB9KSwgbShOdW1iZXJWaWV3LCB7XG4gICAgICAgIGlkeDogOFxuICAgIH0pLCBlcXVhbHMsIG0oUmVzdWx0SW5wdXQsIHtcbiAgICAgICAgaWR4OiAyXG4gICAgfSldLFxuICAgIFtlcXVhbHMsIGVtcHR5LCBlcXVhbHMsIGVtcHR5LCBlcXVhbHMsIGVtcHR5LCBlbXB0eV0sXG4gICAgW20oUmVzdWx0SW5wdXQsIHtcbiAgICAgICAgaWR4OiAzXG4gICAgfSksIGVtcHR5LCBtKFJlc3VsdElucHV0LCB7XG4gICAgICAgIGlkeDogNFxuICAgIH0pLCBlbXB0eSwgbShSZXN1bHRJbnB1dCwge1xuICAgICAgICBpZHg6IDVcbiAgICB9KSwgZW1wdHksIG0oJ2J1dHRvbicsIHtcbiAgICAgICAgb25jbGljazogKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coc2V0TnVtYmVycyhcbiAgICAgICAgICAgICAgICBfLmZsYXR0ZW4ocGVybXV0ZShbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV0pLmZpbmQodGVzdF8pKVxuICAgICAgICAgICAgICAgIC8vICAgICBbMSwyLDMsNCw1LDYsNyw4LDldXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICAgIG0ucmVkcmF3KClcbiAgICAgICAgfVxuICAgIH0sICdnbycpXVxuXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcHV0ZVNxdWFyZSB7XG4gICAgdmlldyh2bm9kZSkge1xuICAgICAgICByZXR1cm4gbSgnLmNvbnRhaW5lcicsXG4gICAgICAgICAgICBtKCd0YWJsZScsXG4gICAgICAgICAgICAgICAgZmllbGRzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgcm93ID0+IG0oJ3RyJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcImhlaWdodDoyMHB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByb3cubWFwKGNvbCA9PiBtKCd0ZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogXCJwYWRkaW5nOjNweDtib3JkZXItd2lkdGg6MXB4O2JvcmRlci1jb2xvcjpibGFjaztib3JkZXItc3R5bGU6c29saWQ7d2lkdGg6MjBweDtcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY29sKSlcbiAgICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbSgncHJlJywgSlNPTi5zdHJpbmdpZnkocmVzdWx0cykpLFxuICAgICAgICAgICAgbSgncHJlJywgSlNPTi5zdHJpbmdpZnkobi5udW1iZXJzKSksXG4gICAgICAgICAgICBtKCdwcmUnLCBKU09OLnN0cmluZ2lmeShfLmZsYXR0ZW4oZnMpLm1hcChmbjJzdHIpKSlcblxuICAgICAgICAgICAgLy8gICAgIG0oJ3ByZScsIEpTT04uc3RyaW5naWZ5KG51bWJlcnMpKVxuICAgICAgICApO1xuICAgIH1cbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9jb21wdXRlc3F1YXJlLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFJQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBRkE7QUFDQTtBQUtBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBSEE7QUFLQTs7Ozs7O0FBR0E7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBR0E7QUFBQTtBQUNBOzs7Ozs7QUFHQTtBQUdBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFGQTtBQUlBO0FBREE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQURBO0FBR0E7QUFEQTtBQU1BO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQU1BO0FBREE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQURBO0FBSUE7QUFDQTtBQUZBO0FBSUE7QUFEQTtBQUdBO0FBREE7QUFNQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBRkE7QUFNQTtBQURBO0FBR0E7QUFDQTtBQUZBO0FBSUE7QUFEQTtBQUdBO0FBQ0E7QUFGQTtBQUlBO0FBREE7QUFHQTtBQURBO0FBS0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFDQTtBQUVBO0FBRkE7QUFJQTtBQUNBO0FBUEE7QUFDQTtBQVVBOzs7Ozs7O0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUFBO0FBSEE7QUFDQTtBQWNBO0FBbEJBO0FBb0JBOzs7Ozs7QUF0QkE7QUF1QkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///22\n");

/***/ }),
/* 23 */
/*!**********************!*\
  !*** ./src/ships.js ***!
  \**********************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _taglMithril = __webpack_require__(/*! tagl-mithril */ 24);\n\nvar _taglMithril2 = _interopRequireDefault(_taglMithril);\n\nvar _fn = __webpack_require__(/*! ./fn */ 2);\n\nvar _fn2 = _interopRequireDefault(_fn);\n\nvar _stack = __webpack_require__(/*! ./stack */ 26);\n\nvar _stack2 = _interopRequireDefault(_stack);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar debug = function debug(a) {\n  return function (e) {\n    console.log(a, e);\n    return e;\n  };\n};\n\nvar games = {\n  \"15./16.12. 2018\": {\n    hintsRow: [9, 1, 8, 1, 6, 2, 2, 5, 3, 4, 3, 1],\n    hintsColumn: [3, 6, 2, 3, 7, 2, 1, 7, 2, 2, 6, 4],\n    width: 12,\n    field: [[0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],\n    ships: [5, 4, 4, 2, 6, 5, 3, 7, 6, 3]\n  },\n  \"12./13.01. 2019\": {\n    hintsRow: [2, 6, 1, 6, 3, 3, 4, 4, 2, 4, 7, 3],\n    hintsColumn: [6, 3, 9, 1, 1, 7, 2, 3, 6, 3, 2, 2],\n    width: 12,\n    field: [[0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],\n    ships: [5, 4, 4, 2, 6, 5, 3, 7, 6, 3]\n  },\n  \"12./13.01. 2019 partly solved\": {\n    hintsRow: [2, 6, 1, 6, 3, 3, 4, 4, 2, 4, 7, 3],\n    hintsColumn: [6, 3, 9, 1, 1, 7, 2, 3, 6, 3, 2, 2],\n    width: 12,\n    field: [[1, 5, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 3, 1, 0, 0, 0, 0, 3, 0, 0, 0], [2, 1, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0], [3, 1, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0], [2, 1, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 6, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [5, 3, 3, 7, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 0, 2, 3, 3, 3, 3, 2, 0], [5, 3, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1]],\n    ships: [5, 4, 4, 2, 6, 5, 3, 7, 6, 3]\n  },\n  test: {\n    hintsRow: [2, 6, 1, 6, 3, 3, 4, 4, 2, 4, 7, 3],\n    hintsColumn: [6, 3, 9, 1, 1, 7, 2, 3, 6, 3, 2, 2],\n    width: 12,\n    field: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],\n    ships: [5, 4, 4, 2, 6, 5, 3, 7, 6, 3]\n  }\n};\n\nvar _tagl = (0, _taglMithril2.default)(_mithril2.default),\n    nav = _tagl.nav,\n    article = _tagl.article,\n    a = _tagl.a,\n    div = _tagl.div,\n    h1 = _tagl.h1,\n    h2 = _tagl.h2,\n    h3 = _tagl.h3,\n    svg = _tagl.svg,\n    input = _tagl.input,\n    button = _tagl.button,\n    pre = _tagl.pre,\n    polygon = _tagl.polygon,\n    polyline = _tagl.polyline;\n\nvar innerHeight = window.innerHeight;\nvar innerWidth = window.innerWidth;\n\nwindow.addEventListener(\"resize\", function (ev) {\n  innerHeight = ev.target.innerHeight;\n  innerWidth = ev.target.innerWidth;\n  _mithril2.default.redraw();\n});\n\nvar gameWidth = 12;\n\nvar type = Object.freeze(Object.assign({}, {\n  UNKNOWN: 0,\n  WATER: 1,\n  SHIP_UNKNOWN: 2,\n  SHIP_MIDDLE: 3,\n  SHIP_NORTH_END: 4,\n  SHIP_WEST_END: 5,\n  SHIP_SOUTH_END: 6,\n  SHIP_EAST_END: 7\n}));\n\nvar direction = Object.freeze({\n  HORIZONTAL: 0,\n  VERTICAL: 1\n});\n\nvar gameModel = function gameModel(_width) {\n  var cb = null;\n  var hintsRow = _fn2.default.range(0, _width).map(function (l) {\n    return 0;\n  });\n  var hintsColumn = _fn2.default.range(0, _width).map(function (l) {\n    return 0;\n  });\n  var field = _fn2.default.range(0, _width).map(function (k) {\n    return _fn2.default.range(0, _width).map(function (l) {\n      return type.UNKNOWN;\n    });\n  });\n  var _ships = [4, 5];\n  var setFieldAt = function setFieldAt(r, c, v) {\n    field[r][c] = v;\n    cb && cb();\n  };\n  var fieldAt = function fieldAt(r, c) {\n    return field[r][c];\n  };\n  var fieldCoords = function fieldCoords() {\n    var res = [];\n    _fn2.default.range(0, _width).forEach(function (x) {\n      return _fn2.default.range(0, _width).forEach(function (y) {\n        return res.push({ x: x, y: y });\n      });\n    });\n    return res;\n  };\n  var neighbours = function neighbours(_ref) {\n    var x = _ref.x,\n        y = _ref.y;\n\n    var res = [];\n    _fn2.default.interval(Math.max(0, x - 1), Math.min(x + 1, _width - 1)).forEach(function (nx) {\n      return _fn2.default.interval(Math.max(0, y - 1), Math.min(y + 1, _width - 1)).filter(function (ny) {\n        return !(nx === x && ny === y);\n      }).forEach(function (ny) {\n        return res.push({ x: nx, y: ny });\n      });\n    });\n    return res;\n  };\n  var clearWater = function clearWater() {\n    fieldCoords().forEach(function (p) {\n      return fieldAt(p.y, p.x) === type.WATER ? setFieldAt(p.y, p.x, type.UNKNOWN) : null;\n    });\n  };\n  var refreshWater = function refreshWater() {\n    return fieldCoords().forEach(function (p) {\n      if (fieldAt(p.y, p.x) === type.UNKNOWN) {\n        var neighbourValues = neighbours(p).map(function (pos) {\n          return fieldAt(pos.y, pos.x);\n        });\n        if (neighbourValues.find(function (v) {\n          return v >= type.SHIP_UNKNOWN;\n        })) {\n          setFieldAt(p.y, p.x, type.WATER);\n        }\n      }\n    });\n  };\n  return {\n    hintAt: function hintAt(r, c) {\n      return r === 0 ? hintsColumn[c - 1] : hintsRow[r - 1];\n    },\n    setHintAt: function setHintAt(r, c, v) {\n      if (r === 0) hintsColumn[c - 1] = v;else hintsRow[r - 1] = v;\n      cb && cb();\n    },\n    fieldAt: fieldAt,\n    setFieldAt: setFieldAt,\n    placeShip: function placeShip(r, c, l, d) {\n      var shipCoords = _fn2.default.range(0, l).map(function (segment) {\n        return {\n          x: c + (d === direction.HORIZONTAL ? segment : 0),\n          y: r + (d === direction.VERTICAL ? segment : 0)\n        };\n      }).filter(function (p) {\n        return p.x >= 0 && p.x < _width && p.y >= 0 && p.y < _width;\n      });\n\n      if (shipCoords.length !== l) return false;\n\n      if (!shipCoords.map(function (p) {\n        return fieldAt(p.y, p.x);\n      }).every(function (v) {\n        return v === type.UNKNOWN;\n      })) {\n        return false;\n      }\n\n      switch (d) {\n        case direction.VERTICAL:\n          setFieldAt(r, c, type.SHIP_NORTH_END);\n          _fn2.default.range(1, l - 1).forEach(function (i) {\n            return setFieldAt(r + i, c, type.SHIP_MIDDLE);\n          });\n          setFieldAt(r + l - 1, c, type.SHIP_SOUTH_END);\n          break;\n        case direction.HORIZONTAL:\n          setFieldAt(r, c, type.SHIP_WEST_END);\n          _fn2.default.range(1, l - 1).forEach(function (i) {\n            return setFieldAt(r, c + i, type.SHIP_MIDDLE);\n          });\n          setFieldAt(r, c + l - 1, type.SHIP_EAST_END);\n          break;\n        default:\n          break;\n      }\n      clearWater();\n      refreshWater();\n      return true;\n    },\n    setShip: function setShip(idx, size) {\n      _ships[idx] = Math.min(_width, size);\n      cb && cb();\n    },\n    removeShip: function removeShip(idx) {\n      _ships.splice(idx, 1);\n      cb && cb();\n    },\n    addShip: function addShip() {\n      _ships.push(2);\n      cb && cb();\n    },\n    isWon: function isWon() {\n      return false;\n    },\n    ships: function ships() {\n      return _ships;\n    },\n    width: function width() {\n      return _width;\n    },\n    setChangeCallback: function setChangeCallback(f) {\n      return cb = f;\n    },\n    data: function data() {\n      return {\n        hintsRow: hintsRow,\n        hintsColumn: hintsColumn,\n        width: _width,\n        field: field,\n        ships: _ships\n      };\n    },\n    fromData: function fromData(d) {\n      hintsRow = d.hintsRow;\n      hintsColumn = d.hintsColumn;\n      _width = d.width;\n      field = d.field;\n      _ships = d.ships;\n    }\n  };\n};\n\nvar g = gameModel(gameWidth);\n\ng.fromData(games[Object.keys(games)[1]]);\n\nvar history = (0, _stack2.default)(g.data());\ng.setChangeCallback(function () {\n  return history.push(g.data());\n});\n\nvar shipsToPlace = g.ships().map(function (e) {\n  return e;\n});\n\nvar varyPropertyArrays = function varyPropertyArrays(arrays) {\n  return Object.keys(arrays).reduce(function (acc, key) {\n    return arrays[key].flatMap && arrays[key].length > 0 ? arrays[key].flatMap(function (v) {\n      return acc.map(function (obj) {\n        return Object.assign(_defineProperty({}, key, v), obj);\n      });\n    }) : acc.map(function (obj) {\n      return Object.assign(_defineProperty({}, key, arrays[key]), obj);\n    });\n  }, [{}]);\n};\n\nvar solve = function solve() {\n  var solution = [];\n\n  var possibleSolutionsForOneShip = varyPropertyArrays({\n    x: _fn2.default.range(0, 12),\n    y: _fn2.default.range(0, 12),\n    direction: [direction.VERTICAL, direction.HORIZONTAL]\n  });\n\n  var extendSolution = function extendSolution(solution, ships) {\n    if (ships.length === 0) return solution;\n  };\n\n  extendSolution(solution, shipsToPlace);\n\n  solution.forEach(function (ship) {\n    g.placeShip(ship.y, ship.x, ship.length, ship.direction);\n  });\n};\n\nif (false) shipsToPlace.forEach(function (ship) {\n  var possiblePositions = [];\n  _fn2.default.range(0, gameWidth).map(function (x) {\n    return _fn2.default.range(0, gameWidth).map(function (y) {\n      return [direction.VERTICAL, direction.HORIZONTAL].map(function (direction) {\n        possiblePositions.push({ x: x, y: y, direction: direction });\n      });\n    });\n  });\n  var idx = 0;\n  while (!g.placeShip(possiblePositions[idx].y, possiblePositions[idx].x, ship, possiblePositions[idx].direction)) {\n    idx++;\n  }solution.push(possiblePositions[idx]);\n});\n\nvar GameField = function () {\n  function GameField() {\n    _classCallCheck(this, GameField);\n  }\n\n  _createClass(GameField, [{\n    key: \"view\",\n    value: function view(vnode) {\n      var w = g.width() + 1;\n      return div.gamefield([_fn2.default.range(0, w * w).map(function (l) {\n        return {\n          x: l % w,\n          y: Math.floor(l / w)\n        };\n      }).map(function (l) {\n        return l.x !== 0 || l.y !== 0 ? l.x === 0 || l.y === 0 ? input.box.input({\n          value: g.hintAt(l.y, l.x),\n          oninput: _mithril2.default.withAttr(\"value\", function (v) {\n            return g.setHintAt(l.y, l.x, Number(v));\n          })\n        }) : g.fieldAt(l.y - 1, l.x - 1) === type.UNKNOWN ? div.box.empty({\n          onclick: function onclick() {\n            return g.setFieldAt(l.y - 1, l.x - 1, type.WATER);\n          }\n        }) : g.fieldAt(l.y - 1, l.x - 1) === type.WATER ? div.box.water({\n          onclick: function onclick() {\n            return g.setFieldAt(l.y - 1, l.x - 1, type.SHIP_UNKNOWN);\n          }\n        }) : div.box[\"ship-\" + g.fieldAt(l.y - 1, l.x - 1)]({\n          onclick: function onclick() {\n            return g.setFieldAt(l.y - 1, l.x - 1, (g.fieldAt(l.y - 1, l.x - 1) + 1) % 8);\n          }\n        }, \"\" + l.x + \",\" + l.y) : history.dirty() ? button.box.empty({\n          onclick: function onclick() {\n            return g.fromData(history.pop());\n          }\n        }, \"⬅️\") : div.box.empty();\n      })]);\n    }\n  }]);\n\n  return GameField;\n}();\n\nvar Ships = function () {\n  function Ships() {\n    _classCallCheck(this, Ships);\n  }\n\n  _createClass(Ships, [{\n    key: \"view\",\n    value: function view(vnode) {\n      return [div.ships([g.ships().map(function (shipSize, shipIdx) {\n        return div.ship({\n          key: shipIdx\n        }, [button.shipcell.shipcellfirst({\n          onclick: function onclick() {\n            return shipSize - 1 >= 2 ? g.setShip(shipIdx, shipSize - 1) : g.removeShip(shipIdx);\n          }\n        }, \"-\"), _fn2.default.range(0, shipSize - 2).map(function (i) {\n          return div.shipcell({\n            key: i\n          });\n        }), button.shipcell.shipcelllast({\n          onclick: function onclick() {\n            return g.setShip(shipIdx, shipSize + 1);\n          }\n        }, \"+\")]);\n      }), button.box.empty({\n        onclick: function onclick() {\n          return g.addShip();\n        }\n      }, \"+\")])];\n    }\n  }]);\n\n  return Ships;\n}();\n\nvar ShipsView = function () {\n  function ShipsView() {\n    _classCallCheck(this, ShipsView);\n  }\n\n  _createClass(ShipsView, [{\n    key: \"view\",\n    value: function view(vnode) {\n      return div.container([(0, _mithril2.default)(\"h1\", \"Ships \" + (g.isWon() ? \"Won\" : \"Not won\"), button.btn.btnPrimary({ onclick: function onclick() {\n          return g.fromData(history.clear());\n        } }, \"Clear\")), div.maingrid([(0, _mithril2.default)(GameField), (0, _mithril2.default)(Ships)]), pre(JSON.stringify({\n        rowSum: g.data().hintsRow.reduce(function (a, b) {\n          return a + b;\n        }, 0),\n        colSum: g.data().hintsColumn.reduce(function (a, b) {\n          return a + b;\n        }, 0)\n      })), pre(JSON.stringify(g.data(), null, 2))]);\n    }\n  }]);\n\n  return ShipsView;\n}();\n\nexports.default = ShipsView;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3NoaXBzLmpzPzFhM2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG0gZnJvbSBcIm1pdGhyaWxcIjtcbmltcG9ydCB0YWdsIGZyb20gXCJ0YWdsLW1pdGhyaWxcIjtcbmltcG9ydCBmbiBmcm9tIFwiLi9mblwiO1xuXG5pbXBvcnQgc3RhY2sgZnJvbSBcIi4vc3RhY2tcIjtcblxuY29uc3QgZGVidWcgPSBhID0+IGUgPT4ge1xuICBjb25zb2xlLmxvZyhhLCBlKTtcbiAgcmV0dXJuIGU7XG59O1xuXG5jb25zdCBnYW1lcyA9IHtcbiAgXCIxNS4vMTYuMTIuIDIwMThcIjoge1xuICAgIGhpbnRzUm93OiBbOSwgMSwgOCwgMSwgNiwgMiwgMiwgNSwgMywgNCwgMywgMV0sXG4gICAgaGludHNDb2x1bW46IFszLCA2LCAyLCAzLCA3LCAyLCAxLCA3LCAyLCAyLCA2LCA0XSxcbiAgICB3aWR0aDogMTIsXG4gICAgZmllbGQ6IFtcbiAgICAgIFswLCAzLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgIFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgIFswLCAwLCAwLCA1LCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgIFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgIFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgIFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgIFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgIFswLCAwLCAwLCAwLCAwLCAwLCAwLCAzLCAwLCAwLCAwLCAwXSxcbiAgICAgIFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgIFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgIFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgIFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXVxuICAgIF0sXG4gICAgc2hpcHM6IFs1LCA0LCA0LCAyLCA2LCA1LCAzLCA3LCA2LCAzXVxuICB9LFxuICBcIjEyLi8xMy4wMS4gMjAxOVwiOiB7XG4gICAgaGludHNSb3c6IFsyLCA2LCAxLCA2LCAzLCAzLCA0LCA0LCAyLCA0LCA3LCAzXSxcbiAgICBoaW50c0NvbHVtbjogWzYsIDMsIDksIDEsIDEsIDcsIDIsIDMsIDYsIDMsIDIsIDJdLFxuICAgIHdpZHRoOiAxMixcbiAgICBmaWVsZDogW1xuICAgICAgWzAsIDAsIDcsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDMsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdXG4gICAgXSxcbiAgICBzaGlwczogWzUsIDQsIDQsIDIsIDYsIDUsIDMsIDcsIDYsIDNdXG4gIH0sXG4gIFwiMTIuLzEzLjAxLiAyMDE5IHBhcnRseSBzb2x2ZWRcIjoge1xuICAgIGhpbnRzUm93OiBbMiwgNiwgMSwgNiwgMywgMywgNCwgNCwgMiwgNCwgNywgM10sXG4gICAgaGludHNDb2x1bW46IFs2LCAzLCA5LCAxLCAxLCA3LCAyLCAzLCA2LCAzLCAyLCAyXSxcbiAgICB3aWR0aDogMTIsXG4gICAgZmllbGQ6IFtcbiAgICAgIFsxLCA1LCA3LCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxXSxcbiAgICAgIFsxLCAxLCAxLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgIFswLCAxLCA0LCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgIFswLCAxLCAzLCAxLCAwLCAwLCAwLCAwLCAzLCAwLCAwLCAwXSxcbiAgICAgIFsyLCAxLCAzLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgIFszLCAxLCAzLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgIFsyLCAxLCAzLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgIFswLCAxLCA2LCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgIFsxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgIFs1LCAzLCAzLCA3LCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxXSxcbiAgICAgIFsxLCAxLCAxLCAxLCAwLCAyLCAzLCAzLCAzLCAzLCAyLCAwXSxcbiAgICAgIFs1LCAzLCA3LCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxXVxuICAgIF0sXG4gICAgc2hpcHM6IFs1LCA0LCA0LCAyLCA2LCA1LCAzLCA3LCA2LCAzXVxuICB9LFxuICB0ZXN0OiB7XG4gICAgaGludHNSb3c6IFsyLCA2LCAxLCA2LCAzLCAzLCA0LCA0LCAyLCA0LCA3LCAzXSxcbiAgICBoaW50c0NvbHVtbjogWzYsIDMsIDksIDEsIDEsIDcsIDIsIDMsIDYsIDMsIDIsIDJdLFxuICAgIHdpZHRoOiAxMixcbiAgICBmaWVsZDogW1xuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdXG4gICAgXSxcbiAgICBzaGlwczogWzUsIDQsIDQsIDIsIDYsIDUsIDMsIDcsIDYsIDNdXG4gIH1cbn07XG5cbmNvbnN0IHtcbiAgbmF2LFxuICBhcnRpY2xlLFxuICBhLFxuICBkaXYsXG4gIGgxLFxuICBoMixcbiAgaDMsXG4gIHN2ZyxcbiAgaW5wdXQsXG4gIGJ1dHRvbixcbiAgcHJlLFxuICBwb2x5Z29uLFxuICBwb2x5bGluZVxufSA9IHRhZ2wobSk7XG5cbmxldCBpbm5lckhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbmxldCBpbm5lcldpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGV2ID0+IHtcbiAgaW5uZXJIZWlnaHQgPSBldi50YXJnZXQuaW5uZXJIZWlnaHQ7XG4gIGlubmVyV2lkdGggPSBldi50YXJnZXQuaW5uZXJXaWR0aDtcbiAgbS5yZWRyYXcoKTtcbn0pO1xuXG5sZXQgZ2FtZVdpZHRoID0gMTI7XG5cbmNvbnN0IHR5cGUgPSBPYmplY3QuZnJlZXplKFxuICBPYmplY3QuYXNzaWduKFxuICAgIHt9LFxuICAgIHtcbiAgICAgIFVOS05PV046IDAsXG4gICAgICBXQVRFUjogMSxcbiAgICAgIFNISVBfVU5LTk9XTjogMixcbiAgICAgIFNISVBfTUlERExFOiAzLFxuICAgICAgU0hJUF9OT1JUSF9FTkQ6IDQsXG4gICAgICBTSElQX1dFU1RfRU5EOiA1LFxuICAgICAgU0hJUF9TT1VUSF9FTkQ6IDYsXG4gICAgICBTSElQX0VBU1RfRU5EOiA3XG4gICAgfVxuICApXG4pO1xuXG5jb25zdCBkaXJlY3Rpb24gPSBPYmplY3QuZnJlZXplKHtcbiAgSE9SSVpPTlRBTDogMCxcbiAgVkVSVElDQUw6IDFcbn0pO1xuXG5sZXQgZ2FtZU1vZGVsID0gd2lkdGggPT4ge1xuICBsZXQgY2IgPSBudWxsO1xuICBsZXQgaGludHNSb3cgPSBmbi5yYW5nZSgwLCB3aWR0aCkubWFwKGwgPT4gMCk7XG4gIGxldCBoaW50c0NvbHVtbiA9IGZuLnJhbmdlKDAsIHdpZHRoKS5tYXAobCA9PiAwKTtcbiAgbGV0IGZpZWxkID0gZm5cbiAgICAucmFuZ2UoMCwgd2lkdGgpXG4gICAgLm1hcChrID0+IGZuLnJhbmdlKDAsIHdpZHRoKS5tYXAobCA9PiB0eXBlLlVOS05PV04pKTtcbiAgbGV0IHNoaXBzID0gWzQsIDVdO1xuICBjb25zdCBzZXRGaWVsZEF0ID0gKHIsIGMsIHYpID0+IHtcbiAgICBmaWVsZFtyXVtjXSA9IHY7XG4gICAgY2IgJiYgY2IoKTtcbiAgfTtcbiAgY29uc3QgZmllbGRBdCA9IChyLCBjKSA9PiBmaWVsZFtyXVtjXTtcbiAgY29uc3QgZmllbGRDb29yZHMgPSAoKSA9PiB7XG4gICAgbGV0IHJlcyA9IFtdO1xuICAgIGZuLnJhbmdlKDAsIHdpZHRoKS5mb3JFYWNoKHggPT5cbiAgICAgIGZuLnJhbmdlKDAsIHdpZHRoKS5mb3JFYWNoKHkgPT4gcmVzLnB1c2goeyB4LCB5IH0pKVxuICAgICk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgY29uc3QgbmVpZ2hib3VycyA9ICh7IHgsIHkgfSkgPT4ge1xuICAgIGxldCByZXMgPSBbXTtcbiAgICBmbi5pbnRlcnZhbChNYXRoLm1heCgwLCB4IC0gMSksIE1hdGgubWluKHggKyAxLCB3aWR0aCAtIDEpKS5mb3JFYWNoKG54ID0+XG4gICAgICBmblxuICAgICAgICAuaW50ZXJ2YWwoTWF0aC5tYXgoMCwgeSAtIDEpLCBNYXRoLm1pbih5ICsgMSwgd2lkdGggLSAxKSlcbiAgICAgICAgLmZpbHRlcihueSA9PiAhKG54ID09PSB4ICYmIG55ID09PSB5KSlcbiAgICAgICAgLmZvckVhY2gobnkgPT4gcmVzLnB1c2goeyB4OiBueCwgeTogbnkgfSkpXG4gICAgKTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuICBjb25zdCBjbGVhcldhdGVyID0gKCkgPT4ge1xuICAgIGZpZWxkQ29vcmRzKCkuZm9yRWFjaChwID0+XG4gICAgICBmaWVsZEF0KHAueSwgcC54KSA9PT0gdHlwZS5XQVRFUlxuICAgICAgICA/IHNldEZpZWxkQXQocC55LCBwLngsIHR5cGUuVU5LTk9XTilcbiAgICAgICAgOiBudWxsXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgcmVmcmVzaFdhdGVyID0gKCkgPT5cbiAgICBmaWVsZENvb3JkcygpLmZvckVhY2gocCA9PiB7XG4gICAgICBpZiAoZmllbGRBdChwLnksIHAueCkgPT09IHR5cGUuVU5LTk9XTikge1xuICAgICAgICBsZXQgbmVpZ2hib3VyVmFsdWVzID0gbmVpZ2hib3VycyhwKS5tYXAocG9zID0+IGZpZWxkQXQocG9zLnksIHBvcy54KSk7XG4gICAgICAgIGlmIChuZWlnaGJvdXJWYWx1ZXMuZmluZCh2ID0+IHYgPj0gdHlwZS5TSElQX1VOS05PV04pKSB7XG4gICAgICAgICAgc2V0RmllbGRBdChwLnksIHAueCwgdHlwZS5XQVRFUik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgcmV0dXJuIHtcbiAgICBoaW50QXQ6IChyLCBjKSA9PiB7XG4gICAgICByZXR1cm4gciA9PT0gMCA/IGhpbnRzQ29sdW1uW2MgLSAxXSA6IGhpbnRzUm93W3IgLSAxXTtcbiAgICB9LFxuICAgIHNldEhpbnRBdDogKHIsIGMsIHYpID0+IHtcbiAgICAgIGlmIChyID09PSAwKSBoaW50c0NvbHVtbltjIC0gMV0gPSB2O1xuICAgICAgZWxzZSBoaW50c1Jvd1tyIC0gMV0gPSB2O1xuICAgICAgY2IgJiYgY2IoKTtcbiAgICB9LFxuICAgIGZpZWxkQXQsXG4gICAgc2V0RmllbGRBdCxcbiAgICBwbGFjZVNoaXA6IChyLCBjLCBsLCBkKSA9PiB7XG4gICAgICBsZXQgc2hpcENvb3JkcyA9IGZuXG4gICAgICAgIC5yYW5nZSgwLCBsKVxuICAgICAgICAubWFwKHNlZ21lbnQgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBjICsgKGQgPT09IGRpcmVjdGlvbi5IT1JJWk9OVEFMID8gc2VnbWVudCA6IDApLFxuICAgICAgICAgICAgeTogciArIChkID09PSBkaXJlY3Rpb24uVkVSVElDQUwgPyBzZWdtZW50IDogMClcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgICAuZmlsdGVyKHAgPT4gcC54ID49IDAgJiYgcC54IDwgd2lkdGggJiYgcC55ID49IDAgJiYgcC55IDwgd2lkdGgpO1xuXG4gICAgICBpZiAoc2hpcENvb3Jkcy5sZW5ndGggIT09IGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgaWYgKFxuICAgICAgICAhc2hpcENvb3Jkcy5tYXAocCA9PiBmaWVsZEF0KHAueSwgcC54KSkuZXZlcnkodiA9PiB2ID09PSB0eXBlLlVOS05PV04pXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGQpIHtcbiAgICAgICAgY2FzZSBkaXJlY3Rpb24uVkVSVElDQUw6XG4gICAgICAgICAgc2V0RmllbGRBdChyLCBjLCB0eXBlLlNISVBfTk9SVEhfRU5EKTtcbiAgICAgICAgICBmbi5yYW5nZSgxLCBsIC0gMSkuZm9yRWFjaChpID0+XG4gICAgICAgICAgICBzZXRGaWVsZEF0KHIgKyBpLCBjLCB0eXBlLlNISVBfTUlERExFKVxuICAgICAgICAgICk7XG4gICAgICAgICAgc2V0RmllbGRBdChyICsgbCAtIDEsIGMsIHR5cGUuU0hJUF9TT1VUSF9FTkQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGRpcmVjdGlvbi5IT1JJWk9OVEFMOlxuICAgICAgICAgIHNldEZpZWxkQXQociwgYywgdHlwZS5TSElQX1dFU1RfRU5EKTtcbiAgICAgICAgICBmbi5yYW5nZSgxLCBsIC0gMSkuZm9yRWFjaChpID0+XG4gICAgICAgICAgICBzZXRGaWVsZEF0KHIsIGMgKyBpLCB0eXBlLlNISVBfTUlERExFKVxuICAgICAgICAgICk7XG4gICAgICAgICAgc2V0RmllbGRBdChyLCBjICsgbCAtIDEsIHR5cGUuU0hJUF9FQVNUX0VORCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjbGVhcldhdGVyKCk7XG4gICAgICByZWZyZXNoV2F0ZXIoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgc2V0U2hpcDogKGlkeCwgc2l6ZSkgPT4ge1xuICAgICAgc2hpcHNbaWR4XSA9IE1hdGgubWluKHdpZHRoLCBzaXplKTtcbiAgICAgIGNiICYmIGNiKCk7XG4gICAgfSxcbiAgICByZW1vdmVTaGlwOiBpZHggPT4ge1xuICAgICAgc2hpcHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICBjYiAmJiBjYigpO1xuICAgIH0sXG4gICAgYWRkU2hpcDogKCkgPT4ge1xuICAgICAgc2hpcHMucHVzaCgyKTtcbiAgICAgIGNiICYmIGNiKCk7XG4gICAgfSxcbiAgICBpc1dvbjogKCkgPT4ge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgc2hpcHM6ICgpID0+IHNoaXBzLFxuICAgIHdpZHRoOiAoKSA9PiB3aWR0aCxcbiAgICBzZXRDaGFuZ2VDYWxsYmFjazogZiA9PiAoY2IgPSBmKSxcbiAgICBkYXRhOiAoKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoaW50c1JvdyxcbiAgICAgICAgaGludHNDb2x1bW4sXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBmaWVsZCxcbiAgICAgICAgc2hpcHNcbiAgICAgIH07XG4gICAgfSxcbiAgICBmcm9tRGF0YTogZCA9PiB7XG4gICAgICBoaW50c1JvdyA9IGQuaGludHNSb3c7XG4gICAgICBoaW50c0NvbHVtbiA9IGQuaGludHNDb2x1bW47XG4gICAgICB3aWR0aCA9IGQud2lkdGg7XG4gICAgICBmaWVsZCA9IGQuZmllbGQ7XG4gICAgICBzaGlwcyA9IGQuc2hpcHM7XG4gICAgfVxuICB9O1xufTtcblxubGV0IGcgPSBnYW1lTW9kZWwoZ2FtZVdpZHRoKTtcblxuZy5mcm9tRGF0YShnYW1lc1tPYmplY3Qua2V5cyhnYW1lcylbMV1dKTtcblxubGV0IGhpc3RvcnkgPSBzdGFjayhnLmRhdGEoKSk7XG5nLnNldENoYW5nZUNhbGxiYWNrKCgpID0+IGhpc3RvcnkucHVzaChnLmRhdGEoKSkpO1xuXG5sZXQgc2hpcHNUb1BsYWNlID0gZy5zaGlwcygpLm1hcChlID0+IGUpO1xuXG5jb25zdCB2YXJ5UHJvcGVydHlBcnJheXMgPSBhcnJheXMgPT5cbiAgT2JqZWN0LmtleXMoYXJyYXlzKS5yZWR1Y2UoXG4gICAgKGFjYywga2V5KSA9PlxuICAgICAgYXJyYXlzW2tleV0uZmxhdE1hcCAmJiBhcnJheXNba2V5XS5sZW5ndGggPiAwXG4gICAgICAgID8gYXJyYXlzW2tleV0uZmxhdE1hcCh2ID0+XG4gICAgICAgICAgICBhY2MubWFwKG9iaiA9PiBPYmplY3QuYXNzaWduKHsgW2tleV06IHYgfSwgb2JqKSlcbiAgICAgICAgICApXG4gICAgICAgIDogYWNjLm1hcChvYmogPT4gT2JqZWN0LmFzc2lnbih7IFtrZXldOiBhcnJheXNba2V5XSB9LCBvYmopKSxcbiAgICBbe31dXG4gICk7XG5cbmNvbnN0IHNvbHZlID0gKCkgPT4ge1xuICBsZXQgc29sdXRpb24gPSBbXTtcblxuICBjb25zdCBwb3NzaWJsZVNvbHV0aW9uc0Zvck9uZVNoaXAgPSB2YXJ5UHJvcGVydHlBcnJheXMoe1xuICAgIHg6IGZuLnJhbmdlKDAsIDEyKSxcbiAgICB5OiBmbi5yYW5nZSgwLCAxMiksXG4gICAgZGlyZWN0aW9uOiBbZGlyZWN0aW9uLlZFUlRJQ0FMLCBkaXJlY3Rpb24uSE9SSVpPTlRBTF1cbiAgfSk7XG5cbiAgY29uc3QgZXh0ZW5kU29sdXRpb24gPSAoc29sdXRpb24sIHNoaXBzKSA9PiB7XG4gICAgaWYgKHNoaXBzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHNvbHV0aW9uO1xuICB9O1xuXG4gIGV4dGVuZFNvbHV0aW9uKHNvbHV0aW9uLCBzaGlwc1RvUGxhY2UpO1xuXG4gIHNvbHV0aW9uLmZvckVhY2goc2hpcCA9PiB7XG4gICAgZy5wbGFjZVNoaXAoc2hpcC55LCBzaGlwLngsIHNoaXAubGVuZ3RoLCBzaGlwLmRpcmVjdGlvbik7XG4gIH0pO1xufTtcblxuaWYgKGZhbHNlKVxuICBzaGlwc1RvUGxhY2UuZm9yRWFjaChzaGlwID0+IHtcbiAgICBsZXQgcG9zc2libGVQb3NpdGlvbnMgPSBbXTtcbiAgICBmbi5yYW5nZSgwLCBnYW1lV2lkdGgpLm1hcCh4ID0+XG4gICAgICBmbi5yYW5nZSgwLCBnYW1lV2lkdGgpLm1hcCh5ID0+XG4gICAgICAgIFtkaXJlY3Rpb24uVkVSVElDQUwsIGRpcmVjdGlvbi5IT1JJWk9OVEFMXS5tYXAoZGlyZWN0aW9uID0+IHtcbiAgICAgICAgICBwb3NzaWJsZVBvc2l0aW9ucy5wdXNoKHsgeCwgeSwgZGlyZWN0aW9uIH0pO1xuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gICAgbGV0IGlkeCA9IDA7XG4gICAgd2hpbGUgKFxuICAgICAgIWcucGxhY2VTaGlwKFxuICAgICAgICBwb3NzaWJsZVBvc2l0aW9uc1tpZHhdLnksXG4gICAgICAgIHBvc3NpYmxlUG9zaXRpb25zW2lkeF0ueCxcbiAgICAgICAgc2hpcCxcbiAgICAgICAgcG9zc2libGVQb3NpdGlvbnNbaWR4XS5kaXJlY3Rpb25cbiAgICAgIClcbiAgICApXG4gICAgICBpZHgrKztcbiAgICBzb2x1dGlvbi5wdXNoKHBvc3NpYmxlUG9zaXRpb25zW2lkeF0pO1xuICB9KTtcblxuY2xhc3MgR2FtZUZpZWxkIHtcbiAgdmlldyh2bm9kZSkge1xuICAgIGxldCB3ID0gZy53aWR0aCgpICsgMTtcbiAgICByZXR1cm4gZGl2LmdhbWVmaWVsZChbXG4gICAgICBmblxuICAgICAgICAucmFuZ2UoMCwgdyAqIHcpXG4gICAgICAgIC5tYXAobCA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGwgJSB3LFxuICAgICAgICAgICAgeTogTWF0aC5mbG9vcihsIC8gdylcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgICAubWFwKGwgPT5cbiAgICAgICAgICBsLnggIT09IDAgfHwgbC55ICE9PSAwXG4gICAgICAgICAgICA/IGwueCA9PT0gMCB8fCBsLnkgPT09IDBcbiAgICAgICAgICAgICAgPyBpbnB1dC5ib3guaW5wdXQoe1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IGcuaGludEF0KGwueSwgbC54KSxcbiAgICAgICAgICAgICAgICAgIG9uaW5wdXQ6IG0ud2l0aEF0dHIoXCJ2YWx1ZVwiLCB2ID0+XG4gICAgICAgICAgICAgICAgICAgIGcuc2V0SGludEF0KGwueSwgbC54LCBOdW1iZXIodikpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgOiBnLmZpZWxkQXQobC55IC0gMSwgbC54IC0gMSkgPT09IHR5cGUuVU5LTk9XTlxuICAgICAgICAgICAgICA/IGRpdi5ib3guZW1wdHkoe1xuICAgICAgICAgICAgICAgICAgb25jbGljazogKCkgPT4gZy5zZXRGaWVsZEF0KGwueSAtIDEsIGwueCAtIDEsIHR5cGUuV0FURVIpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgOiBnLmZpZWxkQXQobC55IC0gMSwgbC54IC0gMSkgPT09IHR5cGUuV0FURVJcbiAgICAgICAgICAgICAgPyBkaXYuYm94LndhdGVyKHtcbiAgICAgICAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+XG4gICAgICAgICAgICAgICAgICAgIGcuc2V0RmllbGRBdChsLnkgLSAxLCBsLnggLSAxLCB0eXBlLlNISVBfVU5LTk9XTilcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICA6IGRpdi5ib3hbXCJzaGlwLVwiICsgZy5maWVsZEF0KGwueSAtIDEsIGwueCAtIDEpXShcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb25jbGljazogKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgICBnLnNldEZpZWxkQXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBsLnkgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgbC54IC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChnLmZpZWxkQXQobC55IC0gMSwgbC54IC0gMSkgKyAxKSAlIDhcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJcIiArIGwueCArIFwiLFwiICsgbC55XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBoaXN0b3J5LmRpcnR5KClcbiAgICAgICAgICAgID8gYnV0dG9uLmJveC5lbXB0eShcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBvbmNsaWNrOiAoKSA9PiBnLmZyb21EYXRhKGhpc3RvcnkucG9wKCkpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIuKshe+4j1wiXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogZGl2LmJveC5lbXB0eSgpXG4gICAgICAgIClcbiAgICBdKTtcbiAgfVxufVxuXG5jbGFzcyBTaGlwcyB7XG4gIHZpZXcodm5vZGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgZGl2LnNoaXBzKFtcbiAgICAgICAgZy5zaGlwcygpLm1hcCgoc2hpcFNpemUsIHNoaXBJZHgpID0+XG4gICAgICAgICAgZGl2LnNoaXAoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGtleTogc2hpcElkeFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgYnV0dG9uLnNoaXBjZWxsLnNoaXBjZWxsZmlyc3QoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgb25jbGljazogKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgc2hpcFNpemUgLSAxID49IDJcbiAgICAgICAgICAgICAgICAgICAgICA/IGcuc2V0U2hpcChzaGlwSWR4LCBzaGlwU2l6ZSAtIDEpXG4gICAgICAgICAgICAgICAgICAgICAgOiBnLnJlbW92ZVNoaXAoc2hpcElkeClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiLVwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGZuLnJhbmdlKDAsIHNoaXBTaXplIC0gMikubWFwKGkgPT5cbiAgICAgICAgICAgICAgICBkaXYuc2hpcGNlbGwoe1xuICAgICAgICAgICAgICAgICAga2V5OiBpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgYnV0dG9uLnNoaXBjZWxsLnNoaXBjZWxsbGFzdChcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBvbmNsaWNrOiAoKSA9PiBnLnNldFNoaXAoc2hpcElkeCwgc2hpcFNpemUgKyAxKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCIrXCJcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgYnV0dG9uLmJveC5lbXB0eShcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvbmNsaWNrOiAoKSA9PiBnLmFkZFNoaXAoKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCIrXCJcbiAgICAgICAgKVxuICAgICAgXSlcbiAgICBdO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoaXBzVmlldyB7XG4gIHZpZXcodm5vZGUpIHtcbiAgICByZXR1cm4gZGl2LmNvbnRhaW5lcihbXG4gICAgICBtKFxuICAgICAgICBcImgxXCIsXG4gICAgICAgIFwiU2hpcHMgXCIgKyAoZy5pc1dvbigpID8gXCJXb25cIiA6IFwiTm90IHdvblwiKSxcbiAgICAgICAgYnV0dG9uLmJ0bi5idG5QcmltYXJ5KFxuICAgICAgICAgIHsgb25jbGljazogKCkgPT4gZy5mcm9tRGF0YShoaXN0b3J5LmNsZWFyKCkpIH0sXG4gICAgICAgICAgXCJDbGVhclwiXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBkaXYubWFpbmdyaWQoW20oR2FtZUZpZWxkKSwgbShTaGlwcyldKSxcbiAgICAgIHByZShcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHJvd1N1bTogZy5kYXRhKCkuaGludHNSb3cucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCksXG4gICAgICAgICAgY29sU3VtOiBnLmRhdGEoKS5oaW50c0NvbHVtbi5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKVxuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIHByZShKU09OLnN0cmluZ2lmeShnLmRhdGEoKSwgbnVsbCwgMikpXG4gICAgXSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvc2hpcHMuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFjQTtBQWxCQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBY0E7QUFsQkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWNBO0FBbEJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFjQTtBQWxCQTtBQTdEQTtBQUNBO0FBZ0dBO0FBYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJGQTtBQXVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFEQTtBQUdBO0FBQUE7QUFMQTtBQUZBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFIQTtBQURBO0FBT0E7QUFDQTtBQVFBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBUUE7QUFBQTtBQUFBO0FBREE7QUFLQTtBQUFBO0FBQUE7QUFEQTtBQU1BO0FBQUE7QUFBQTtBQURBO0FBYUE7QUFBQTtBQUFBO0FBREE7QUEvQkE7QUF1Q0E7Ozs7OztBQUdBOzs7Ozs7O0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFEQTtBQU1BO0FBQUE7QUFBQTtBQURBO0FBUUE7QUFFQTtBQURBO0FBREE7QUFPQTtBQUFBO0FBQUE7QUFEQTtBQXJCQTtBQStCQTtBQUFBO0FBQUE7QUFEQTtBQU9BOzs7Ozs7QUFHQTs7Ozs7OztBQUNBO0FBQ0E7QUFLQTtBQUFBO0FBT0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFPQTs7Ozs7O0FBcEJBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n");

/***/ }),
/* 24 */
/*!************************************************!*\
  !*** ./node_modules/tagl-mithril/lib/index.js ***!
  \************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _tagl = __webpack_require__(/*! tagl */ 25);\n\nvar _tagl2 = _interopRequireDefault(_tagl);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nvar camelToHyphen = function camelToHyphen(s) {\n  return s.replace(/([A-Z])/g, function (g) {\n    return \"-\" + g[0].toLowerCase();\n  });\n};\n\nvar tagl_hyperscript = function tagl_hyperscript(m) {\n  return (0, _tagl2.default)(function (tagName, classes) {\n    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    var cls = classes.map(camelToHyphen).join(\".\");\n    var fullTagName = cls.length ? [tagName, cls].join(\".\").replace(\".$\", \"#\") : tagName;\n    return m.apply(undefined, [fullTagName].concat(args));\n  });\n};\n\nmodule.exports = tagl_hyperscript;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3RhZ2wtbWl0aHJpbC9saWIvaW5kZXguanM/ZDY2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF90YWdsID0gcmVxdWlyZShcInRhZ2xcIik7XG5cbnZhciBfdGFnbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90YWdsKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNhbWVsVG9IeXBoZW4gPSBmdW5jdGlvbiBjYW1lbFRvSHlwaGVuKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAoZykge1xuICAgIHJldHVybiBcIi1cIiArIGdbMF0udG9Mb3dlckNhc2UoKTtcbiAgfSk7XG59O1xuXG52YXIgdGFnbF9oeXBlcnNjcmlwdCA9IGZ1bmN0aW9uIHRhZ2xfaHlwZXJzY3JpcHQobSkge1xuICByZXR1cm4gKDAsIF90YWdsMi5kZWZhdWx0KShmdW5jdGlvbiAodGFnTmFtZSwgY2xhc3Nlcykge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGNscyA9IGNsYXNzZXMubWFwKGNhbWVsVG9IeXBoZW4pLmpvaW4oXCIuXCIpO1xuICAgIHZhciBmdWxsVGFnTmFtZSA9IGNscy5sZW5ndGggPyBbdGFnTmFtZSwgY2xzXS5qb2luKFwiLlwiKS5yZXBsYWNlKFwiLiRcIiwgXCIjXCIpIDogdGFnTmFtZTtcbiAgICByZXR1cm4gbS5hcHBseSh1bmRlZmluZWQsIFtmdWxsVGFnTmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRhZ2xfaHlwZXJzY3JpcHQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy90YWdsLW1pdGhyaWwvbGliL2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///24\n");

/***/ }),
/* 25 */
/*!************************************!*\
  !*** ./node_modules/tagl/index.js ***!
  \************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction noop() {}\n\nfunction tagl(h) {\n  function createProxy(tagName) {\n    return new Proxy(noop, {\n      apply: function apply(_, __, args) {\n        return h.apply(undefined, [tagName, []].concat(_toConsumableArray(args)));\n      },\n      get: function get(_, className) {\n        var classNames = [className];\n        var proxy = new Proxy(noop, {\n          get: function get(_, className) {\n            classNames.push(className);\n            return proxy;\n          },\n          apply: function apply(_, ___, args) {\n            return h.apply(undefined, [tagName, classNames].concat(_toConsumableArray(args)));\n          }\n        });\n        return proxy;\n      }\n    });\n  }\n\n  return new Proxy(function (component) {\n    return createProxy(component);\n  }, {\n    get: function get(components, tagName) {\n      return createProxy(components[tagName] || tagName);\n    }\n  });\n}\n\nexports.default = tagl;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3RhZ2wvaW5kZXguanM/YjI3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gdGFnbChoKSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZVByb3h5KHRhZ05hbWUpIHtcbiAgICByZXR1cm4gbmV3IFByb3h5KG5vb3AsIHtcbiAgICAgIGFwcGx5OiAoXywgX18sIGFyZ3MpID0+IGgodGFnTmFtZSwgW10sIC4uLmFyZ3MpLFxuICAgICAgZ2V0OiAoXywgY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBbY2xhc3NOYW1lXVxuICAgICAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShub29wLCB7XG4gICAgICAgICAgZ2V0KF8sIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKGNsYXNzTmFtZSlcbiAgICAgICAgICAgIHJldHVybiBwcm94eVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXBwbHkoXywgX19fLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gaCh0YWdOYW1lLCBjbGFzc05hbWVzLCAuLi5hcmdzKVxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBwcm94eVxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm94eShjb21wb25lbnQgPT4gY3JlYXRlUHJveHkoY29tcG9uZW50KSwge1xuICAgIGdldDogKGNvbXBvbmVudHMsIHRhZ05hbWUpID0+IGNyZWF0ZVByb3h5KGNvbXBvbmVudHNbdGFnTmFtZV0gfHwgdGFnTmFtZSksXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IHRhZ2xcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvdGFnbC9pbmRleC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFkQTtBQWdCQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFHQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///25\n");

/***/ }),
/* 26 */
/*!**********************!*\
  !*** ./src/stack.js ***!
  \**********************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fastJsonPatch = __webpack_require__(/*! fast-json-patch */ 27);\n\nvar _fastJsonPatch2 = _interopRequireDefault(_fastJsonPatch);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar stack = function stack(obj) {\n  var clone = function clone(o) {\n    return JSON.parse(JSON.stringify(o));\n  };\n  var state = clone(obj);\n  var original = clone(obj);\n  var history = [];\n  var dirty = function dirty() {\n    return history.length > 0;\n  };\n  var pop = function pop() {\n    if (dirty()) {\n      state = _fastJsonPatch2.default.applyPatch(state, history.pop()).newDocument;\n    }\n    return clone(state);\n  };\n  return {\n    push: function push(newObj) {\n      history.push(_fastJsonPatch2.default.compare(newObj, state));\n      state = clone(newObj);\n    },\n    pop: pop,\n    clear: function clear() {\n      history = [];\n      return clone(original);\n    },\n    peek: function peek() {\n      return dirty() ? clone(history[history.length - 1]) : [];\n    },\n    dirty: dirty\n  };\n};\n\nvar testStack = function testStack() {\n  var test = {\n    a: 0\n  };\n  var history = stack(test);\n  console.log(\"test_0 dirty false\", history.dirty());\n  test.b = 1;\n  history.push(test);\n  console.log(\"test_1 dirty true\", history.dirty());\n  console.log(\"test_2 {op:remove, path:/b}\", JSON.stringify(history.peek()));\n  test.b = 2;\n  history.push(test);\n  console.log(\"test_3 {op:replace, path:/b, value:1}\", JSON.stringify(history.peek()));\n  console.log(\"test_4 {a:0,b:1}\", JSON.stringify(history.pop()));\n  console.log(\"test_4 {a:0}\", JSON.stringify(history.pop()));\n  console.log(\"test_5 dirty false\", history.dirty());\n};\n\nexports.default = stack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3N0YWNrLmpzP2MxOGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGpwIGZyb20gXCJmYXN0LWpzb24tcGF0Y2hcIjtcblxuY29uc3Qgc3RhY2sgPSBvYmogPT4ge1xuICBsZXQgY2xvbmUgPSBvID0+IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobykpO1xuICBsZXQgc3RhdGUgPSBjbG9uZShvYmopO1xuICBsZXQgb3JpZ2luYWwgPSBjbG9uZShvYmopO1xuICBsZXQgaGlzdG9yeSA9IFtdO1xuICBjb25zdCBkaXJ0eSA9ICgpID0+IGhpc3RvcnkubGVuZ3RoID4gMDtcbiAgY29uc3QgcG9wID0gKCkgPT4ge1xuICAgIGlmIChkaXJ0eSgpKSB7XG4gICAgICBzdGF0ZSA9IGpwLmFwcGx5UGF0Y2goc3RhdGUsIGhpc3RvcnkucG9wKCkpLm5ld0RvY3VtZW50O1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmUoc3RhdGUpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHB1c2g6IG5ld09iaiA9PiB7XG4gICAgICBoaXN0b3J5LnB1c2goanAuY29tcGFyZShuZXdPYmosIHN0YXRlKSk7XG4gICAgICBzdGF0ZSA9IGNsb25lKG5ld09iaik7XG4gICAgfSxcbiAgICBwb3AsXG4gICAgY2xlYXI6ICgpID0+IHtcbiAgICAgIGhpc3RvcnkgPSBbXTtcbiAgICAgIHJldHVybiBjbG9uZShvcmlnaW5hbCk7XG4gICAgfSxcbiAgICBwZWVrOiAoKSA9PiAoZGlydHkoKSA/IGNsb25lKGhpc3RvcnlbaGlzdG9yeS5sZW5ndGggLSAxXSkgOiBbXSksXG4gICAgZGlydHlcbiAgfTtcbn07XG5cbmNvbnN0IHRlc3RTdGFjayA9ICgpID0+IHtcbiAgbGV0IHRlc3QgPSB7XG4gICAgYTogMFxuICB9O1xuICBsZXQgaGlzdG9yeSA9IHN0YWNrKHRlc3QpO1xuICBjb25zb2xlLmxvZyhcInRlc3RfMCBkaXJ0eSBmYWxzZVwiLCBoaXN0b3J5LmRpcnR5KCkpO1xuICB0ZXN0LmIgPSAxO1xuICBoaXN0b3J5LnB1c2godGVzdCk7XG4gIGNvbnNvbGUubG9nKFwidGVzdF8xIGRpcnR5IHRydWVcIiwgaGlzdG9yeS5kaXJ0eSgpKTtcbiAgY29uc29sZS5sb2coXCJ0ZXN0XzIge29wOnJlbW92ZSwgcGF0aDovYn1cIiwgSlNPTi5zdHJpbmdpZnkoaGlzdG9yeS5wZWVrKCkpKTtcbiAgdGVzdC5iID0gMjtcbiAgaGlzdG9yeS5wdXNoKHRlc3QpO1xuICBjb25zb2xlLmxvZyhcbiAgICBcInRlc3RfMyB7b3A6cmVwbGFjZSwgcGF0aDovYiwgdmFsdWU6MX1cIixcbiAgICBKU09OLnN0cmluZ2lmeShoaXN0b3J5LnBlZWsoKSlcbiAgKTtcbiAgY29uc29sZS5sb2coXCJ0ZXN0XzQge2E6MCxiOjF9XCIsIEpTT04uc3RyaW5naWZ5KGhpc3RvcnkucG9wKCkpKTtcbiAgY29uc29sZS5sb2coXCJ0ZXN0XzQge2E6MH1cIiwgSlNPTi5zdHJpbmdpZnkoaGlzdG9yeS5wb3AoKSkpO1xuICBjb25zb2xlLmxvZyhcInRlc3RfNSBkaXJ0eSBmYWxzZVwiLCBoaXN0b3J5LmRpcnR5KCkpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc3RhY2s7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3N0YWNrLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQVhBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///26\n");

/***/ }),
/* 27 */
/*!****************************************************!*\
  !*** ./node_modules/fast-json-patch/lib/duplex.js ***!
  \****************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar equalsOptions = { strict: true };\nvar _equals = __webpack_require__(/*! deep-equal */ 5);\nvar areEquals = function areEquals(a, b) {\n    return _equals(a, b, equalsOptions);\n};\nvar helpers_1 = __webpack_require__(/*! ./helpers */ 4);\nvar core_1 = __webpack_require__(/*! ./core */ 6);\n/* export all core functions */\nvar core_2 = __webpack_require__(/*! ./core */ 6);\nexports.applyOperation = core_2.applyOperation;\nexports.applyPatch = core_2.applyPatch;\nexports.applyReducer = core_2.applyReducer;\nexports.getValueByPointer = core_2.getValueByPointer;\nexports.validate = core_2.validate;\nexports.validator = core_2.validator;\n/* export some helpers */\nvar helpers_2 = __webpack_require__(/*! ./helpers */ 4);\nexports.JsonPatchError = helpers_2.PatchError;\nexports.deepClone = helpers_2._deepClone;\nexports.escapePathComponent = helpers_2.escapePathComponent;\nexports.unescapePathComponent = helpers_2.unescapePathComponent;\nvar beforeDict = [];\nvar Mirror = function () {\n    function Mirror(obj) {\n        this.observers = [];\n        this.obj = obj;\n    }\n    return Mirror;\n}();\nvar ObserverInfo = function () {\n    function ObserverInfo(callback, observer) {\n        this.callback = callback;\n        this.observer = observer;\n    }\n    return ObserverInfo;\n}();\nfunction getMirror(obj) {\n    for (var i = 0, length = beforeDict.length; i < length; i++) {\n        if (beforeDict[i].obj === obj) {\n            return beforeDict[i];\n        }\n    }\n}\nfunction getObserverFromMirror(mirror, callback) {\n    for (var j = 0, length = mirror.observers.length; j < length; j++) {\n        if (mirror.observers[j].callback === callback) {\n            return mirror.observers[j].observer;\n        }\n    }\n}\nfunction removeObserverFromMirror(mirror, observer) {\n    for (var j = 0, length = mirror.observers.length; j < length; j++) {\n        if (mirror.observers[j].observer === observer) {\n            mirror.observers.splice(j, 1);\n            return;\n        }\n    }\n}\n/**\r\n * Detach an observer from an object\r\n */\nfunction unobserve(root, observer) {\n    observer.unobserve();\n}\nexports.unobserve = unobserve;\n/**\r\n * Observes changes made to an object, which can then be retrieved using generate\r\n */\nfunction observe(obj, callback) {\n    var patches = [];\n    var root = obj;\n    var observer;\n    var mirror = getMirror(obj);\n    if (!mirror) {\n        mirror = new Mirror(obj);\n        beforeDict.push(mirror);\n    } else {\n        observer = getObserverFromMirror(mirror, callback);\n    }\n    if (observer) {\n        return observer;\n    }\n    observer = {};\n    mirror.value = helpers_1._deepClone(obj);\n    if (callback) {\n        observer.callback = callback;\n        observer.next = null;\n        var dirtyCheck = function dirtyCheck() {\n            generate(observer);\n        };\n        var fastCheck = function fastCheck() {\n            clearTimeout(observer.next);\n            observer.next = setTimeout(dirtyCheck);\n        };\n        if (typeof window !== 'undefined') {\n            if (window.addEventListener) {\n                window.addEventListener('mouseup', fastCheck);\n                window.addEventListener('keyup', fastCheck);\n                window.addEventListener('mousedown', fastCheck);\n                window.addEventListener('keydown', fastCheck);\n                window.addEventListener('change', fastCheck);\n            } else {\n                document.documentElement.attachEvent('onmouseup', fastCheck);\n                document.documentElement.attachEvent('onkeyup', fastCheck);\n                document.documentElement.attachEvent('onmousedown', fastCheck);\n                document.documentElement.attachEvent('onkeydown', fastCheck);\n                document.documentElement.attachEvent('onchange', fastCheck);\n            }\n        }\n    }\n    observer.patches = patches;\n    observer.object = obj;\n    observer.unobserve = function () {\n        generate(observer);\n        clearTimeout(observer.next);\n        removeObserverFromMirror(mirror, observer);\n        if (typeof window !== 'undefined') {\n            if (window.removeEventListener) {\n                window.removeEventListener('mouseup', fastCheck);\n                window.removeEventListener('keyup', fastCheck);\n                window.removeEventListener('mousedown', fastCheck);\n                window.removeEventListener('keydown', fastCheck);\n            } else {\n                document.documentElement.detachEvent('onmouseup', fastCheck);\n                document.documentElement.detachEvent('onkeyup', fastCheck);\n                document.documentElement.detachEvent('onmousedown', fastCheck);\n                document.documentElement.detachEvent('onkeydown', fastCheck);\n            }\n        }\n    };\n    mirror.observers.push(new ObserverInfo(callback, observer));\n    return observer;\n}\nexports.observe = observe;\n/**\r\n * Generate an array of patches from an observer\r\n */\nfunction generate(observer) {\n    var mirror;\n    for (var i = 0, length = beforeDict.length; i < length; i++) {\n        if (beforeDict[i].obj === observer.object) {\n            mirror = beforeDict[i];\n            break;\n        }\n    }\n    _generate(mirror.value, observer.object, observer.patches, \"\");\n    if (observer.patches.length) {\n        core_1.applyPatch(mirror.value, observer.patches);\n    }\n    var temp = observer.patches;\n    if (temp.length > 0) {\n        observer.patches = [];\n        if (observer.callback) {\n            observer.callback(temp);\n        }\n    }\n    return temp;\n}\nexports.generate = generate;\n// Dirty check if obj is different from mirror, generate patches and update mirror\nfunction _generate(mirror, obj, patches, path) {\n    if (obj === mirror) {\n        return;\n    }\n    if (typeof obj.toJSON === \"function\") {\n        obj = obj.toJSON();\n    }\n    var newKeys = helpers_1._objectKeys(obj);\n    var oldKeys = helpers_1._objectKeys(mirror);\n    var changed = false;\n    var deleted = false;\n    //if ever \"move\" operation is implemented here, make sure this test runs OK: \"should not generate the same patch twice (move)\"\n    for (var t = oldKeys.length - 1; t >= 0; t--) {\n        var key = oldKeys[t];\n        var oldVal = mirror[key];\n        if (helpers_1.hasOwnProperty(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {\n            var newVal = obj[key];\n            if ((typeof oldVal === 'undefined' ? 'undefined' : _typeof(oldVal)) == \"object\" && oldVal != null && (typeof newVal === 'undefined' ? 'undefined' : _typeof(newVal)) == \"object\" && newVal != null) {\n                _generate(oldVal, newVal, patches, path + \"/\" + helpers_1.escapePathComponent(key));\n            } else {\n                if (oldVal !== newVal) {\n                    changed = true;\n                    patches.push({ op: \"replace\", path: path + \"/\" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(newVal) });\n                }\n            }\n        } else {\n            patches.push({ op: \"remove\", path: path + \"/\" + helpers_1.escapePathComponent(key) });\n            deleted = true; // property has been deleted\n        }\n    }\n    if (!deleted && newKeys.length == oldKeys.length) {\n        return;\n    }\n    for (var t = 0; t < newKeys.length; t++) {\n        var key = newKeys[t];\n        if (!helpers_1.hasOwnProperty(mirror, key) && obj[key] !== undefined) {\n            patches.push({ op: \"add\", path: path + \"/\" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(obj[key]) });\n        }\n    }\n}\n/**\r\n * Create an array of patches from the differences in two objects\r\n */\nfunction compare(tree1, tree2) {\n    var patches = [];\n    _generate(tree1, tree2, patches, '');\n    return patches;\n}\nexports.compare = compare;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2Zhc3QtanNvbi1wYXRjaC9saWIvZHVwbGV4LmpzP2Q1MmUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGVxdWFsc09wdGlvbnMgPSB7IHN0cmljdDogdHJ1ZSB9O1xyXG52YXIgX2VxdWFscyA9IHJlcXVpcmUoJ2RlZXAtZXF1YWwnKTtcclxudmFyIGFyZUVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICByZXR1cm4gX2VxdWFscyhhLCBiLCBlcXVhbHNPcHRpb25zKTtcclxufTtcclxudmFyIGhlbHBlcnNfMSA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xyXG52YXIgY29yZV8xID0gcmVxdWlyZSgnLi9jb3JlJyk7XHJcbi8qIGV4cG9ydCBhbGwgY29yZSBmdW5jdGlvbnMgKi9cclxudmFyIGNvcmVfMiA9IHJlcXVpcmUoJy4vY29yZScpO1xyXG5leHBvcnRzLmFwcGx5T3BlcmF0aW9uID0gY29yZV8yLmFwcGx5T3BlcmF0aW9uO1xyXG5leHBvcnRzLmFwcGx5UGF0Y2ggPSBjb3JlXzIuYXBwbHlQYXRjaDtcclxuZXhwb3J0cy5hcHBseVJlZHVjZXIgPSBjb3JlXzIuYXBwbHlSZWR1Y2VyO1xyXG5leHBvcnRzLmdldFZhbHVlQnlQb2ludGVyID0gY29yZV8yLmdldFZhbHVlQnlQb2ludGVyO1xyXG5leHBvcnRzLnZhbGlkYXRlID0gY29yZV8yLnZhbGlkYXRlO1xyXG5leHBvcnRzLnZhbGlkYXRvciA9IGNvcmVfMi52YWxpZGF0b3I7XHJcbi8qIGV4cG9ydCBzb21lIGhlbHBlcnMgKi9cclxudmFyIGhlbHBlcnNfMiA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xyXG5leHBvcnRzLkpzb25QYXRjaEVycm9yID0gaGVscGVyc18yLlBhdGNoRXJyb3I7XHJcbmV4cG9ydHMuZGVlcENsb25lID0gaGVscGVyc18yLl9kZWVwQ2xvbmU7XHJcbmV4cG9ydHMuZXNjYXBlUGF0aENvbXBvbmVudCA9IGhlbHBlcnNfMi5lc2NhcGVQYXRoQ29tcG9uZW50O1xyXG5leHBvcnRzLnVuZXNjYXBlUGF0aENvbXBvbmVudCA9IGhlbHBlcnNfMi51bmVzY2FwZVBhdGhDb21wb25lbnQ7XHJcbnZhciBiZWZvcmVEaWN0ID0gW107XHJcbnZhciBNaXJyb3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWlycm9yKG9iaikge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWlycm9yO1xyXG59KCkpO1xyXG52YXIgT2JzZXJ2ZXJJbmZvID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE9ic2VydmVySW5mbyhjYWxsYmFjaywgb2JzZXJ2ZXIpIHtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE9ic2VydmVySW5mbztcclxufSgpKTtcclxuZnVuY3Rpb24gZ2V0TWlycm9yKG9iaikge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGJlZm9yZURpY3QubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoYmVmb3JlRGljdFtpXS5vYmogPT09IG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gYmVmb3JlRGljdFtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgY2FsbGJhY2spIHtcclxuICAgIGZvciAodmFyIGogPSAwLCBsZW5ndGggPSBtaXJyb3Iub2JzZXJ2ZXJzLmxlbmd0aDsgaiA8IGxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgaWYgKG1pcnJvci5vYnNlcnZlcnNbal0uY2FsbGJhY2sgPT09IGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtaXJyb3Iub2JzZXJ2ZXJzW2pdLm9ic2VydmVyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZW1vdmVPYnNlcnZlckZyb21NaXJyb3IobWlycm9yLCBvYnNlcnZlcikge1xyXG4gICAgZm9yICh2YXIgaiA9IDAsIGxlbmd0aCA9IG1pcnJvci5vYnNlcnZlcnMubGVuZ3RoOyBqIDwgbGVuZ3RoOyBqKyspIHtcclxuICAgICAgICBpZiAobWlycm9yLm9ic2VydmVyc1tqXS5vYnNlcnZlciA9PT0gb2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgbWlycm9yLm9ic2VydmVycy5zcGxpY2UoaiwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERldGFjaCBhbiBvYnNlcnZlciBmcm9tIGFuIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gdW5vYnNlcnZlKHJvb3QsIG9ic2VydmVyKSB7XHJcbiAgICBvYnNlcnZlci51bm9ic2VydmUoKTtcclxufVxyXG5leHBvcnRzLnVub2JzZXJ2ZSA9IHVub2JzZXJ2ZTtcclxuLyoqXHJcbiAqIE9ic2VydmVzIGNoYW5nZXMgbWFkZSB0byBhbiBvYmplY3QsIHdoaWNoIGNhbiB0aGVuIGJlIHJldHJpZXZlZCB1c2luZyBnZW5lcmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gb2JzZXJ2ZShvYmosIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgcGF0Y2hlcyA9IFtdO1xyXG4gICAgdmFyIHJvb3QgPSBvYmo7XHJcbiAgICB2YXIgb2JzZXJ2ZXI7XHJcbiAgICB2YXIgbWlycm9yID0gZ2V0TWlycm9yKG9iaik7XHJcbiAgICBpZiAoIW1pcnJvcikge1xyXG4gICAgICAgIG1pcnJvciA9IG5ldyBNaXJyb3Iob2JqKTtcclxuICAgICAgICBiZWZvcmVEaWN0LnB1c2gobWlycm9yKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG9ic2VydmVyID0gZ2V0T2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgaWYgKG9ic2VydmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xyXG4gICAgfVxyXG4gICAgb2JzZXJ2ZXIgPSB7fTtcclxuICAgIG1pcnJvci52YWx1ZSA9IGhlbHBlcnNfMS5fZGVlcENsb25lKG9iaik7XHJcbiAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICBvYnNlcnZlci5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIG9ic2VydmVyLm5leHQgPSBudWxsO1xyXG4gICAgICAgIHZhciBkaXJ0eUNoZWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBnZW5lcmF0ZShvYnNlcnZlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgZmFzdENoZWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQob2JzZXJ2ZXIubmV4dCk7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgPSBzZXRUaW1lb3V0KGRpcnR5Q2hlY2spO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBmYXN0Q2hlY2spO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmYXN0Q2hlY2spO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmYXN0Q2hlY2spO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ubW91c2V1cCcsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ua2V5dXAnLCBmYXN0Q2hlY2spO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dGFjaEV2ZW50KCdvbm1vdXNlZG93bicsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ua2V5ZG93bicsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uY2hhbmdlJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9ic2VydmVyLnBhdGNoZXMgPSBwYXRjaGVzO1xyXG4gICAgb2JzZXJ2ZXIub2JqZWN0ID0gb2JqO1xyXG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGdlbmVyYXRlKG9ic2VydmVyKTtcclxuICAgICAgICBjbGVhclRpbWVvdXQob2JzZXJ2ZXIubmV4dCk7XHJcbiAgICAgICAgcmVtb3ZlT2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgb2JzZXJ2ZXIpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZiAod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kZXRhY2hFdmVudCgnb25tb3VzZXVwJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kZXRhY2hFdmVudCgnb25rZXl1cCcsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGV0YWNoRXZlbnQoJ29ubW91c2Vkb3duJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kZXRhY2hFdmVudCgnb25rZXlkb3duJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBtaXJyb3Iub2JzZXJ2ZXJzLnB1c2gobmV3IE9ic2VydmVySW5mbyhjYWxsYmFjaywgb2JzZXJ2ZXIpKTtcclxuICAgIHJldHVybiBvYnNlcnZlcjtcclxufVxyXG5leHBvcnRzLm9ic2VydmUgPSBvYnNlcnZlO1xyXG4vKipcclxuICogR2VuZXJhdGUgYW4gYXJyYXkgb2YgcGF0Y2hlcyBmcm9tIGFuIG9ic2VydmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZShvYnNlcnZlcikge1xyXG4gICAgdmFyIG1pcnJvcjtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBiZWZvcmVEaWN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGJlZm9yZURpY3RbaV0ub2JqID09PSBvYnNlcnZlci5vYmplY3QpIHtcclxuICAgICAgICAgICAgbWlycm9yID0gYmVmb3JlRGljdFtpXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2dlbmVyYXRlKG1pcnJvci52YWx1ZSwgb2JzZXJ2ZXIub2JqZWN0LCBvYnNlcnZlci5wYXRjaGVzLCBcIlwiKTtcclxuICAgIGlmIChvYnNlcnZlci5wYXRjaGVzLmxlbmd0aCkge1xyXG4gICAgICAgIGNvcmVfMS5hcHBseVBhdGNoKG1pcnJvci52YWx1ZSwgb2JzZXJ2ZXIucGF0Y2hlcyk7XHJcbiAgICB9XHJcbiAgICB2YXIgdGVtcCA9IG9ic2VydmVyLnBhdGNoZXM7XHJcbiAgICBpZiAodGVtcC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgb2JzZXJ2ZXIucGF0Y2hlcyA9IFtdO1xyXG4gICAgICAgIGlmIChvYnNlcnZlci5jYWxsYmFjaykge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5jYWxsYmFjayh0ZW1wKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGVtcDtcclxufVxyXG5leHBvcnRzLmdlbmVyYXRlID0gZ2VuZXJhdGU7XHJcbi8vIERpcnR5IGNoZWNrIGlmIG9iaiBpcyBkaWZmZXJlbnQgZnJvbSBtaXJyb3IsIGdlbmVyYXRlIHBhdGNoZXMgYW5kIHVwZGF0ZSBtaXJyb3JcclxuZnVuY3Rpb24gX2dlbmVyYXRlKG1pcnJvciwgb2JqLCBwYXRjaGVzLCBwYXRoKSB7XHJcbiAgICBpZiAob2JqID09PSBtaXJyb3IpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIG9iai50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIG9iaiA9IG9iai50b0pTT04oKTtcclxuICAgIH1cclxuICAgIHZhciBuZXdLZXlzID0gaGVscGVyc18xLl9vYmplY3RLZXlzKG9iaik7XHJcbiAgICB2YXIgb2xkS2V5cyA9IGhlbHBlcnNfMS5fb2JqZWN0S2V5cyhtaXJyb3IpO1xyXG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcclxuICAgIHZhciBkZWxldGVkID0gZmFsc2U7XHJcbiAgICAvL2lmIGV2ZXIgXCJtb3ZlXCIgb3BlcmF0aW9uIGlzIGltcGxlbWVudGVkIGhlcmUsIG1ha2Ugc3VyZSB0aGlzIHRlc3QgcnVucyBPSzogXCJzaG91bGQgbm90IGdlbmVyYXRlIHRoZSBzYW1lIHBhdGNoIHR3aWNlIChtb3ZlKVwiXHJcbiAgICBmb3IgKHZhciB0ID0gb2xkS2V5cy5sZW5ndGggLSAxOyB0ID49IDA7IHQtLSkge1xyXG4gICAgICAgIHZhciBrZXkgPSBvbGRLZXlzW3RdO1xyXG4gICAgICAgIHZhciBvbGRWYWwgPSBtaXJyb3Jba2V5XTtcclxuICAgICAgICBpZiAoaGVscGVyc18xLmhhc093blByb3BlcnR5KG9iaiwga2V5KSAmJiAhKG9ialtrZXldID09PSB1bmRlZmluZWQgJiYgb2xkVmFsICE9PSB1bmRlZmluZWQgJiYgQXJyYXkuaXNBcnJheShvYmopID09PSBmYWxzZSkpIHtcclxuICAgICAgICAgICAgdmFyIG5ld1ZhbCA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9sZFZhbCA9PSBcIm9iamVjdFwiICYmIG9sZFZhbCAhPSBudWxsICYmIHR5cGVvZiBuZXdWYWwgPT0gXCJvYmplY3RcIiAmJiBuZXdWYWwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgX2dlbmVyYXRlKG9sZFZhbCwgbmV3VmFsLCBwYXRjaGVzLCBwYXRoICsgXCIvXCIgKyBoZWxwZXJzXzEuZXNjYXBlUGF0aENvbXBvbmVudChrZXkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChvbGRWYWwgIT09IG5ld1ZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7IG9wOiBcInJlcGxhY2VcIiwgcGF0aDogcGF0aCArIFwiL1wiICsgaGVscGVyc18xLmVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSwgdmFsdWU6IGhlbHBlcnNfMS5fZGVlcENsb25lKG5ld1ZhbCkgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7IG9wOiBcInJlbW92ZVwiLCBwYXRoOiBwYXRoICsgXCIvXCIgKyBoZWxwZXJzXzEuZXNjYXBlUGF0aENvbXBvbmVudChrZXkpIH0pO1xyXG4gICAgICAgICAgICBkZWxldGVkID0gdHJ1ZTsgLy8gcHJvcGVydHkgaGFzIGJlZW4gZGVsZXRlZFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghZGVsZXRlZCAmJiBuZXdLZXlzLmxlbmd0aCA9PSBvbGRLZXlzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbmV3S2V5cy5sZW5ndGg7IHQrKykge1xyXG4gICAgICAgIHZhciBrZXkgPSBuZXdLZXlzW3RdO1xyXG4gICAgICAgIGlmICghaGVscGVyc18xLmhhc093blByb3BlcnR5KG1pcnJvciwga2V5KSAmJiBvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7IG9wOiBcImFkZFwiLCBwYXRoOiBwYXRoICsgXCIvXCIgKyBoZWxwZXJzXzEuZXNjYXBlUGF0aENvbXBvbmVudChrZXkpLCB2YWx1ZTogaGVscGVyc18xLl9kZWVwQ2xvbmUob2JqW2tleV0pIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlIGFuIGFycmF5IG9mIHBhdGNoZXMgZnJvbSB0aGUgZGlmZmVyZW5jZXMgaW4gdHdvIG9iamVjdHNcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBhcmUodHJlZTEsIHRyZWUyKSB7XHJcbiAgICB2YXIgcGF0Y2hlcyA9IFtdO1xyXG4gICAgX2dlbmVyYXRlKHRyZWUxLCB0cmVlMiwgcGF0Y2hlcywgJycpO1xyXG4gICAgcmV0dXJuIHBhdGNoZXM7XHJcbn1cclxuZXhwb3J0cy5jb21wYXJlID0gY29tcGFyZTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9mYXN0LWpzb24tcGF0Y2gvbGliL2R1cGxleC5qcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///27\n");

/***/ }),
/* 28 */
/*!*********************************************!*\
  !*** ./node_modules/deep-equal/lib/keys.js ***!
  \*********************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports = module.exports = typeof Object.keys === 'function' ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim(obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2tleXMuanM/ZWY1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbidcbiAgPyBPYmplY3Qua2V5cyA6IHNoaW07XG5cbmV4cG9ydHMuc2hpbSA9IHNoaW07XG5mdW5jdGlvbiBzaGltIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYi9rZXlzLmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///28\n");

/***/ }),
/* 29 */
/*!*****************************************************!*\
  !*** ./node_modules/deep-equal/lib/is_arguments.js ***!
  \*****************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar supportsArgumentsClass = function () {\n  return Object.prototype.toString.call(arguments);\n}() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nexports.unsupported = unsupported;\nfunction unsupported(object) {\n  return object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) == 'object' && typeof object.length == 'number' && Object.prototype.hasOwnProperty.call(object, 'callee') && !Object.prototype.propertyIsEnumerable.call(object, 'callee') || false;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qcz84Y2NkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID0gKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKVxufSkoKSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA/IHN1cHBvcnRlZCA6IHVuc3VwcG9ydGVkO1xuXG5leHBvcnRzLnN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbmZ1bmN0aW9uIHN1cHBvcnRlZChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxuZXhwb3J0cy51bnN1cHBvcnRlZCA9IHVuc3VwcG9ydGVkO1xuZnVuY3Rpb24gdW5zdXBwb3J0ZWQob2JqZWN0KXtcbiAgcmV0dXJuIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdjYWxsZWUnKSAmJlxuICAgICFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCAnY2FsbGVlJykgfHxcbiAgICBmYWxzZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///29\n");

/***/ }),
/* 30 */
/*!**********************!*\
  !*** ./src/waves.js ***!
  \**********************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _fn = __webpack_require__(/*! ./fn */ 2);\n\nvar _fn2 = _interopRequireDefault(_fn);\n\nvar _tagl = __webpack_require__(/*! ./tagl */ 7);\n\nvar _tagl2 = _interopRequireDefault(_tagl);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar camelToHyphen = function camelToHyphen(s) {\n    return s.replace(/([A-Z])/g, function (g) {\n        return '-' + g[0].toLowerCase();\n    });\n};\n\nvar tagl_hyperscript = (0, _tagl2.default)(function (tagName, classes) {\n    var cls = classes.map(camelToHyphen).join('.');\n\n    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n    }\n\n    return _mithril2.default.apply(undefined, [[tagName, cls].join('.').replace('.$', '#')].concat(args));\n});\n\nvar div = tagl_hyperscript.div,\n    svg = tagl_hyperscript.svg,\n    input = tagl_hyperscript.input,\n    button = tagl_hyperscript.button,\n    polygon = tagl_hyperscript.polygon,\n    polyline = tagl_hyperscript.polyline,\n    rect = tagl_hyperscript.rect,\n    circle = tagl_hyperscript.circle,\n    g = tagl_hyperscript.g,\n    foreignObject = tagl_hyperscript.foreignObject,\n    body = tagl_hyperscript.body,\n    pre = tagl_hyperscript.pre,\n    text = tagl_hyperscript.text,\n    textarea = tagl_hyperscript.textarea;\n\n\nvar xres = 60;\nvar yres = Math.round(xres / innerWidth * innerHeight);\n\nyres += yres % 2;\n\nvar time = 0;\n\nsetInterval(function () {\n    time += 0.05;\n    // console.log(velocity)\n    _mithril2.default.redraw();\n}, 50);\n\nvar evilGuy = {\n    x: xres / 2,\n    y: yres / 2\n};\n\nvar player = {\n    x: 0,\n    y: 0\n};\n\nvar velocity = 85;\n\nvar color = function color(x, y) {\n    if (x === player.x && y === player.y) return 'rgba(255,255,255,1)';\n    if (x === evilGuy.x && y === evilGuy.y) return 'rgba(255,255,0,1)';\n\n    var dx = player.x - evilGuy.x;\n    var dy = player.y - evilGuy.y;\n\n    var d1 = Math.sqrt(Math.pow(x - evilGuy.x, 2) + Math.pow(y - evilGuy.y, 2));\n    var d2 = Math.sqrt(Math.pow(x - player.x, 2) + Math.pow(y - player.y, 2));\n\n    var f1 = 0.25 * Math.sin(-d1 - time * velocity) + 0.5;\n    var f2 = -0.25 * Math.sin(-d2 - time * velocity) + 0.5;\n    //   let f1 = 0.5*(Math.sin(evilGuy.x+x)+Math.sin(time) + Math.cos(evilGuy.y+y)+Math.cos(time));\n    //   let f2 = -0.5*(Math.sin(player.x+x)+Math.sin(time) + Math.cos(player.y+y)+Math.cos(time));\n\n    return 'rgba(' + (f1 + f2) * 255 + ',' + Math.cos(f1 + f2) * 255 + ',150,1)';\n};\n\nexports.default = {\n    view: function view(vnode) {\n        return [svg.debug({\n            width: innerWidth,\n            height: innerHeight,\n            style: 'background-color:black',\n            onmousemove: function onmousemove(e) {\n                player.x = Math.round(e.clientX / innerWidth * xres);\n                player.y = Math.round(e.clientY / innerHeight * yres);\n            }\n        }, _fn2.default.range(0, xres).map(function (x) {\n            return _fn2.default.range(0, yres).map(function (y) {\n                return rect.debug({\n                    x: x * innerWidth / xres,\n                    y: y * innerHeight / yres,\n                    width: innerWidth / xres,\n                    height: innerHeight / yres,\n                    //      stroke:'red',\n                    fill: color(x, y)\n                });\n            });\n        })), input({\n            type: 'range',\n            min: 0,\n            max: 200,\n            oninput: _mithril2.default.withAttr('value', function (v) {\n                return velocity = v;\n            }),\n            onchange: _mithril2.default.withAttr('value', function (v) {\n                return velocity = v;\n            })\n        })];\n    }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3dhdmVzLmpzPzk4NmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuaW1wb3J0IGZuIGZyb20gJy4vZm4nO1xuaW1wb3J0IHRhZ2wgZnJvbSAnLi90YWdsJztcblxuXG5jb25zdCBjYW1lbFRvSHlwaGVuID0gcyA9PlxuICAgIHMucmVwbGFjZSgvKFtBLVpdKS9nLCBnID0+IGAtJHtnWzBdLnRvTG93ZXJDYXNlKCl9YCk7XG5cbmNvbnN0IHRhZ2xfaHlwZXJzY3JpcHQgPSB0YWdsKGZ1bmN0aW9uICh0YWdOYW1lLCBjbGFzc2VzLCAuLi5hcmdzKSB7XG4gICAgbGV0IGNscyA9IGNsYXNzZXNcbiAgICAgICAgLm1hcChjYW1lbFRvSHlwaGVuKVxuICAgICAgICAuam9pbignLicpO1xuICAgIHJldHVybiBtKFt0YWdOYW1lLCBjbHNdLmpvaW4oJy4nKS5yZXBsYWNlKCcuJCcsICcjJyksIC4uLmFyZ3MpO1xufSk7XG5cbmNvbnN0IHtcbiAgICBkaXYsXG4gICAgc3ZnLFxuICAgIGlucHV0LFxuICAgIGJ1dHRvbixcbiAgICBwb2x5Z29uLFxuICAgIHBvbHlsaW5lLFxuICAgIHJlY3QsXG4gICAgY2lyY2xlLFxuICAgIGcsXG4gICAgZm9yZWlnbk9iamVjdCxcbiAgICBib2R5LFxuICAgIHByZSxcbiAgICB0ZXh0LFxuICAgIHRleHRhcmVhXG59ID0gdGFnbF9oeXBlcnNjcmlwdDtcblxuXG5sZXQgeHJlcyA9IDYwO1xubGV0IHlyZXMgPSBNYXRoLnJvdW5kKHhyZXMgLyBpbm5lcldpZHRoICogaW5uZXJIZWlnaHQpO1xuXG55cmVzICs9IHlyZXMgJSAyO1xuXG5sZXQgdGltZSA9IDA7XG5cbnNldEludGVydmFsKCgpID0+IHtcbiAgICB0aW1lICs9IDAuMDU7XG4gICAvLyBjb25zb2xlLmxvZyh2ZWxvY2l0eSlcbiAgICBtLnJlZHJhdygpO1xufSwgNTApO1xuXG5sZXQgZXZpbEd1eSA9IHtcbiAgICB4OiB4cmVzIC8gMixcbiAgICB5OiB5cmVzIC8gMlxufTtcblxubGV0IHBsYXllciA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbn07XG5cbmxldCB2ZWxvY2l0eSA9IDg1O1xuXG5jb25zdCBjb2xvciA9ICh4LCB5KSA9PiB7XG4gICAgaWYgKHggPT09IHBsYXllci54ICYmIHkgPT09IHBsYXllci55KVxuICAgICAgICByZXR1cm4gYHJnYmEoMjU1LDI1NSwyNTUsMSlgO1xuICAgIGlmICh4ID09PSBldmlsR3V5LnggJiYgeSA9PT0gZXZpbEd1eS55KVxuICAgICAgICByZXR1cm4gYHJnYmEoMjU1LDI1NSwwLDEpYDtcblxuICAgIGxldCBkeCA9IHBsYXllci54IC0gZXZpbEd1eS54O1xuICAgIGxldCBkeSA9IHBsYXllci55IC0gZXZpbEd1eS55O1xuXG4gICAgbGV0IGQxID0gTWF0aC5zcXJ0KE1hdGgucG93KHggLSBldmlsR3V5LngsIDIpICsgTWF0aC5wb3coeSAtIGV2aWxHdXkueSwgMikpXG4gICAgbGV0IGQyID0gTWF0aC5zcXJ0KE1hdGgucG93KHggLSBwbGF5ZXIueCwgMikgKyBNYXRoLnBvdyh5IC0gcGxheWVyLnksIDIpKVxuXG4gICAgbGV0IGYxID0gMC4yNSAqIChNYXRoLnNpbigtZDEgLSB0aW1lICogdmVsb2NpdHkpKSArIDAuNTtcbiAgICBsZXQgZjIgPSAtMC4yNSAqIChNYXRoLnNpbigtZDIgLSB0aW1lICogdmVsb2NpdHkpKSArIDAuNTtcbiAgICAvLyAgIGxldCBmMSA9IDAuNSooTWF0aC5zaW4oZXZpbEd1eS54K3gpK01hdGguc2luKHRpbWUpICsgTWF0aC5jb3MoZXZpbEd1eS55K3kpK01hdGguY29zKHRpbWUpKTtcbiAgICAvLyAgIGxldCBmMiA9IC0wLjUqKE1hdGguc2luKHBsYXllci54K3gpK01hdGguc2luKHRpbWUpICsgTWF0aC5jb3MocGxheWVyLnkreSkrTWF0aC5jb3ModGltZSkpO1xuXG4gICAgcmV0dXJuIGByZ2JhKCR7KGYxK2YyKSoyNTV9LCR7TWF0aC5jb3MoZjErZjIpKjI1NX0sMTUwLDEpYDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIHJldHVybiBbc3ZnLmRlYnVnKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogaW5uZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGlubmVySGVpZ2h0LFxuICAgICAgICAgICAgICAgIHN0eWxlOiAnYmFja2dyb3VuZC1jb2xvcjpibGFjaycsXG4gICAgICAgICAgICAgICAgb25tb3VzZW1vdmU6IGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIueCA9IE1hdGgucm91bmQoZS5jbGllbnRYIC8gaW5uZXJXaWR0aCAqIHhyZXMpO1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIueSA9IE1hdGgucm91bmQoZS5jbGllbnRZIC8gaW5uZXJIZWlnaHQgKiB5cmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm4ucmFuZ2UoMCwgeHJlcykubWFwKHggPT5cbiAgICAgICAgICAgICAgICBmbi5yYW5nZSgwLCB5cmVzKS5tYXAoeSA9PiByZWN0LmRlYnVnKHtcbiAgICAgICAgICAgICAgICAgICAgeDogeCAqIGlubmVyV2lkdGggLyB4cmVzLFxuICAgICAgICAgICAgICAgICAgICB5OiB5ICogaW5uZXJIZWlnaHQgLyB5cmVzLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogaW5uZXJXaWR0aCAvIHhyZXMsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaW5uZXJIZWlnaHQgLyB5cmVzLFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIHN0cm9rZToncmVkJyxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogY29sb3IoeCwgeSlcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIClcbiAgICAgICAgKSwgaW5wdXQoe1xuICAgICAgICAgICAgdHlwZTogJ3JhbmdlJyxcbiAgICAgICAgICAgIG1pbjowLFxuICAgICAgICAgICAgbWF4OjIwMCxcbiAgICAgICAgICAgIG9uaW5wdXQ6ICBtLndpdGhBdHRyKCd2YWx1ZScsIHYgPT4gdmVsb2NpdHkgPSB2KSxcbiAgICAgICAgICAgIG9uY2hhbmdlOiAgbS53aXRoQXR0cigndmFsdWUnLCB2ID0+IHZlbG9jaXR5ID0gdilcbiAgICAgICAgfSldO1xuICAgIH1cbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy93YXZlcy5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFBQTtBQURBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBTEE7QUFPQTtBQTVCQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///30\n");

/***/ }),
/* 31 */
/*!***********************!*\
  !*** ./src/secret.js ***!
  \***********************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _tagl = __webpack_require__(/*! ./tagl */ 7);\n\nvar _tagl2 = _interopRequireDefault(_tagl);\n\nvar _fn = __webpack_require__(/*! ./fn */ 2);\n\nvar _fn2 = _interopRequireDefault(_fn);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar camelToHyphen = function camelToHyphen(s) {\n  return s.replace(/([A-Z])/g, function (g) {\n    return \"-\" + g[0].toLowerCase();\n  });\n};\n\nvar tagl_hyperscript = (0, _tagl2.default)(function (tagName, classes) {\n  var cls = classes.map(camelToHyphen).join(\".\");\n\n  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key2 = 2; _key2 < _len; _key2++) {\n    args[_key2 - 2] = arguments[_key2];\n  }\n\n  return _mithril2.default.apply(undefined, [[tagName, cls].join(\".\").replace(\".$\", \"#\")].concat(args));\n});\n\nvar input = tagl_hyperscript.input,\n    form = tagl_hyperscript.form,\n    formfield = tagl_hyperscript.formfield,\n    label = tagl_hyperscript.label,\n    a = tagl_hyperscript.a,\n    button = tagl_hyperscript.button,\n    div = tagl_hyperscript.div,\n    span = tagl_hyperscript.span,\n    textarea = tagl_hyperscript.textarea,\n    table = tagl_hyperscript.table,\n    tr = tagl_hyperscript.tr,\n    br = tagl_hyperscript.br,\n    td = tagl_hyperscript.td;\n\n\nvar botschaft = localStorage.getItem(\"botschaft\") || \"\";\nvar dec = true;\nvar save = function save() {\n  return localStorage.setItem(\"botschaft\", botschaft);\n};\n\nvar key = \"\";\n\nvar map = {};\nvar map2 = {};\n\nvar klartext = \"\";\n\nvar arrayify = function arrayify(str) {\n  return _fn2.default.range(0, str.length).map(function (i) {\n    return str[i];\n  });\n};\n\nvar decrypt = function decrypt(_map) {\n  klartext = arrayify(botschaft).map(function (c) {\n    return _map[c] || c;\n  }).join(\"\");\n};\n\nvar alphabet = _fn2.default.range(0, 26).map(function (i) {\n  return \"a\".charCodeAt(0) + i;\n}).map(function (ni) {\n  return String.fromCharCode(ni);\n});\n\nvar setKey = function setKey(_key) {\n  var alphabet = _fn2.default.range(0, 26).map(function (i) {\n    return \"a\".charCodeAt(0) + i;\n  }).map(function (ni) {\n    return String.fromCharCode(ni);\n  });\n  key = _key;\n  var kk = _fn2.default.unique(arrayify(key));\n\n  var newAlphabet = _fn2.default.reverse([].concat(_toConsumableArray(kk), _toConsumableArray(_fn2.default.without(alphabet, kk))));\n\n  map = {};\n  newAlphabet.forEach(function (n, i) {\n    return map[n] = alphabet[i];\n  });\n\n  map2 = {};\n  newAlphabet.forEach(function (n, i) {\n    return map2[alphabet[i]] = n;\n  });\n\n  if (dec) decrypt(map);else decrypt(map2);\n\n  console.log(map);\n};\n\nvar map3 = {};\n\nalphabet.forEach(function (k) {\n  return map3[k] = k;\n});\n\nexports.default = {\n  view: function view(vnode) {\n    return div.container([form(formfield(label(\"Schlüssel\"), input.formControl({\n      value: key,\n      oninput: _mithril2.default.withAttr(\"value\", function (v) {\n        return setKey(v);\n      })\n    })), br(), formfield(label(\"Botschaft\"), textarea.formControl({\n      value: botschaft,\n      oninput: _mithril2.default.withAttr(\"value\", function (v) {\n        return botschaft = v;\n      })\n    })), br(), div.formGroup(button.btn.btnPrimary({\n      onclick: function onclick() {\n        dec = true;\n        setKey(key);\n      }\n    }, \"^^ entschlüsseln\"), span.badge(dec ? \"^\" : \"v\"), button.btn.btnPrimary({\n      onclick: function onclick() {\n        dec = false;\n        setKey(key);\n      }\n    }, \"verschlüsseln vv\"), button.btn.btnSuccess({ onclick: function onclick() {\n        return save();\n      } }, \"Botschaft speichern\")), br(), formfield(label(\"Klartext oder Geheimbotschaft\"), textarea.formControl({\n      value: klartext,\n      oninput: _mithril2.default.withAttr(\"value\", function (v) {\n        return klartext = v;\n      })\n    }))), table.table(tr(Object.keys(map).map(function (k) {\n      return td(map[k]);\n    })), tr(Object.keys(map).map(function (k) {\n      return td(k);\n    }))), table.table(tr(alphabet.map(function (k) {\n      return td(k);\n    })), tr(alphabet.map(function (k) {\n      return td(input.formControl({\n        value: map3[k],\n        oninput: _mithril2.default.withAttr(\"value\", function (v) {\n          map3[k] = v;\n          decrypt(map3);\n        })\n      }));\n    })))\n    /*      br(),\n    br(),\n    table.table(\n      tr(alphabet.map(k => td(k))),\n      tr(alphabet.map(k =>td(Object.keys(map3).filter(map3_key => map3[map3_key] === k)[0] ))),\n      tr(alphabet.map(k => td(k)))\n    )*/\n    //      table(Object.keys(map).map(k => tr(td(map[k]), td(k))))\n    ]);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3NlY3JldC5qcz81MGVkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gXCJtaXRocmlsXCI7XG5pbXBvcnQgdGFnbCBmcm9tIFwiLi90YWdsXCI7XG5pbXBvcnQgZm4gZnJvbSBcIi4vZm5cIjtcblxuY29uc3QgY2FtZWxUb0h5cGhlbiA9IHMgPT4gcy5yZXBsYWNlKC8oW0EtWl0pL2csIGcgPT4gYC0ke2dbMF0udG9Mb3dlckNhc2UoKX1gKTtcblxuY29uc3QgdGFnbF9oeXBlcnNjcmlwdCA9IHRhZ2woZnVuY3Rpb24odGFnTmFtZSwgY2xhc3NlcywgLi4uYXJncykge1xuICBsZXQgY2xzID0gY2xhc3Nlcy5tYXAoY2FtZWxUb0h5cGhlbikuam9pbihcIi5cIik7XG4gIHJldHVybiBtKFt0YWdOYW1lLCBjbHNdLmpvaW4oXCIuXCIpLnJlcGxhY2UoXCIuJFwiLCBcIiNcIiksIC4uLmFyZ3MpO1xufSk7XG5cbmNvbnN0IHtcbiAgaW5wdXQsXG4gIGZvcm0sXG4gIGZvcm1maWVsZCxcbiAgbGFiZWwsXG4gIGEsXG4gIGJ1dHRvbixcbiAgZGl2LFxuICBzcGFuLFxuICB0ZXh0YXJlYSxcbiAgdGFibGUsXG4gIHRyLFxuICBicixcbiAgdGRcbn0gPSB0YWdsX2h5cGVyc2NyaXB0O1xuXG5sZXQgYm90c2NoYWZ0ID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJib3RzY2hhZnRcIikgfHwgXCJcIjtcbmxldCBkZWMgPSB0cnVlO1xuY29uc3Qgc2F2ZSA9ICgpID0+IGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiYm90c2NoYWZ0XCIsIGJvdHNjaGFmdCk7XG5cbmxldCBrZXkgPSBcIlwiO1xuXG5sZXQgbWFwID0ge307XG5sZXQgbWFwMiA9IHt9O1xuXG5sZXQga2xhcnRleHQgPSBcIlwiO1xuXG5jb25zdCBhcnJheWlmeSA9IHN0ciA9PiBmbi5yYW5nZSgwLCBzdHIubGVuZ3RoKS5tYXAoaSA9PiBzdHJbaV0pO1xuXG5jb25zdCBkZWNyeXB0ID0gX21hcCA9PiB7XG4gIGtsYXJ0ZXh0ID0gYXJyYXlpZnkoYm90c2NoYWZ0KVxuICAgIC5tYXAoYyA9PiBfbWFwW2NdIHx8IGMpXG4gICAgLmpvaW4oXCJcIik7XG59O1xuXG5jb25zdCBhbHBoYWJldCA9IGZuXG4gIC5yYW5nZSgwLCAyNilcbiAgLm1hcChpID0+IFwiYVwiLmNoYXJDb2RlQXQoMCkgKyBpKVxuICAubWFwKG5pID0+IFN0cmluZy5mcm9tQ2hhckNvZGUobmkpKTtcblxuY29uc3Qgc2V0S2V5ID0gX2tleSA9PiB7XG4gIGxldCBhbHBoYWJldCA9IGZuXG4gICAgLnJhbmdlKDAsIDI2KVxuICAgIC5tYXAoaSA9PiBcImFcIi5jaGFyQ29kZUF0KDApICsgaSlcbiAgICAubWFwKG5pID0+IFN0cmluZy5mcm9tQ2hhckNvZGUobmkpKTtcbiAga2V5ID0gX2tleTtcbiAgbGV0IGtrID0gZm4udW5pcXVlKGFycmF5aWZ5KGtleSkpO1xuXG4gIGxldCBuZXdBbHBoYWJldCA9IGZuLnJldmVyc2UoWy4uLmtrLCAuLi5mbi53aXRob3V0KGFscGhhYmV0LCBrayldKTtcblxuICBtYXAgPSB7fTtcbiAgbmV3QWxwaGFiZXQuZm9yRWFjaCgobiwgaSkgPT4gKG1hcFtuXSA9IGFscGhhYmV0W2ldKSk7XG5cbiAgbWFwMiA9IHt9O1xuICBuZXdBbHBoYWJldC5mb3JFYWNoKChuLCBpKSA9PiAobWFwMlthbHBoYWJldFtpXV0gPSBuKSk7XG5cbiAgaWYgKGRlYykgZGVjcnlwdChtYXApO1xuICBlbHNlIGRlY3J5cHQobWFwMik7XG5cbiAgY29uc29sZS5sb2cobWFwKTtcbn07XG5cbmxldCBtYXAzID0ge307XG5cbmFscGhhYmV0LmZvckVhY2goayA9PiAobWFwM1trXSA9IGspKTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2aWV3KHZub2RlKSB7XG4gICAgcmV0dXJuIGRpdi5jb250YWluZXIoW1xuICAgICAgZm9ybShcbiAgICAgICAgZm9ybWZpZWxkKFxuICAgICAgICAgIGxhYmVsKFwiU2NobMO8c3NlbFwiKSxcbiAgICAgICAgICBpbnB1dC5mb3JtQ29udHJvbCh7XG4gICAgICAgICAgICB2YWx1ZToga2V5LFxuICAgICAgICAgICAgb25pbnB1dDogbS53aXRoQXR0cihcInZhbHVlXCIsIHYgPT4gc2V0S2V5KHYpKVxuICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICAgIGJyKCksXG4gICAgICAgIGZvcm1maWVsZChcbiAgICAgICAgICBsYWJlbChcIkJvdHNjaGFmdFwiKSxcbiAgICAgICAgICB0ZXh0YXJlYS5mb3JtQ29udHJvbCh7XG4gICAgICAgICAgICB2YWx1ZTogYm90c2NoYWZ0LFxuICAgICAgICAgICAgb25pbnB1dDogbS53aXRoQXR0cihcInZhbHVlXCIsIHYgPT4gKGJvdHNjaGFmdCA9IHYpKVxuICAgICAgICAgIH0pXG4gICAgICAgICksICAgICAgICBcbiAgICAgICAgYnIoKSxcbiAgICAgICAgZGl2LmZvcm1Hcm91cChcbiAgICAgICAgICBidXR0b24uYnRuLmJ0blByaW1hcnkoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNldEtleShrZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJeXiBlbnRzY2hsw7xzc2VsblwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICBzcGFuLmJhZGdlKGRlYyA/IFwiXlwiIDogXCJ2XCIpLFxuICAgICAgICAgIGJ1dHRvbi5idG4uYnRuUHJpbWFyeShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb25jbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNldEtleShrZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ2ZXJzY2hsw7xzc2VsbiB2dlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICBidXR0b24uYnRuLmJ0blN1Y2Nlc3MoXG4gICAgICAgICAgICB7IG9uY2xpY2s6ICgpID0+IHNhdmUoKSB9LFxuICAgICAgICAgICAgXCJCb3RzY2hhZnQgc3BlaWNoZXJuXCJcbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIGJyKCksXG4gICAgICAgIGZvcm1maWVsZChcbiAgICAgICAgICBsYWJlbChcIktsYXJ0ZXh0IG9kZXIgR2VoZWltYm90c2NoYWZ0XCIpLFxuICAgICAgICAgIHRleHRhcmVhLmZvcm1Db250cm9sKHtcbiAgICAgICAgICAgIHZhbHVlOiBrbGFydGV4dCxcbiAgICAgICAgICAgIG9uaW5wdXQ6IG0ud2l0aEF0dHIoXCJ2YWx1ZVwiLCB2ID0+IChrbGFydGV4dCA9IHYpKVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICB0YWJsZS50YWJsZShcbiAgICAgICAgdHIoT2JqZWN0LmtleXMobWFwKS5tYXAoayA9PiB0ZChtYXBba10pKSksXG4gICAgICAgIHRyKE9iamVjdC5rZXlzKG1hcCkubWFwKGsgPT4gdGQoaykpKVxuICAgICAgKSxcbiAgICAgIHRhYmxlLnRhYmxlKFxuICAgICAgICB0cihhbHBoYWJldC5tYXAoayA9PiB0ZChrKSkpLFxuICAgICAgICB0cihcbiAgICAgICAgICBhbHBoYWJldC5tYXAoayA9PlxuICAgICAgICAgICAgdGQoXG4gICAgICAgICAgICAgIGlucHV0LmZvcm1Db250cm9sKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWFwM1trXSxcbiAgICAgICAgICAgICAgICBvbmlucHV0OiBtLndpdGhBdHRyKFwidmFsdWVcIiwgdiA9PiB7XG4gICAgICAgICAgICAgICAgICBtYXAzW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgIGRlY3J5cHQobWFwMyk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICAgIC8qICAgICAgYnIoKSxcbiAgICAgIGJyKCksXG4gICAgICB0YWJsZS50YWJsZShcbiAgICAgICAgdHIoYWxwaGFiZXQubWFwKGsgPT4gdGQoaykpKSxcbiAgICAgICAgdHIoYWxwaGFiZXQubWFwKGsgPT50ZChPYmplY3Qua2V5cyhtYXAzKS5maWx0ZXIobWFwM19rZXkgPT4gbWFwM1ttYXAzX2tleV0gPT09IGspWzBdICkpKSxcbiAgICAgICAgdHIoYWxwaGFiZXQubWFwKGsgPT4gdGQoaykpKVxuICAgICAgKSovXG4gICAgICAvLyAgICAgIHRhYmxlKE9iamVjdC5rZXlzKG1hcCkubWFwKGsgPT4gdHIodGQobWFwW2tdKSwgdGQoaykpKSlcbiAgICBdKTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvc2VjcmV0LmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7Ozs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBU0E7QUFDQTtBQUFBO0FBQUE7QUFGQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBU0E7QUFBQTtBQVFBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFPQTtBQUFBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUZBO0FBYUE7Ozs7Ozs7QUFPQTtBQS9FQTtBQWlGQTtBQW5GQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///31\n");

/***/ })
/******/ ]);